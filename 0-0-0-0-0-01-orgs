def simulate_clone_and_rename_client_lists_debug(session, base_url, config_id, version, access_group, section=None):
    print(f"[DEBUG] Simulating clone and rename of client lists for access group: {access_group}")
    summary = {
        "processed": 0,
        "to_clone": [],
        "skipped_active": [],
        "skipped_existing": []
    }

    url = f"{base_url}/client-list/v1/lists?includeDeprecated=true&includeNetworkLists=true"
    try:
        response = session.get(url)
        response.raise_for_status()
        client_lists = response.json().get("content", [])
    except Exception as e:
        print(f"[ERROR] Failed to fetch client lists: {e}")
        return summary

    # Group all client lists by name for full visibility of duplicates
    existing_lists_by_name = {}
    for cl in client_lists:
        name = cl.get("name", "")
        existing_lists_by_name.setdefault(name, []).append(cl)

    for cl in client_lists:
        try:
            name = cl.get("name", "")
            list_id = cl.get("listId")
            if "Security Policy Template" not in name:
                continue  # only template source lists

            suffix = name.replace("Security Policy Template", "").strip()
            new_name = f"SC-{access_group}-{suffix}"

            matches = existing_lists_by_name.get(new_name, [])
            if any(not m.get("availableActions", {}).get("DELETE", {}).get("available", True) for m in matches):
                print(f"[DEBUG] Skipping '{new_name}' â€” at least one active (non-deletable) instance exists")
                for m in matches:
                    print(f"    [EXISTING] listId: {m.get('listId')} | DELETE available: {m.get('availableActions', {}).get('DELETE', {}).get('available')}")
                summary["skipped_existing"].append(new_name)
                continue

            print(f"[INFO] Would clone: '{name}' -> '{new_name}' using listId: {list_id}")
            if matches:
                print(f"    [NOTE] Existing inactive entries found for {new_name}, but all are deletable, safe to re-clone.")
                for m in matches:
                    print(f"        listId: {m.get('listId')} | DELETE available: {m.get('availableActions', {}).get('DELETE', {}).get('available')}")
            summary["to_clone"].append(new_name)
            summary["processed"] += 1

        except Exception as e:
            print(f"[ERROR] Unexpected error processing list '{name}': {e}")

    from pprint import pprint
    print("\n[DEBUG] Clone Summary:")
    pprint(summary)
    return summary
