def update_rate_policies(session, base_url, config_id, version, access_group,
                         search_client_lists_by_id, search_client_lists_by_name):
    result = {"processed": 0, "successful": 0, "failed": 0, "skipped": 0, "details": []}
    get_url = f"{base_url}/appsec/v1/configs/{config_id}/versions/{version}/rate-policies"

    try:
        response = session.get(get_url)
        response.raise_for_status()
        policies = response.json().get("ratePolicies", [])
    except Exception as e:
        print(f"[ERROR] Failed to fetch rate policies: {e}")
        return result

    result["processed"] = len(policies)

    for policy in policies:
        policy_id = policy.get("id")
        original_name = policy.get("name", "")
        updated_name = original_name
        updated = False

        # 1. Fetch full policy JSON to use as payload base
        get_policy_url = f"{get_url}/{policy_id}"
        try:
            policy_response = session.get(get_policy_url)
            policy_response.raise_for_status()
            full_policy = policy_response.json()
        except Exception as e:
            result["failed"] += 1
            result["details"].append({
                "id": policy_id,
                "name": original_name,
                "status": "failed",
                "error": f"Failed to fetch policy: {e}"
            })
            continue

        # 2. Rename policy if it contains 'Security Policy Template'
        if "Security Policy Template" in original_name:
            suffix = original_name.split("Security Policy Template")[-1].strip()
            updated_name = f"SC-{access_group} {suffix}"
            full_policy["name"] = updated_name
            updated = True

        # 3. Update client list references in additionalMatchOptions
        new_match_options = []
        for option in full_policy.get("additionalMatchOptions", []):
            if option.get("type") == "NetworkListCondition":
                new_values = []
                for original_id in option.get("values", []):
                    matches = search_client_lists_by_id(session, base_url, original_id)
                    if not matches:
                        result["failed"] += 1
                        result["details"].append({
                            "id": policy_id,
                            "name": updated_name,
                            "status": "skipped",
                            "reason": f"No match found for list ID: {original_id}"
                        })
                        break
                    original_name_match = matches[0][1]
                    if "Security Policy Template" not in original_name_match:
                        result["failed"] += 1
                        result["details"].append({
                            "id": policy_id,
                            "name": updated_name,
                            "status": "skipped",
                            "reason": f"Template name not found for list ID: {original_id}"
                        })
                        break

                    suffix = original_name_match.split("Security Policy Template")[-1].strip()
                    new_lookup = f"SC-{access_group} {suffix}"
                    new_match = search_client_lists_by_name(session, base_url, new_lookup)
                    if not new_match:
                        result["failed"] += 1
                        result["details"].append({
                            "id": policy_id,
                            "name": updated_name,
                            "status": "skipped",
                            "reason": f"No matching client list found for: {new_lookup}"
                        })
                        break

                    new_values.append(new_match[0][0])  # only List ID
                else:
                    option["values"] = new_values
                    new_match_options.append(option)
                    updated = True
            else:
                new_match_options.append(option)

        full_policy["additionalMatchOptions"] = new_match_options

        # 4. Sanitize payload by removing read-only / non-updatable fields
        for readonly_field in ["id", "createDate", "updateDate", "used"]:
            full_policy.pop(readonly_field, None)

        # 5. Submit updated policy
        if updated:
            put_url = f"{get_url}/{policy_id}"
            try:
                print("Payload:", json.dumps(full_policy, indent=2))  # for debug
                put_response = session.put(put_url, json=full_policy)
                put_response.raise_for_status()
                result["successful"] += 1
                result["details"].append({
                    "id": policy_id,
                    "name": updated_name,
                    "status": "success"
                })
            except Exception as e:
                result["failed"] += 1
                result["details"].append({
                    "id": policy_id,
                    "name": updated_name,
                    "status": "failed",
                    "error": str(e)
                })
        else:
            result["skipped"] += 1
            result["details"].append({
                "id": policy_id,
                "name": updated_name,
                "status": "skipped"
            })

    return result
