"""
===================================================================================
                    Akamai Application Security Config Generator (via Jinja + YAML)
===================================================================================
Script Name:
    akamai_config_generator.py

Description:
    This script generates Akamai AppSec configuration JSON files using modular Jinja templates
    and a central YAML configuration file. It supports rendering the following config modules:

        • Client Lists
        • Custom Bots
        • Custom Rules
        • Rate Limits
        • WAF Rule Exceptions
        • WAF Group Actions
        • Akamai Bot Category Actions

    The output JSONs are intended for use with Akamai's AppSec APIs to create or update security
    configurations in an automated CI/CD pipeline (e.g., Jenkins). This generator supports dry-run
    mode and can be extended to include Akamai API calls post-render.

Parameters:
    --config (required)       : Path to the YAML configuration file (e.g. appsec_config.yaml)
    --template_dir (required) : Directory containing Jinja2 template files
    --output_dir (required)   : Directory where the rendered JSON files will be saved
    --dry_run (optional)      : If specified, only renders files; does not trigger Akamai API calls

Usage:
    python akamai_config_generator.py \
        --config configs/appsec_config.yaml \
        --template_dir templates \
        --output_dir output \
        --dry_run

Example:  python akamai_config_generator.py --config config/appsec_config.yaml --template_dir templates --output_dir generated --dry_run
===================================================================================
"""

import os
import sys
import yaml
import json
import argparse
import requests
from jinja2 import Environment, FileSystemLoader
from akamai.edgegrid import EdgeGridAuth, EdgeRc

# ----- REGION SETTINGS -----
REGION_SETTINGS = {
    "Global":  {"parent_group_name": "HSBC-DDos-KSD-D-2YN4YRH", "contract_id": "P-2YN4YRH", "group_id": "154041"},
    "APAC":    {"parent_group_name": "HSBC - APAC-V-5A82LRN",   "contract_id": "V-5A82LRN", "group_id": "272084"},
    "EMEA":    {"parent_group_name": "HSBC - EMEA-V-5A82MHB",   "contract_id": "V-5A82MHB", "group_id": "272093"},
    "LATAM":   {"parent_group_name": "HSBC-AMER -LATAM(V-5A854K9)",  "contract_id": "V-5A854K9", "group_id": "272094"},
    "AMER":    {"parent_group_name": "HSBC-AMER -LATAM(V-5A854K9)",  "contract_id": "V-5A854K9", "group_id": "272094"},
    "DEV":     {"parent_group_name": "HSBC - DEV (V-5A82MTA)",    "contract_id": "V-5A82MTA", "group_id": "272095"}
}

def load_yaml_config(config_path):
    with open(config_path, 'r') as f:
        return yaml.safe_load(f)

def render_template(env, template_file, data):
    template = env.get_template(template_file)
    return template.render(data)

def save_rendered_output(output_dir, name, content):
    os.makedirs(output_dir, exist_ok=True)
    output_path = os.path.join(output_dir, name)
    with open(output_path, 'w') as f:
        f.write(content)
    print(f"Rendered output saved: {output_path}")

def setup_session(edgerc_file, section_name):
    try:
        print(f"[DEBUG] Reading .edgerc from: {os.path.expanduser(edgerc_file)}")
        print(f"[DEBUG] Requested section: {section_name}")

        edgerc = EdgeRc(os.path.expanduser(edgerc_file))
        if not edgerc.has_section(section_name):
            raise ValueError(f"[ERROR] Section '{section_name}' not found in .edgerc. Available sections: {[s for s in edgerc.sections()]}")

        base_url = "https://" + edgerc.get(section_name, 'host')
        client_token = edgerc.get(section_name, 'client_token')
        client_secret = edgerc.get(section_name, 'client_secret')
        access_token = edgerc.get(section_name, 'access_token')

        session = requests.Session()
        session.auth = EdgeGridAuth(
            client_token=client_token,
            client_secret=client_secret,
            access_token=access_token
        )

        session.headers.update({"Content-Type": "application/json"})
        return session, base_url
    except Exception as e:
        raise RuntimeError(f"Error loading .edgerc section '{section_name}': {e}")
    
def get_config_id(session, base_url, config_name):
    url = f"{base_url}/appsec/v1/configs"
    resp = session.get(url)
    resp.raise_for_status()
    for cfg in resp.json().get("configurations", []):
        if cfg["name"] == config_name:
            print(f"[INFO] Found config '{config_name}' (ID: {cfg['id']})")
            return cfg["id"], cfg["latestVersion"]
    raise ValueError(f"Configuration '{config_name}' not found.")

def post_config_items(session, base_url, config_id, version, file_path, endpoint, label):
    if not os.path.exists(file_path):
        print(f"No {label}.json found. Skipping...")
        return
    with open(file_path) as f:
        items = json.load(f)
    for item in items:
        url = f"{base_url}/appsec/v1/configs/{config_id}/versions/{version}/{endpoint}"
        r = session.post(url, json=item)
        if r.status_code in (200, 201):
            print(f"✓ Created {label}: {item.get('name', item.get('id', 'unnamed'))}")
        else:
            print(f"✗ Failed to create {label}: {item.get('name', item.get('id', 'unnamed'))}")
            print(r.status_code, r.text)

def create_appsec_config(session, base_url, config_name, contract_id, group_id, hostnames, description):
    url = f"{base_url}/appsec/v1/configs"
    payload = {
        "name": config_name,
        "contractId": contract_id,
        "groupId": int(group_id),
        "hostnames": hostnames,
        "description": description
    }
    print(f"[INFO] Creating AppSec config '{config_name}'")
    print(json.dumps(payload, indent=2))
    resp = session.post(url, json=payload)
    if resp.status_code in [200, 201]:
        cfg = resp.json()
        print(f"[OK] Created configuration ID {cfg['id']}")
        return cfg["id"], 1
    raise RuntimeError(f"[ERROR] Failed to create config: {resp.status_code} {resp.text}")

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--config', default='config/appsec_config.yaml', required=True, help='Path to YAML config file')
    parser.add_argument('--template_dir', default='templates', required=True, help='Path to directory of Jinja templates')
    parser.add_argument('--output_dir', default='generated', required=True, help='Where to save rendered JSON files')
    parser.add_argument('--dry_run', action='store_true', help='Do not call Akamai APIs')
    parser.add_argument('--edgerc_file', default="~/.edgerc", help='Path to the .edgerc file')
    parser.add_argument('--account', default='DEV', help='Section name in .edgerc (default: DEV)')
    args = parser.parse_args()

    account = args.account
    session, base_url = setup_session(args.edgerc_file, account)
    region = REGION_SETTINGS[account]
    contract_id = region["contract_id"]
    group_id = region["group_id"]

    meta_path = os.path.join(args.output_dir, "config_metadata.json")
    if not os.path.exists(meta_path):
        print(f"[FATAL] config_metadata.json not found at {meta_path}")
        sys.exit(1)

    with open(meta_path, "r") as f:
        metadata = json.load(f)

    config_name = metadata["configuration_name"]
    hostnames = metadata.get("hostnames", [])
    description = metadata.get("description", "Created by onboarding automation.")

    if not hostnames:
        raise ValueError("Hostnames list in config_matadata.json cannot be emopty.")
    
    try:
        config_id, version = get_config_id(session, base_url, config_name)
    except ValueError:
        print(f"[INFO] Configuration '{config_name}' not found. Attempting to create it...")
        try:
            config_id, version = create_appsec_config(
                session, base_url, config_name,
                contract_id, group_id, hostnames, description
            )
        except Exception as e:
            print(f"[FATAL] Could not create configuration: {e}")
            sys.exit(1)

    print(f"[SUCCESS] Config ID: {config_id}, Version: {version}")

    config = load_yaml_config(args.config)
    env = Environment(loader=FileSystemLoader(args.template_dir), trim_blocks=True, lstrip_blocks=True)

    output = render_template(env, 'config_metadata.j2', config)
    save_rendered_output(args.output_dir, 'config_metadata.json', output)

    if 'client_lists' in config:
        output = render_template(env, 'client_list_template.j2', config)
        save_rendered_output(args.output_dir, 'client_lists.json', output)

    if 'custom_rules' in config:
        output = render_template(env, 'custom_rule_template.j2', config)
        save_rendered_output(args.output_dir, 'custom_rules.json', output)

    if 'custom_bots' in config:
        output = render_template(env, 'custom_bot_templates.j2', config)
        save_rendered_output(args.output_dir, 'custom_bots.json', output)

    if 'rate_limits' in config:
        output = render_template(env, 'rate_limit_template.j2', config)
        save_rendered_output(args.output_dir, 'rate_limits.json', output)

    if 'waf_rule_exceptions' in config:
        output = render_template(env, 'waf_rule_exceptions_template.j2', config)
        save_rendered_output(args.output_dir, 'waf_rule_exceptions.json', output)

    if 'waf_group_actions' in config:
        output = render_template(env, 'waf_group_actions_template.j2', config)
        save_rendered_output(args.output_dir, 'waf_group_actions.json', output)

    if 'akamai_bot_category_actions' in config:
        output = render_template(env, 'akamai_bot_category_actions_template.j2', config)
        save_rendered_output(args.output_dir, 'akamai_bot_category_actions.json', output)

    print("\n All templates rendered.")

    if not args.dry_run:
        print("\n Importing configs to Akamai AppSec...")

        metadata_path = os.path.join(args.output_dir, "config_metadata.json")
        with open(metadata_path) as f:
            metadata = json.load(f)

        section_name = args.account
        session, base_url = setup_session(args.edgerc_file, section_name)
        config_id, version = get_config_id(session, base_url, metadata["configuration_name"])
        print(f"Connected to Akamai: Config ID = {config_id}, Version = {version}\n")

        post_config_items(session, base_url, config_id, version, os.path.join(args.output_dir, "client_lists.json"), "client-lists", "client_list")
        post_config_items(session, base_url, config_id, version, os.path.join(args.output_dir, "custom_bots.json"), "custom-bots", "custom_bot")
        post_config_items(session, base_url, config_id, version, os.path.join(args.output_dir, "custom_rules.json"), "custom-rules", "custom_rule")
        post_config_items(session, base_url, config_id, version, os.path.join(args.output_dir, "rate_limits.json"), "rate-policies", "rate_limit")
        post_config_items(session, base_url, config_id, version, os.path.join(args.output_dir, "waf_rule_exceptions.json"), "rules/exceptions", "waf_rule_exception")
        post_config_items(session, base_url, config_id, version, os.path.join(args.output_dir, "waf_group_actions.json"), "rules/groups", "waf_group_action")
        post_config_items(session, base_url, config_id, version, os.path.join(args.output_dir, "akamai_bot_category_actions.json"), "botman/actions", "akamai_bot_category_action")

        print("\n Import complete.")

if __name__ == '__main__':
    main()
