#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
CI/CD Debugging Interview — Candidate-Safe Runner (v2)
=====================================================

Overview
--------
Run a Zoom-friendly CI/CD troubleshooting session. The candidate sees a **buggy
snippet** (GitLab CI, GitHub Actions, or Jenkins) and three **randomized** fix
options (A/B/C). You type their choice. The app **does not** reveal correctness
on screen (unless you choose to print the summary at the end). Results are saved
to CSVs, plus an optional one-page PDF summary (no question details).

What's new in v2
----------------
- New `--tool` filter to choose platform(s): `gitlab`, `github`, `jenkins`.
  Use one or multiple: e.g. `--tool gitlab jenkins`. `--all` still runs
  everything; `--pick` still selects specific exercise numbers.
- Each exercise now has a `platform` tag internally for filtering.

Outputs
-------
- **Summary CSV**: one row per exercise (choice, pass/fail, totals, percentage).
- **Details CSV**: buggy snippet, chosen option, correct option (if wrong), and
  a short interviewer-only explanation.
- **PDF Summary** (optional): one-page summary (candidate name, timestamp,
  PASS/FAIL per exercise, overall score).

Usage Examples
--------------
# Run *all* exercises
python cicd_interview_runner_v2.py --all --name "Jane Doe"

# Only GitLab CI
python cicd_interview_runner_v2.py --tool gitlab --name "Jane Doe"

# GitLab + Jenkins
python cicd_interview_runner_v2.py --tool gitlab jenkins --shuffle --pause --name "Alex"

# Pick specific questions (by number), no on-screen results
python cicd_interview_runner_v2.py --pick 2 5 9 --name "John" --no-display-results

# Full run with PDF summary
python cicd_interview_runner_v2.py --all --name "Alice" --pdf

Flags
-----
--all                 Run all exercises (default is interactive single-pick).
--tool T [T ...]      Filter by platform(s): gitlab, github, jenkins.
--pick N [N ...]      Run explicit exercise numbers.
--shuffle             Shuffle chosen exercises.
--limit N             Limit number of exercises after selection/shuffle.
--pause               Pause after each exercise and clear the screen.
--time-limit SEC      Seconds allowed to enter a choice (0 = unlimited).
--output-dir DIR      Directory to save results (default: current dir).
--results-file FILE   Explicit summary CSV filename.
--details-file FILE   Explicit details CSV filename.
--pdf                 Write one-page PDF summary (no details).
--pdf-file FILE       Explicit PDF filename (optional).
--name NAME           Candidate name (otherwise prompted).
--no-display-results  Suppress final results printout (files still saved).

Dependencies
------------
Pure standard library (Python 3). No external packages required.
"""
import sys, os, time, random, argparse, csv, re
from datetime import datetime

# ----------------------------
# Utilities
# ----------------------------
def _print_header(title):
    print("\n" + "="*70)
    print(title)
    print("="*70)

def timed_input(prompt, timeout=0.0):
    if not timeout or timeout <= 0:
        return input(prompt), False
    if os.name == "nt":
        import msvcrt, time as _t
        sys.stdout.write(prompt); sys.stdout.flush()
        chars, t0 = [], _t.time()
        while True:
            if msvcrt.kbhit():
                ch = msvcrt.getwch()
                if ch in ("\r","\n"):
                    print(); return "".join(chars), False
                if ch == "\003":
                    raise KeyboardInterrupt
                if ch == "\b":
                    if chars:
                        chars.pop()
                        sys.stdout.write("\b \b"); sys.stdout.flush()
                else:
                    chars.append(ch)
                    sys.stdout.write(ch); sys.stdout.flush()
            if _t.time() - t0 >= timeout:
                print(); return "".join(chars), True
            _t.sleep(0.01)
    else:
        import select
        sys.stdout.write(prompt); sys.stdout.flush()
        r,_,_ = select.select([sys.stdin],[],[],timeout)
        if r:
            return sys.stdin.readline().rstrip("\n"), False
        print(); return "", True

def sanitize_filename(s):
    s = re.sub(r"\s+","_", s.strip())
    return re.sub(r"[^A-Za-z0-9._-]","", s) or "candidate"

# ----------------------------
# Minimal single-page PDF (text-only, no deps)
# ----------------------------
def _esc(s): return s.replace("\\","\\\\").replace("(","\\(").replace(")","\\)")

def write_summary_pdf(path, title, name, ts, lines, footer):
    width, height = 595, 842; y = height-56; leading=16
    out = bytearray(b"%PDF-1.4\n"); xref=[0]
    out_lines=[]
    def add(sz, text):
        nonlocal y
        out_lines.append(f"BT /F1 {sz} Tf 50 {y} Td ({_esc(text)}) Tj ET")
        y -= leading
    add(16, title); y -= 6
    add(12, f"Candidate: {name}")
    add(12, f"Timestamp: {ts}"); y -= 6
    for ln in lines:
        if y < 80: break
        add(12, ln)
    y -= leading
    for ln in footer:
        if y < 60: break
        add(12, ln)
    stream = "\n".join(out_lines).encode("latin-1","replace")

    def obj(payload):
        xref.append(len(out))
        if not payload.endswith(b"\n"):
            payload += b"\n"
        out.extend(payload)
        out.extend(b"endobj\n")

    obj(b"1 0 obj\n<< /Type /Catalog /Pages 2 0 R >>")
    obj(b"2 0 obj\n<< /Type /Pages /Kids [3 0 R] /Count 1 >>")
    obj(f"3 0 obj\n<< /Type /Page /Parent 2 0 R /MediaBox [0 0 {width} {height}] /Resources << /Font << /F1 5 0 R >> >> /Contents 4 0 R >>".encode())
    obj(b"4 0 obj\n<< /Length "+str(len(stream)).encode()+b" >>\nstream\n"+stream+b"\nendstream")
    obj(b"5 0 obj\n<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>")
    xref_pos = len(out)
    out.extend(b"xref\n"); out.extend(f"0 {len(xref)}\n".encode())
    out.extend(b"0000000000 65535 f \n")
    for off in xref[1:]:
        out.extend(f"{off:010d} 00000 n \n".encode())
    out.extend(b"trailer\n"); out.extend(f"<< /Size {len(xref)} /Root 1 0 R >>\n".encode())
    out.extend(b"startxref\n"); out.extend(f"{xref_pos}\n".encode()); out.extend(b"%%EOF")
    with open(path,"wb") as f: f.write(out)

# ----------------------------
# Exercises (12 total) with platform tags
# ----------------------------
EX = {
# ---------- GitLab CI ----------
1: {"platform":"gitlab",
    "title":"GitLab CI — Snippet 1", "desc":"Review and choose the correct version.",
    "buggy": """# .gitlab-ci.yml
build-job:
  script:
    - echo "Running tests"
""",
    "options":[
        {"ok":True,"code":"""build-job:
  stage: build
  script:
    - echo "Running tests"
""","explanation":"Jobs typically declare a stage (or rely on defaults)."},
        {"ok":False,"code":"""build-job:
  only: [ master ]
  script:
    - echo "Running tests"
"""},
        {"ok":False,"code":"""stage: build
script:
  - echo "Running tests"
"""},
    ]},

2: {"platform":"gitlab",
    "title":"GitLab CI — Snippet 2", "desc":"Review and choose the correct version.",
    "buggy": """# .gitlab-ci.yml
test-job:
  stage: test
  script: echo "Hello"
""",
    "options":[
        {"ok":True,"code":"""test-job:
  stage: test
  script:
    - echo "Hello"
""","explanation":"`script` must be a YAML sequence (dashed list)."},
        {"ok":False,"code":"""test-job:
  stage: test
  script:
    echo "Hello"
"""},
        {"ok":False,"code":"""test-job:
  stage: test
  run:
    - echo "Hello"
"""},
    ]},

3: {"platform":"gitlab",
    "title":"GitLab CI — Snippet 3", "desc":"Review and choose the correct version.",
    "buggy": """# .gitlab-ci.yml
image-job:
  image: ubuntu:latest:extra
  script:
    - echo "Using image"
""",
    "options":[
        {"ok":True,"code":"""image-job:
  image: ubuntu:latest
  script:
    - echo "Using image"
""","explanation":"Docker tag must be `name:tag` (single colon)."},
        {"ok":False,"code":"""image-job:
  image: latest/ubuntu
  script:
    - echo "Using image"
"""},
        {"ok":False,"code":"""image-job:
  image:
    name: ubuntu
    tag: latest:foo
  script:
    - echo "Using image"
"""},
    ]},

4: {"platform":"gitlab",
    "title":"GitLab CI — Snippet 4", "desc":"Review and choose the correct version.",
    "buggy": """# .gitlab-ci.yml
job-with-var:
  stage: build
  script:
    - echo VAR
""",
    "options":[
        {"ok":True,"code":"""job-with-var:
  stage: build
  script:
    - echo $VAR
""","explanation":"Use shell variable expansion `$VAR` (or `${VAR}`)."},
        {"ok":False,"code":"""job-with-var:
  stage: build
  script:
    - echo ${VAR}
    - set -u
"""},
        {"ok":False,"code":"""job-with-var:
  stage: build
  script:
    - echo "$(VAR)"
"""},
    ]},

# ---------- GitHub Actions ----------
5: {"platform":"github",
    "title":"GitHub Actions — Snippet 5", "desc":"Review and choose the correct version.",
    "buggy": """# .github/workflows/main.yml
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - run: echo "Test"
onn:
  push:
    branches: [ main ]
""",
    "options":[
        {"ok":True,"code":"""on:
  push:
    branches: [ main ]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - run: echo "Test"
""","explanation":"Top-level trigger key is `on`, not `onn`. Keys must be correct."},
        {"ok":False,"code":"""trigger:
  push:
    branches: [ main ]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - run: echo "Test"
"""},
        {"ok":False,"code":"""on: push
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - run: echo "Test"
"""},
    ]},

6: {"platform":"github",
    "title":"GitHub Actions — Snippet 6", "desc":"Review and choose the correct version.",
    "buggy": """# .github/workflows/main.yml
on: [ push ]
jobs:
  test:
    runs-on: ubuntu-latest
    - run: echo "Hello"
""",
    "options":[
        {"ok":True,"code":"""on: [ push ]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - run: echo "Hello"
""","explanation":"Each job needs a `steps:` sequence; list items belong under it."},
        {"ok":False,"code":"""on: [ push ]
jobs:
  test:
    steps:
      - run: echo "Hello"
"""},
        {"ok":False,"code":"""on: [ push ]
jobs:
  test:
    runs-on: ubuntu-latest
    scripts:
      - run: echo "Hello"
"""},
    ]},

7: {"platform":"github",
    "title":"GitHub Actions — Snippet 7", "desc":"Review and choose the correct version.",
    "buggy": """# .github/workflows/main.yml
on: [ push ]
jobs:
  matrix-job:
    runs-on: ubuntu-latest
  strategy:
    matrix:
      node-version: [12, 14, 16]
    steps:
      - run: node --version
""",
    "options":[
        {"ok":True,"code":"""on: [ push ]
jobs:
  matrix-job:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [12, 14, 16]
    steps:
      - run: node --version
""","explanation":"`strategy` must be inside the job (same level as `runs-on`/`steps`)."},
        {"ok":False,"code":"""on: [ push ]
strategy:
  matrix:
    node-version: [12, 14, 16]
jobs:
  matrix-job:
    runs-on: ubuntu-latest
    steps:
      - run: node --version
"""},
        {"ok":False,"code":"""on: [ push ]
jobs:
  matrix-job:
    runs-on: ubuntu-latest
    steps:
      - strategy:
          matrix:
            node-version: [12, 14, 16]
      - run: node --version
"""},
    ]},

8: {"platform":"github",
    "title":"GitHub Actions — Snippet 8", "desc":"Review and choose the correct version.",
    "buggy": """# .github/workflows/main.yml
on: [ push, workflow_dispatch ]
jobs:
  conditional:
    runs-on: ubuntu-latest
    steps:
      - run: echo "Conditional"
        if: github.event_name == push
""",
    "options":[
        {"ok":True,"code":"""on: [ push, workflow_dispatch ]
jobs:
  conditional:
    runs-on: ubuntu-latest
    steps:
      - run: echo "Conditional"
        if: github.event_name == 'push'
""","explanation":"Compare against a quoted string in expressions: `'push'`."},
        {"ok":False,"code":"""on: [ push, workflow_dispatch ]
jobs:
  conditional:
    runs-on: ubuntu-latest
    steps:
      - run: echo "Conditional"
        if: github.event == 'push'
"""},
        {"ok":False,"code":"""on: [ push, workflow_dispatch ]
jobs:
  conditional:
    runs-on: ubuntu-latest
    steps:
      - if: github.event_name == 'push'
        run: echo "Conditional"
        when: true
"""},
    ]},

# ---------- Jenkins ----------
9: {"platform":"jenkins",
    "title":"Jenkins — Snippet 9", "desc":"Review and choose the correct version.",
    "buggy": """// Jenkinsfile
pipeline {
  agent any
}
""",
    "options":[
        {"ok":True,"code":"""pipeline {
  agent any
  stages {
    stage('Build') {
      steps { echo 'Build' }
    }
  }
}
""","explanation":"Declarative pipelines require a `stages { ... }` block with at least one stage."},
        {"ok":False,"code":"""pipeline {
  agent any
  steps { echo 'Build' }
}
"""},
        {"ok":False,"code":"""pipeline {
  agent none
}
"""},
    ]},

10: {"platform":"jenkins",
     "title":"Jenkins — Snippet 10", "desc":"Review and choose the correct version.",
     "buggy": """pipeline {
  agent any
  stags {
    stage('Build') { steps { echo 'Building...' } }
  }
}
""",
     "options":[
        {"ok":True,"code":"""pipeline {
  agent any
  stages {
    stage('Build') { steps { echo 'Building...' } }
  }
}
""","explanation":"Key must be `stages` (not `stags`)."},
        {"ok":False,"code":"""pipeline {
  agent any
  stage {
    steps { echo 'Building...' }
  }
}
"""},
        {"ok":False,"code":"""pipeline {
  agent any
  stages:
    stage('Build') { steps { echo 'Building...' } }
}
"""},
     ]},

11: {"platform":"jenkins",
     "title":"Jenkins — Snippet 11", "desc":"Review and choose the correct version.",
     "buggy": """pipeline {
  agent any
  stages {
    stage('Deploy') {
      steps { echo "$VAR()" }
    }
  }
}
""",
     "options":[
        {"ok":True,"code":"""pipeline {
  agent any
  stages {
    stage('Deploy') {
      steps { echo "${VAR}" }
    }
  }
}
""","explanation":"Use Groovy interpolation `${VAR}` (or `env.VAR`)."},
        {"ok":False,"code":"""pipeline {
  agent any
  stages {
    stage('Deploy') {
      steps { echo "$VAR" }
    }
  }
}
"""},
        {"ok":False,"code":"""pipeline {
  agent any
  environment { VAR = 'value' }
  stages {
    stage('Deploy') {
      steps { echo "$(VAR)" }
    }
  }
}
"""},
     ]},

12: {"platform":"jenkins",
     "title":"Jenkins — Snippet 12", "desc":"Review and choose the correct version.",
     "buggy": """pipeline {
  agent any
  stages {
    stage('Build') { steps { echo 'First' } }
    stage('Build') { steps { echo 'Second' } }
  }
}
""",
     "options":[
        {"ok":True,"code":"""pipeline {
  agent any
  stages {
    stage('Build')  { steps { echo 'First' } }
    stage('Test')   { steps { echo 'Second' } }
  }
}
""","explanation":"Stage names should be unique to avoid confusing the UI/graph."},
        {"ok":False,"code":"""pipeline {
  agent any
  stages {
    stage('Build') { steps { echo 'First' } }
    stage('Build') { steps { echo 'Second' } }
  }
}
"""},
        {"ok":False,"code":"""pipeline {
  agent any
  stage('Build') { steps { echo 'First' } }
  stage('Test')  { steps { echo 'Second' } }
}
"""},
     ]},
}

# ----------------------------
# Core execution (no code exec; correctness from metadata)
# ----------------------------
def run_single(idx, time_limit=0.0, pause=False):
    spec = EX[idx]
    _print_header(f"{spec['title']} - {spec['desc']}")
    print(spec["buggy"])
    _print_header(f"{spec['title']} - Options")
    opts = spec["options"][:]; random.shuffle(opts)
    labels = list("ABC")[:len(opts)]
    mapping = dict(zip(labels, opts))
    for lab, opt in mapping.items():
        print(f"{lab})\n{opt['code']}")
    ans, to = timed_input(f"Enter choice ({'/'.join(labels)}): ", time_limit)
    chosen = "TIMEOUT" if to else (ans.strip().upper() if ans.strip().upper() in mapping else "INVALID")
    ok = (mapping.get(chosen, {"ok":False})["ok"] if chosen in mapping else False)
    correct_label = next((lab for lab,opt in mapping.items() if opt["ok"]), "")
    chosen_code = mapping.get(chosen, {}).get("code","")
    correct_code = "" if ok else mapping.get(correct_label,{}).get("code","")
    explanation = "" if ok else next((opt.get("explanation","") for opt in mapping.values() if opt.get("ok")), "")
    if pause:
        input("Press Enter to continue...")
        os.system('cls' if os.name=='nt' else 'clear')
    return {
        "chosen_label": chosen,
        "ok": ok,
        "correct_label": correct_label,
        "buggy_code": spec["buggy"],
        "chosen_code": chosen_code,
        "correct_code_if_wrong": correct_code,
        "explanation": explanation,
        "platform": spec["platform"],
        "title": spec["title"],
        "desc": spec["desc"]
    }

def run_session(order, time_limit, pause, out_dir, results_file, details_file,
                display_results, name, pdf, pdf_file):
    os.makedirs(out_dir, exist_ok=True)
    ts = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    ts_fn = datetime.now().strftime("%Y%m%d_%H%M%S")
    safe = sanitize_filename(name)

    sum_csv = os.path.join(out_dir, results_file) if results_file else os.path.join(out_dir, f"cicd_results_{safe}_{ts_fn}.csv")
    det_csv = os.path.join(out_dir, details_file) if details_file else os.path.join(out_dir, f"cicd_results_details_{safe}_{ts_fn}.csv")

    total=0; rows=[]; details=[]
    try:
        for i in order:
            r = run_single(i, time_limit, pause)
            rows.append((i, EX[i]["desc"], r["chosen_label"], r["ok"]))
            if r["ok"]: total+=1
            details.append({
                "exercise": i,
                "platform": r["platform"],
                "title": r["title"],
                "description": r["desc"],
                "chosen_label": r["chosen_label"],
                "chosen_ok": str(r["ok"]),
                "correct_label_if_wrong": (r["correct_label"] if not r["ok"] else ""),
                "buggy_code": r["buggy_code"],
                "chosen_code": r["chosen_code"],
                "correct_code_if_wrong": r["correct_code_if_wrong"],
                "explanation": r["explanation"],
            })
    except KeyboardInterrupt:
        print("\n[Session cancelled by interviewer]")

    with open(sum_csv,"w",newline="",encoding="utf-8") as f:
        w=csv.writer(f)
        w.writerow(["candidate", safe]); w.writerow(["timestamp", ts]); w.writerow([])
        w.writerow(["exercise","description","choice","correct"])
        for i,desc,choice,ok in rows: w.writerow([i,desc,choice,str(ok)])
        w.writerow([]); w.writerow(["TOTAL_CORRECT", total]); w.writerow(["TOTAL_QUESTIONS", len(rows)])
        pct = (total/len(rows)*100.0) if rows else 0.0
        w.writerow(["PERCENT", f"{pct:.0f}%"])

    with open(det_csv,"w",newline="",encoding="utf-8") as f:
        cols=["exercise","platform","title","description","chosen_label","chosen_ok","correct_label_if_wrong","buggy_code","chosen_code","correct_code_if_wrong","explanation"]
        w=csv.DictWriter(f, fieldnames=cols); w.writeheader()
        for d in details: w.writerow(d)

    pdf_path=None
    if pdf:
        pdf_path = os.path.join(out_dir, pdf_file) if pdf_file else os.path.join(out_dir, f"cicd_summary_{safe}_{ts_fn}.pdf")
        lines=[f"Ex {i:>2}: {'PASS' if ok else 'FAIL'}" for (i,_,_,ok) in rows]
        pct = (total/len(rows)*100.0) if rows else 0.0
        footer=["-"*30, f"Score: {total} / {len(rows)} ({pct:.0f}%)"]
        write_summary_pdf(pdf_path, "CI/CD Debugging Interview - Summary", name, ts, lines, footer)

    if display_results:
        _print_header("Session Summary")
        print(f"Candidate: {name}")
        print(f"Saved CSV: {sum_csv}")
        print(f"Saved details: {det_csv}")
        if pdf and pdf_path: print(f"Saved PDF: {pdf_path}")
        pct = (total/len(rows)*100.0) if rows else 0.0
        print(f"Score: {total} / {len(rows)} ({pct:.0f}%)")
    else:
        print(f"Saved CSV: {sum_csv}")
        print(f"Saved details: {det_csv}")
        if pdf and pdf_path: print(f"Saved PDF: {pdf_path}")

# ----------------------------
# CLI
# ----------------------------
def main():
    p=argparse.ArgumentParser(description="CI/CD Debugging Interview - Candidate-Safe Runner (v2)")
    g=p.add_mutually_exclusive_group()
    g.add_argument("--all", action="store_true", help="run all exercises")
    g.add_argument("--pick", nargs="+", type=int, help="specific exercises, e.g. --pick 2 5 9")
    g.add_argument("--tool", nargs="+", choices=["gitlab","github","jenkins"], help="filter by platform(s)")
    p.add_argument("--shuffle", action="store_true", help="shuffle exercise order")
    p.add_argument("--limit", type=int, default=0, help="limit number after selection/shuffle")
    p.add_argument("--time-limit", type=float, default=0.0, help="seconds allowed to enter a choice (0=off)")
    p.add_argument("--pause", action="store_true", help="pause after each exercise and clear the screen")
    p.add_argument("--output-dir", type=str, default=".", help="directory to save results")
    p.add_argument("--results-file", type=str, default=None, help="explicit summary CSV filename")
    p.add_argument("--details-file", type:str, default=None, help="explicit details CSV filename")
    p.add_argument("--no-display-results", action="store_true", help="do not print final results at the end")
    p.add_argument("--name", type=str, default=None, help="candidate name (if omitted, you will be prompted)")
    p.add_argument("--pdf", action="store_true", help="also write a one-page PDF summary")
    p.add_argument("--pdf-file", type=str, default=None, help="explicit PDF filename for the summary")
    args=p.parse_args()

    name = args.name if args.name else (input("Candidate name: ").strip() or "candidate")

    # Determine exercise order
    if args.all:
        order = list(EX.keys())
    elif args.pick:
        order=[i for i in args.pick if i in EX]
        if not order:
            print("No valid exercises in --pick."); return
    elif args.tool:
        wanted = set(args.tool)
        order = [i for i,s in EX.items() if s.get("platform") in wanted]
        if not order:
            print("No exercises found for selected --tool filters."); return
    else:
        print("Available exercises:", ", ".join(str(k) for k in sorted(EX.keys())))
        while True:
            s=input("Enter exercise number: ").strip()
            if s.isdigit() and int(s) in EX: order=[int(s)]; break
            print("Please enter a valid number.")

    if args.shuffle:
        random.shuffle(order)
    if args.limit and args.limit < len(order):
        order = order[:args.limit]

    os.system('cls' if os.name=='nt' else 'clear')

    try:
        run_session(order, args.time_limit, args.pause, args.output_dir,
                    args.results_file, args.details_file,
                    not args.no_display_results, name, args.pdf, args.pdf_file)
    except KeyboardInterrupt:
        print("\n[Session cancelled] Results (so far) have been written.")

if __name__=="__main__":
    main()
