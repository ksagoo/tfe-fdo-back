import requests
from typing import Optional, Iterable, Tuple, List, Dict

def reassign_dos_protection_rate_policies(
    session: requests.Session,
    base_url: str,
    config_id: int,
    version: int,
    access_group: str,
    policy_ids: Optional[Iterable[str]] = None,   # optional: only update these policy IDs
    list_name_fragment: Optional[str] = None,      # optional override of the list name search
    debug: bool = True,
) -> Dict:
    """
    Resolve the SC-<access_group> 'Rate Controls Bypass List', then attach that list
    to all DoS/Rate policies in the given config/version (or only those in policy_ids).

    - Tries Client Lists API (/client-list/v1/lists) first.
    - Falls back to Network Lists API (/network-list/v2/network-lists).
    - Writes the list id into:
        * additionalMatchOptions[type=NetworkListCondition].values (newer schema), or
        * matchCriteria.bypassNetworkLists (older schema)
    - Scrubs read-only fields that cause 4xx on PUT.

    Returns a summary dict with counts and per-policy details.
    """

    def _dbg(msg: str):
        if debug:
            print(msg)

    # ---------------------------
    # 1) Resolve the list ID
    # ---------------------------
    target_fragment = list_name_fragment or f"SC-{access_group} Rate Controls Bypass List"
    list_id, list_name = _find_list_id(session, base_url, target_fragment, _dbg)
    if not list_id:
        print(f"[ERROR] No valid list found matching: '{target_fragment}'. Cannot continue.")
        return {"successful": 0, "failed": 1, "skipped": 0,
                "details": [{"stage": "resolve_list", "error": f"not found: {target_fragment}"}]}

    _dbg(f"[INFO] Using list '{list_name}' ({list_id}) for DoS reassignment.")

    # ---------------------------
    # 2) Fetch rate policies
    # ---------------------------
    list_url = f"{base_url}/appsec/v1/configs/{config_id}/versions/{version}/rate-policies"
    try:
        _dbg(f"[DBG] GET rate policies: {list_url}")
        r = session.get(list_url)
        r.raise_for_status()
        rp_list = r.json().get("ratePolicies", [])
    except Exception as e:
        return {"successful": 0, "failed": 1, "skipped": 0,
                "details": [{"stage": "fetch_rate_policies", "error": str(e)}]}

    if not rp_list:
        _dbg("[INFO] No rate policies attached to this config/version; nothing to do.")
        return {"successful": 0, "failed": 0, "skipped": 0, "details": []}

    # optional filter by IDs
    allowed_ids = set(str(pid) for pid in policy_ids) if policy_ids else None
    if allowed_ids:
        rp_list = [p for p in rp_list if str(p.get("id")) in allowed_ids]
        _dbg(f"[DBG] Filtering to {len(rp_list)} policies by provided IDs.")

    # ---------------------------
    # 3) Update each policy
    # ---------------------------
    summary = {"successful": 0, "failed": 0, "skipped": 0, "details": []}
    for p in rp_list:
        pid = p.get("id")
        pname = p.get("name")
        if not pid:
            summary["skipped"] += 1
            summary["details"].append({"policy": p, "status": "skipped", "reason": "missing id"})
            continue

        rp_url = f"{base_url}/appsec/v1/configs/{config_id}/versions/{version}/rate-policies/{pid}"
        try:
            _dbg(f"[DBG] GET policy: {pname} ({pid}) -> {rp_url}")
            g = session.get(rp_url)
            g.raise_for_status()
            doc = g.json()

            changed = False

            # Try newer schema first: additionalMatchOptions / NetworkListCondition
            amo = doc.get("additionalMatchOptions")
            if isinstance(amo, list):
                for opt in amo:
                    if isinstance(opt, dict) and opt.get("type") == "NetworkListCondition":
                        vals = opt.get("values", [])
                        # replace with only this id if different
                        if not isinstance(vals, list) or vals != [list_id]:
                            opt["values"] = [list_id]
                            changed = True
                            _dbg(f"[DBG]   set NetworkListCondition.values -> [{list_id}]")
                # if we found amo, we prefer it and won't fall back unless unchanged

            # Older schema: matchCriteria.bypassNetworkLists
            if not changed:
                mc = doc.get("matchCriteria")
                if isinstance(mc, dict):
                    cur = mc.get("bypassNetworkLists", [])
                    if not isinstance(cur, list) or cur != [list_id]:
                        mc["bypassNetworkLists"] = [list_id]
                        changed = True
                        _dbg(f"[DBG]   set matchCriteria.bypassNetworkLists -> [{list_id}]")

            # scrub typical read-only fields before PUT
            for ro in ("id", "updateDate", "createDate", "used"):
                if ro in doc:
                    doc.pop(ro, None)

            if changed:
                _dbg(f"[DBG] PUT policy: {pname} ({pid})")
                u = session.put(rp_url, json=doc)
                u.raise_for_status()
                summary["successful"] += 1
                summary["details"].append({"policyId": pid, "name": pname, "status": "updated"})
            else:
                summary["skipped"] += 1
                summary["details"].append({"policyId": pid, "name": pname, "status": "unchanged"})

        except Exception as e:
            summary["failed"] += 1
            summary["details"].append({"policyId": pid, "name": pname, "status": "failed", "error": str(e)})

    _dbg(f"[INFO] DoS reassignment done. Success: {summary['successful']}  "
         f"Skipped: {summary['skipped']}  Failed: {summary['failed']}")
    return summary


# ---------- helpers ----------

def _find_list_id(
    session: requests.Session,
    base_url: str,
    name_fragment: str,
    debug_print,
) -> Tuple[Optional[str], Optional[str]]:
    """
    Try Client Lists API first (/client-list/v1/lists), then Network Lists API
    (/network-list/v2/network-lists). Returns (id, name) or (None, None).
    """
    # Client Lists API (newer)
    try:
        url = f"{base_url}/client-list/v1/lists"
        debug_print(f"[DBG] GET client lists: {url}")
        r = session.get(url)
        r.raise_for_status()
        data = r.json()
        items: List[Dict] = data if isinstance(data, list) else []
        for it in items:
            name = (it.get("name") or "").strip()
            lid = it.get("listId") or it.get("id")
            if name and name_fragment in name:
                return lid, name
    except Exception as e:
        debug_print(f"[WARN] Client Lists lookup failed: {e}")

    # Network Lists API (legacy)
    try:
        url = f"{base_url}/network-list/v2/network-lists"
        debug_print(f"[DBG] GET network lists: {url}")
        r = session.get(url, params={"page": 0, "pageSize": 1000})
        r.raise_for_status()
        payload = r.json()
        lists: List[Dict] = payload.get("networkLists", []) if isinstance(payload, dict) else (payload if isinstance(payload, list) else [])
        for it in lists:
            name = (it.get("name") or "").strip()
            lid = it.get("uniqueId") or it.get("id")
            if name and name_fragment in name:
                return lid, name
    except Exception as e:
        debug_print(f"[WARN] Network Lists lookup failed: {e}")

    return None, None
