test
parser.add_argument(
    "--version-notes",
    dest="version_notes",
    required=False,
    help="Optional Jira issue reference for version notes. Example: --version-notes ABC-123"
)

def set_config_version_notes(session, base_url, config_id, version, jira_issue=None, is_prod=False):
    """
    Writes version notes at the CONFIG VERSION level (not policy).
    If jira_issue is provided, uses: 'Jira Ticket Ref for <Env>: <jira_issue>'
    Otherwise uses default: 'Automatically created for <Env> onboarding'
    """
    env_label = "Prod" if is_prod else "NonProd"
    note = (
        f"Jira Ticket Ref for {env_label}: {jira_issue}"
        if jira_issue else
        f"Automatically created for {env_label} onboarding"
    )

    url = urljoin(base_url, f"/appsec/v1/configs/{config_id}/versions/{version}/version-notes")
    payload = {"notes": note}

    try:
        resp = session.put(url, json=payload)
        resp.raise_for_status()
        print(f"[SUCCESS] Version notes set for v{version} ({env_label}): {note}")
        return True
    except Exception as e:
        print(f"[WARN] Failed to set version notes for v{version} ({env_label}): {e}")
        return False

3) Call it from main()
A) When you create NonProd (new config path)

Right after you’ve created the NonProd policy (i.e., after policy_id = create_default_policy(...)), add:

# Set version notes for NonProd (v1)
set_config_version_notes(
    session=session,
    base_url=base_url,
    config_id=config_id,
    version=1,
    jira_issue=args.version_notes,
    is_prod=False
)


B) When you onboard Prod on an existing config

Inside your if existing_config_id and args.isProd: branch, after the PROD policy is created by onboard_prod_policy(...), add:

# Belt & braces: ensure version notes for Prod (v1) on existing config
set_config_version_notes(
    session=session,
    base_url=base_url,
    config_id=existing_config_id,
    version=1,
    jira_issue=args.version_notes,
    is_prod=True
)

That’s it. This will:

Use the Jira issue if Jenkins passes --version-notes ${params.JIRA_ISSUE}

Fall back to the default “Automatically created for … onboarding” if not provided

Write notes at the config version level for both NonProd and (later) Prod creations.


def ensure_config_hostnames(session, base_url, config_id, fqdn_list):
    """
    Ensure the security config's 'hostnames' includes all entries in fqdn_list.
    Tries the config-level hostnames endpoint first, then falls back to the
    versioned endpoint (some accounts expose one or the other).
    """
    wanted = set([h.strip().lower() for h in fqdn_list if h and h.strip()])

    def _get(url):
        resp = session.get(url)
        if resp.status_code == 404:
            return None, 404
        resp.raise_for_status()
        data = resp.json() if resp.text else {}
        current = set([h.strip().lower() for h in data.get("hostnames", [])])
        return current, resp.status_code

    def _put(url, all_hosts):
        payload = {"hostnames": sorted(all_hosts)}
        r = session.put(url, json=payload)
        r.raise_for_status()
        return True

    # Preferred (config-level) endpoint
    cfg_url = f"{base_url}/appsec/v1/configs/{config_id}/hostnames"
    # Fallback (some tenants expose hostnames per version)
    ver_url = f"{base_url}/appsec/v1/configs/{config_id}/versions/1/hostnames"

    # Try config-level GET
    current, code = _get(cfg_url)
    if code != 404:
        all_hosts = (current or set()) | wanted
        if all_hosts != (current or set()):
            _put(cfg_url, all_hosts)
        return {"where": "config", "before": sorted(current or []), "after": sorted(all_hosts)}

    # Fallback: version-level GET/PUT
    current, _ = _get(ver_url)
    all_hosts = (current or set()) | wanted
    if all_hosts != (current or set()):
        _put(ver_url, all_hosts)
    return {"where": "version", "before": sorted(current or []), "after": sorted(all_hosts)}

2) Call it from main()
A) When you’re doing Prod onboarding on an existing config

Immediately after onboard_prod_policy(...) returns (that’s the spot you just added the version-notes “belt & braces”), add:

# Also make sure the config’s 'Hostnames currently associated with this configuration'
# includes the PROD FQDNs we just onboarded.
ensure_config_hostnames(session, base_url, existing_config_id, args.fqdn)
return None



(Place it right before your return None in that Prod branch—i.e., just after the call to onboard_prod_policy(...) and after set_config_version_notes(..., is_prod=True).)

B) When you’re creating Non-Prod from scratch

After you create the config/policy (your current flow: create_security_config(...), then create_default_policy(...), then reassignments), add:

You can put this right after the create_default_policy(...) call (it’s harmless if the hostnames already match because the function will no-op).

# Belt & braces: make sure the config carries these Non-Prod FQDNs
ensure_config_hostnames(session, base_url, config_id, fqdn_list)

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

def ensure_config_hostnames(session, base_url, config_id, fqdn_list):
    """
    Ensure the security config's 'hostnames' includes all entries in fqdn_list.
    Handles both /configs/{id}/hostnames (preferred) and /configs/{id}/versions/1/hostnames (fallback).
    """
    wanted = set([h.strip().lower() for h in fqdn_list if h and h.strip()])

    def _get(url):
        resp = session.get(url)
        if resp.status_code == 404:
            return None, 404
        resp.raise_for_status()
        data = resp.json() if resp.text else {}
        current = set([h.strip().lower() for h in data.get("hostnames", [])])
        return current, resp.status_code

    def _put(url, all_hosts):
        payload = {"hostnames": sorted(all_hosts)}
        print(f"[INFO] Updating hostnames via {url} -> {payload}")
        r = session.put(url, json=payload)
        if r.status_code == 404:
            print("[WARN] 404 on PUT, endpoint may not be supported.")
            return False
        r.raise_for_status()
        return True

    # Try config-level first (preferred)
    cfg_url = f"{base_url}/appsec/v1/configs/{config_id}/hostnames"
    current, code = _get(cfg_url)
    if code != 404:
        all_hosts = (current or set()) | wanted
        if all_hosts != (current or set()):
            _put(cfg_url, all_hosts)
        print(f"[INFO] Hostnames updated on config {config_id}: {sorted(all_hosts)}")
        return

    # Fallback: version-level
    ver_url = f"{base_url}/appsec/v1/configs/{config_id}/versions/1/hostnames"
    current, _ = _get(ver_url)
    all_hosts = (current or set()) | wanted
    if all_hosts != (current or set()):
        _put(ver_url, all_hosts)
    print(f"[INFO] Hostnames updated on version 1 of config {config_id}: {sorted(all_hosts)}")





