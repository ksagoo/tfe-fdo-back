def ensure_config_hostnames(session, base_url, config_id, version, fqdn_list,
                            strict=False, max_wait_seconds=180, poll_interval=10):
    """
    Ensures all specified FQDNs (for NonProd or Prod) are associated with the given config version.
    Uses 'hostnameList' + 'mode: append' payload format per Akamai TechDocs.

    - Polls selectable-hostnames until all are available (to avoid race after activation)
    - PUTs with mode=append (non-destructive)
    - Prints before/added/skipped/final summary
    """
    import time, requests

    sel_url        = f"{base_url}/appsec/v1/configs/{config_id}/versions/{version}/selected-hostnames"
    selectable_url = f"{base_url}/appsec/v1/configs/{config_id}/versions/{version}/selectable-hostnames"

    def _norm(hosts):
        return {h.strip().lower() for h in (hosts or []) if h and h.strip()}

    desired = _norm(fqdn_list)
    if not desired:
        print("[INFO] No FQDNs requested for association; skipping hostname update.")
        return {"before": [], "added": [], "skipped": [], "final": []}

    # --- Poll selectable-hostnames until all desired appear
    print(f"[DEBUG] Polling selectable-hostnames until all desired FQDNs become selectable...")
    deadline = time.time() + max_wait_seconds
    selectable = set()
    while True:
        try:
            resp = session.get(selectable_url, headers={"accept": "application/json"})
            resp.raise_for_status()
            selectable = _norm(resp.json().get("hostnames", []))
        except Exception as e:
            print(f"[WARN] Unable to fetch selectable hostnames: {e}")
            selectable = set()

        missing = sorted(desired - selectable)
        if not missing:
            break

        if time.time() >= deadline:
            print(f"[WARN] Timeout waiting for selectable hostnames. Skipping: {missing}")
            break

        time.sleep(poll_interval)

    # --- Fetch already-selected hostnames
    selected_before = set()
    try:
        resp = session.get(sel_url, headers={"accept": "application/json"})
        if resp.status_code == 404:
            selected_before = set()
        else:
            resp.raise_for_status()
            data = resp.json()
            if "hostnameList" in data:
                selected_before = _norm([item.get("hostname") for item in data["hostnameList"]])
            else:
                selected_before = _norm(data.get("hostnames", []))
    except Exception as e:
        print(f"[WARN] Could not fetch existing selected hostnames (assuming none): {e}")

    desired_usable = desired & selectable
    not_allowed = sorted(desired - selectable)
    final_set = sorted(selected_before | desired_usable)

    if not_allowed:
        msg = f"[WARN] These FQDNs are not selectable and will be skipped: {not_allowed}"
        if strict:
            raise ValueError(msg)
        else:
            print(msg)

    # --- PUT with preferred payload per Akamai TechDocs
    payload = {
        "hostnameList": [{"hostname": h} for h in final_set],
        "mode": "append"
    }
    headers = {
        "accept": "application/json",
        "content-type": "application/json"
    }

    print(f"[DEBUG] PUT {sel_url}")
    print(f"[DEBUG] Payload: {payload}")

    try:
        put_resp = session.put(sel_url, json=payload, headers=headers)
        put_resp.raise_for_status()
    except requests.exceptions.HTTPError as e:
        print(f"[ERROR] PUT selected-hostnames failed ({e.response.status_code}): {e.response.text}")
        return {"before": sorted(selected_before), "added": [], "skipped": not_allowed, "final": sorted(selected_before)}

    print("\n[INFO] Final selected hostnames now set on the config:")
    for h in final_set:
        print(f"  - {h}")

    return {
        "before": sorted(selected_before),
        "added": sorted(list(desired_usable - selected_before)),
        "skipped": not_allowed,
        "final": final_set
    }

ensure_config_hostnames(
    session=session,
    base_url=base_url,
    config_id=existing_config_id,
    version=1,
    fqdn_list=args.fqdn,  # list of FQDNs passed on CLI
    strict=False
)
