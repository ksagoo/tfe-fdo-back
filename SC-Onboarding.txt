import requests
import json
from typing import Dict, List, Union, Any, Optional

def reassign_dos_protection_rate_policies(
    session: requests.Session,
    base_url: str,
    config_id: Union[str, int],
    version: Union[str, int],
    access_group: str,
    list_name_fragment: Optional[str] = None,
) -> Dict[str, Union[int, List[Dict[str, str]]]]:
    summary = {"successful": 0, "failed": 0, "details": []}
    fragment = (list_name_fragment or f"SC-{access_group} Rate Controls Bypass List").strip()

    def _collect_list_candidates(obj: Any) -> List[Dict[str, Any]]:
        candidates = []
        def walk(node):
            if isinstance(node, dict):
                if "name" in node and any(k in node for k in ("listId", "id", "uniqueId")):
                    candidates.append(node)
                for v in node.values():
                    walk(v)
            elif isinstance(node, list):
                for item in node:
                    walk(item)
        walk(obj)
        return candidates

    # Step 1: Resolve client list
    client_list_id = None
    try:
        resp = session.get(f"{base_url}/client-list/v1/lists", params={"includeInactive": "true"})
        resp.raise_for_status()
        candidates = _collect_list_candidates(resp.json())
        for it in candidates:
            name = (it.get("name") or "").strip()
            if name and fragment.lower() in name.lower():
                client_list_id = str(it.get("listId") or it.get("id") or it.get("uniqueId"))
                break
    except Exception as e:
        print(f"[ERROR] Failed to fetch client lists: {e}")
        return summary

    if not client_list_id:
        print(f"[ERROR] No matching Client List found for fragment '{fragment}'")
        return summary

    print(f"[INFO] Using Client List ID: {client_list_id}")

    # Step 2: Fetch rate policies
    rate_url = f"{base_url}/appsec/v1/configs/{config_id}/versions/{version}/rate-policies"
    try:
        r = session.get(rate_url)
        r.raise_for_status()
        policies = r.json().get("ratePolicies", [])
    except Exception as e:
        print(f"[ERROR] Failed to fetch rate policies: {e}")
        return summary

    def get_policy_id(p: dict) -> str:
        return str(p.get("id") or p.get("policyId") or p.get("uuid") or p.get("uniqueId") or "")

    # Step 3: Update each policy
    for policy in policies:
        policy_id = get_policy_id(policy)
        policy_name = policy.get("name") or "Unnamed Policy"
        rp_url = f"{base_url}/appsec/v1/configs/{config_id}/versions/{version}/rate-policies/{policy_id}"
        print(f"[INFO] Updating policy '{policy_name}' (id={policy_id})")

        try:
            rp_resp = session.get(rp_url)
            rp_resp.raise_for_status()
            full_doc = rp_resp.json()

            # Build GUI-visible match conditions
            new_conditions = [
                {
                    "type": "NetworkListCondition",
                    "positiveMatch": False,
                    "values": [client_list_id]
                },
                {
                    "type": "RequestMethodCondition",
                    "positiveMatch": True,
                    "values": ["POST"]
                }
            ]

            existing_conditions = full_doc.get("additionalMatchConditions", [])
            filtered_conditions = [
                c for c in existing_conditions
                if c.get("type") not in ("NetworkListCondition", "RequestMethodCondition")
            ]
            filtered_conditions.extend(new_conditions)

            payload = {
                "name": full_doc.get("name"),
                "description": full_doc.get("description"),
                "threshold": full_doc.get("threshold"),
                "burstThreshold": full_doc.get("burstThreshold"),
                "durationSeconds": full_doc.get("durationSeconds"),
                "clientIdentifier": full_doc.get("clientIdentifier"),
                "action": {
                    "type": full_doc.get("action", {}).get("type", "alert")
                },
                "additionalMatchConditions": filtered_conditions
            }

            print(f"[DBG] PUT URL: {rp_url}")
            print("[DBG] Payload:")
            print(json.dumps(payload, indent=2))

            put_resp = session.put(rp_url, json=payload)
            put_resp.raise_for_status()
            summary["successful"] += 1
            summary["details"].append({"policy": policy_name, "status": "updated"})
            print(f"[INFO] Updated '{policy_name}'")

            # Step 4: Verify update
            verify_resp = session.get(rp_url)
            verify_resp.raise_for_status()
            verify_doc = verify_resp.json()
            match_conditions = verify_doc.get("additionalMatchConditions", [])

            found_network = any(
                c.get("type") == "NetworkListCondition" and client_list_id in c.get("values", []) and c.get("positiveMatch") is False
                for c in match_conditions
            )
            found_post = any(
                c.get("type") == "RequestMethodCondition" and "POST" in c.get("values", []) and c.get("positiveMatch") is True
                for c in match_conditions
            )

            if found_network and found_post:
                print(f"[VERIFY] ✅ Both conditions correctly attached to '{policy_name}'")
            else:
                print(f"[VERIFY] ❌ Missing condition(s) in '{policy_name}'")
                summary["details"][-1]["verify"] = "missing"

        except Exception as e:
            print(f"[ERROR] Failed updating '{policy_name}': {e}")
            summary["failed"] += 1
            summary["details"].append({"policy": policy_name, "status": "failed", "error": str(e)})

    print(f"[INFO] Done. Success: {summary['successful']}, Failed: {summary['failed']}")
    return summary

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
def reassign_dos_rate_policies_gui_visible(
    session: requests.Session,
    base_url: str,
    config_id: Union[str, int],
    version: Union[str, int],
    access_group: str,
    list_name_fragment: Optional[str] = None,
) -> Dict[str, Union[int, List[Dict[str, str]]]]:
    summary = {"successful": 0, "failed": 0, "details": []}
    fragment = (list_name_fragment or f"SC-{access_group} Rate Controls Bypass List").strip()

    def _collect_list_candidates(obj: Any) -> List[Dict[str, Any]]:
        candidates = []
        def walk(node):
            if isinstance(node, dict):
                if "name" in node and any(k in node for k in ("listId", "id", "uniqueId")):
                    candidates.append(node)
                for v in node.values():
                    walk(v)
            elif isinstance(node, list):
                for item in node:
                    walk(item)
        walk(obj)
        return candidates

    # Step 1: Resolve client list
    client_list_id = None
    try:
        resp = session.get(f"{base_url}/client-list/v1/lists", params={"includeInactive": "true"})
        resp.raise_for_status()
        candidates = _collect_list_candidates(resp.json())
        for it in candidates:
            name = (it.get("name") or "").strip()
            if name and fragment.lower() in name.lower():
                client_list_id = str(it.get("listId") or it.get("id") or it.get("uniqueId"))
                break
    except Exception as e:
        print(f"[ERROR] Failed to fetch client lists: {e}")
        return summary

    if not client_list_id:
        print(f"[ERROR] No matching Client List found for fragment '{fragment}'")
        return summary

    print(f"[INFO] Using Client List ID: {client_list_id}")

    # Step 2: Fetch rate policies
    rate_url = f"{base_url}/appsec/v1/configs/{config_id}/versions/{version}/rate-policies"
    try:
        r = session.get(rate_url)
        r.raise_for_status()
        policies = r.json().get("ratePolicies", [])
    except Exception as e:
        print(f"[ERROR] Failed to fetch rate policies: {e}")
        return summary

    def get_policy_id(p: dict) -> str:
        return str(p.get("id") or p.get("policyId") or p.get("uuid") or p.get("uniqueId") or "")

    # Step 3: Update each policy
    for policy in policies:
        policy_id = get_policy_id(policy)
        policy_name = policy.get("name") or "Unnamed Policy"
        rp_url = f"{base_url}/appsec/v1/configs/{config_id}/versions/{version}/rate-policies/{policy_id}"
        print(f"[INFO] Updating policy '{policy_name}' (id={policy_id})")

        try:
            rp_resp = session.get(rp_url)
            rp_resp.raise_for_status()
            full_doc = rp_resp.json()

            # Build payload with GUI-visible condition
            new_condition = {
                "type": "NetworkListCondition",
                "positiveMatch": True,
                "values": [client_list_id]
            }

            existing_conditions = full_doc.get("additionalMatchConditions", [])
            # Remove any previous NetworkListCondition to avoid duplicates
            filtered_conditions = [
                c for c in existing_conditions if c.get("type") != "NetworkListCondition"
            ]
            filtered_conditions.append(new_condition)

            payload = {
                "name": full_doc.get("name"),
                "description": full_doc.get("description"),
                "threshold": full_doc.get("threshold"),
                "burstThreshold": full_doc.get("burstThreshold"),
                "durationSeconds": full_doc.get("durationSeconds"),
                "clientIdentifier": full_doc.get("clientIdentifier"),
                "action": {
                    "type": full_doc.get("action", {}).get("type", "alert")
                },
                "additionalMatchConditions": filtered_conditions
            }

            print(f"[DBG] PUT URL: {rp_url}")
            print("[DBG] Payload:")
            print(json.dumps(payload, indent=2))

            put_resp = session.put(rp_url, json=payload)
            put_resp.raise_for_status()
            summary["successful"] += 1
            summary["details"].append({"policy": policy_name, "status": "updated"})
            print(f"[INFO] Updated '{policy_name}'")

            # Step 4: Verify update
            verify_resp = session.get(rp_url)
            verify_resp.raise_for_status()
            verify_doc = verify_resp.json()
            print(f"[VERIFY] Match Conditions for '{policy_name}':")
            print(json.dumps(verify_doc.get("additionalMatchConditions", []), indent=2))

        except Exception as e:
            print(f"[ERROR] Failed updating '{policy_name}': {e}")
            summary["failed"] += 1
            summary["details"].append({"policy": policy_name, "status": "failed", "error": str(e)})

    print(f"[INFO] Done. Success: {summary['successful']}, Failed: {summary['failed']}")
    return summary


#########################################################################
import requests
import json
from typing import Dict, List, Union, Any, Optional

def reassign_dos_protection_rate_policies(
    session: requests.Session,
    base_url: str,
    config_id: Union[str, int],
    version: Union[str, int],
    access_group: str,
    list_name_fragment: Optional[str] = None,
) -> Dict[str, Union[int, List[Dict[str, str]]]]:
    summary: Dict[str, Union[int, List[Dict[str, str]]]] = {"successful": 0, "failed": 0, "details": []}
    fragment = (list_name_fragment or f"SC-{access_group} Rate Controls Bypass List").strip()
    print(f"[DBG] Matching fragment: '{fragment}' (case-insensitive)")

    def _pretty_dump(label: str, data: Any):
        print(f"[DBG] {label} (formatted):")
        try:
            print(json.dumps(data, indent=2))
        except Exception:
            print(f"[DBG] {label} could not be pretty-printed.")

    def _collect_list_candidates(obj: Any) -> List[Dict[str, Any]]:
        candidates: List[Dict[str, Any]] = []

        def has_id(d: Dict[str, Any]) -> bool:
            return any(k in d and d[k] for k in ("listId", "id", "uniqueId"))

        def is_candidate(d: Dict[str, Any]) -> bool:
            name = d.get("name")
            return isinstance(name, str) and has_id(d)

        def walk(node: Any):
            if isinstance(node, dict):
                if is_candidate(node):
                    candidates.append(node)
                for v in node.values():
                    walk(v)
            elif isinstance(node, list):
                for item in node:
                    walk(item)

        walk(obj)
        return candidates

    # STEP 1: Resolve client list
    client_list_id = None
    client_list_name = None

    try:
        resp = session.get(f"{base_url}/client-list/v1/lists", params={"includeInactive": "true"})
        resp.raise_for_status()
        data = resp.json()
        _pretty_dump("Client Lists", data)

        candidates = _collect_list_candidates(data)
        for it in candidates:
            name = (it.get("name") or "").strip()
            if name and fragment.lower() in name.lower():
                client_list_id = str(it.get("listId") or it.get("id") or it.get("uniqueId"))
                client_list_name = name
                break

    except Exception as e:
        print(f"[WARN] Failed to fetch client lists: {e}")

    if not client_list_id:
        print(f"[ERROR] No matching Client List found for fragment '{fragment}'")
        return summary

    print(f"[INFO] Using list '{client_list_name}' (ID: {client_list_id})")

    # STEP 2: Fetch rate policies
    rate_url = f"{base_url}/appsec/v1/configs/{config_id}/versions/{version}/rate-policies"
    try:
        r = session.get(rate_url)
        r.raise_for_status()
        raw_policies = r.json()
        _pretty_dump("Rate Policies", raw_policies)
        policies = raw_policies.get("ratePolicies", [])
    except Exception as e:
        print(f"[ERROR] Failed to fetch rate policies: {e}")
        return summary

    if not policies:
        print("[INFO] No rate policies found.")
        return summary

    def get_policy_id(p: dict) -> str:
        return str(p.get("id") or p.get("policyId") or p.get("uuid") or p.get("uniqueId") or "")

    # STEP 3: Update each policy
    for policy in policies:
        policy_id = get_policy_id(policy)
        policy_name = policy.get("name") or "Unnamed Policy"
        rp_url = f"{base_url}/appsec/v1/configs/{config_id}/versions/{version}/rate-policies/{policy_id}"
        print(f"[INFO] Processing policy '{policy_name}' (id={policy_id})")

        try:
            rp_resp = session.get(rp_url)
            rp_resp.raise_for_status()
            full_doc = rp_resp.json()

            # Build minimal schema-aligned payload
            payload = {
                "name": full_doc.get("name"),
                "description": full_doc.get("description"),
                "averageThreshold": full_doc.get("averageThreshold"),
                "burstThreshold": full_doc.get("burstThreshold"),
                "burstWindow": full_doc.get("burstWindow", 5),
                "clientIdentifier": full_doc.get("clientIdentifier"),
                "matchType": full_doc.get("matchType"),
                "pathMatchType": full_doc.get("pathMatchType"),
                "requestType": full_doc.get("requestType"),
                "sameActionOnIpv6": full_doc.get("sameActionOnIpv6", True),
                "type": full_doc.get("type"),
                "action": {
                    "type": full_doc.get("action", {}).get("type", "alert")
                },
                "matchCriteria": {
                    "bypassNetworkLists": [client_list_id]
                }
            }

            print(f"[DBG] PUT URL: {rp_url}")
            print("[DBG] Payload being sent:")
            print(json.dumps(payload, indent=2))

            put_resp = session.put(rp_url, json=payload)
            put_resp.raise_for_status()
            summary["successful"] += 1
            summary["details"].append({"policy": policy_name, "status": "updated"})
            print(f"[INFO] Updated rate policy '{policy_name}'")

        except Exception as e:
            print(f"[ERROR] Failed updating '{policy_name}': {e}")
            summary["failed"] += 1
            summary["details"].append({"policy": policy_name, "status": "failed", "error": str(e)})

    print(f"[INFO] Reassignment complete. Success: {summary['successful']}, Failed: {summary['failed']}")
    return summary
