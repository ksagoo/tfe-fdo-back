def ensure_config_hostnames(session, base_url, config_id, version, fqdn_list, strict=False):
    """
    Ensure that all specified FQDNs (for Non-Prod and Prod) are associated
    with the given security configuration version.

    Behavior:
      - Fetches currently selected hostnames.
      - Fetches selectable hostnames (what Akamai allows).
      - Merges new FQDNs with existing ones.
      - Sends PUT /selected-hostnames with full combined list.
    """
    import requests

    sel_url = f"{base_url}/appsec/v1/configs/{config_id}/versions/{version}/selected-hostnames"
    selectable_url = f"{base_url}/appsec/v1/configs/{config_id}/versions/{version}/selectable-hostnames"

    def _norm(hosts):
        return {h.strip().lower() for h in (hosts or []) if h and h.strip()}

    # Fetch selectable hostnames
    try:
        resp = session.get(selectable_url)
        resp.raise_for_status()
        selectable = _norm(resp.json().get("hostnames", []))
    except Exception as e:
        print(f"[ERROR] Unable to fetch selectable hostnames: {e}")
        return {"before": [], "added": [], "skipped": fqdn_list, "final": []}

    # Fetch already selected hostnames
    selected_before = set()
    try:
        resp = session.get(sel_url)
        if resp.status_code == 404:
            selected_before = set()
        else:
            resp.raise_for_status()
            data = resp.json()
            if "hostnameList" in data:
                selected_before = _norm([item.get("hostname") for item in data.get("hostnameList", [])])
            else:
                selected_before = _norm(data.get("hostnames", []))
    except Exception as e:
        print(f"[WARN] Could not fetch existing selected hostnames (assuming none): {e}")

    # Merge current + desired
    desired = _norm(fqdn_list)
    not_selectable = sorted(desired - selectable)
    desired_usable = desired & selectable

    if not_selectable:
        msg = f"[WARN] The following FQDNs are not selectable and will be skipped: {not_selectable}"
        if strict:
            raise ValueError(msg)
        else:
            print(msg)

    final_set = sorted(selected_before | desired_usable)

    # Preferred payload format (per Akamai techdocs)
    preferred_payload = {"hostnameList": [{"hostname": h} for h in final_set]}

    def _put(payload):
        put_resp = session.put(sel_url, json=payload)
        put_resp.raise_for_status()
        return put_resp

    # PUT with fallback to legacy shape
    try:
        _put(preferred_payload)
    except requests.exceptions.HTTPError as e:
        if e.response is not None and e.response.status_code in (400, 415, 422):
            print("[INFO] Retrying with legacy payload shape { 'hostnames': [...] }")
            legacy_payload = {"hostnames": final_set}
            _put(legacy_payload)
        else:
            print(f"[ERROR] PUT selected-hostnames failed: {e}")
            return {"before": sorted(selected_before), "added": [], "skipped": not_selectable, "final": sorted(selected_before)}

    # Print results
    added = sorted(list(desired_usable - selected_before))
    print("\n[INFO] Final selected hostnames now set on the config:")
    for h in final_set:
        print(f"  - {h}")

    return {
        "before": sorted(selected_before),
        "added": added,
        "skipped": not_selectable,
        "final": final_set
    }

print("\n[INFO] Updating selected hostnames for Non-Prod configuration.")
ensure_config_hostnames(
    session=session,
    base_url=base_url,
    config_id=config_id,         # newly created config ID
    version=1,                   # onboarding always starts at version 1
    fqdn_list=nonprod_fqdns      # list of FQDNs for Non-Prod policy
)


print("\n[INFO] Updating selected hostnames for Prod configuration.")
ensure_config_hostnames(
    session=session,
    base_url=base_url,
    config_id=existing_config_id,  # same security config ID as Non-Prod
    version=1,                     # still version 1 (shared config)
    fqdn_list=prod_fqdns           # list of FQDNs for Prod policy
)
