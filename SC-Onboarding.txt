def reassign_dos_protection_rate_policies(
    session,
    base_url,
    config_id,
    version,
    access_group,
    template_policy_name_prefix="Security Policy Template",
    target_policy_id=None,           # only fix policies attached to this security policy (optional)
    activate_clones=True,            # keep best-effort STAGING activation for clones
):
    """
    1) For every DoS rate policy attached to this config/version:
       - If its name starts with the template prefix, clone it to 'SC-<access_group> <suffix>'.
         Otherwise keep the existing policy id.
    2) For each kept/cloned policy, rewrite additionalMatchOptions/NetworkListCondition values
       so that any template client list names/ids are replaced by the corresponding
       'SC-<access_group> …' client list (if found).
    3) PUT the cleaned policy back, then update the config's dos-rates assignment list.
    """

    list_url = f"{base_url}/appsec/v1/configs/{config_id}/versions/{version}/dos-rates"
    clone_url = f"{base_url}/appsec/v1/rate-policies/clone"
    policy_url_template = f"{base_url}/appsec/v1/rate-policies/{{policy_id}}"

    summary = {
        "processed": 0,
        "successful": 0,
        "failed": 0,
        "fixed_conditions": 0,
        "details": [],
    }

    # ---- helper: resolve the cloned client-list id from either a template-like name or any name fragment
    def _resolve_client_list_id_from_name(name: str):
        # if it looks like a template list name, derive the expected SC- name
        expected = name
        if "Security Policy Template" in name:
            suffix = name.split("Security Policy Template", 1)[-1].strip()
            expected = f"SC-{access_group} {suffix}".strip()

        # try to find a client list whose name contains/equals the expected
        try:
            matches = search_client_lists_by_name(session, base_url, expected)  # returns list of (list_id, name)
        except Exception as e:
            print(f"[WARN] Client list lookup failed for '{expected}': {e}")
            return None

        if not matches:
            print(f"[WARN] No client list found for '{expected}'")
            return None

        first = matches[0]
        if isinstance(first, (list, tuple)):
            return first[0]        # (list_id, name)
        if isinstance(first, dict):
            return first.get("id") # safety if ever dict
        return str(first)          # fallback

    try:
        # 1) Read current DoS assignments
        resp = session.get(list_url)
        resp.raise_for_status()
        current_assignments = resp.json().get("ratePolicies", [])
        updated_assignments = []

        for p in current_assignments:
            summary["processed"] += 1
            orig_name = p.get("name", "")
            orig_id = p.get("id")

            kept_id = orig_id
            kept_name = orig_name

            # Clone if the name looks like a template copy
            if orig_name.startswith(template_policy_name_prefix):
                suffix = orig_name.replace(template_policy_name_prefix, "").strip()
                clone_name = f"SC-{access_group} {suffix}".strip()

                # If an item with clone_name is already in assignment list, reuse it
                existing = next((rp for rp in current_assignments if rp.get("name") == clone_name), None)
                if existing:
                    kept_id = existing.get("id")
                    kept_name = clone_name
                else:
                    try:
                        clone_payload = {
                            "cloneFromRatePolicyId": orig_id,
                            "name": clone_name,
                            "description": f"Cloned from {orig_name}",
                            "matchType": p.get("matchType"),
                        }
                        c = session.post(clone_url, json=clone_payload)
                        c.raise_for_status()
                        kept_id = c.json().get("id")
                        kept_name = clone_name

                        # best-effort STAGING activation for the clone
                        if activate_clones and kept_id:
                            act_url = policy_url_template.format(policy_id=kept_id) + "/activate"
                            try:
                                act = session.post(act_url, json={"network": "STAGING"})
                                act.raise_for_status()
                            except Exception as e:
                                print(f"[WARN] STAGING activation failed for rate policy {kept_id}: {e}")

                        summary["successful"] += 1
                        summary["details"].append({"template": orig_name, "clone": kept_name, "status": "success"})
                    except Exception as clone_err:
                        # fallback to original template policy
                        kept_id = orig_id
                        kept_name = orig_name
                        summary["failed"] += 1
                        summary["details"].append(
                            {"template": orig_name, "status": "clone_failed", "error": str(clone_err)}
                        )

            # 2) Fix NetworkListCondition for the kept policy (cloned or original)
            try:
                d = session.get(policy_url_template.format(policy_id=kept_id))
                d.raise_for_status()
                full = d.json()

                # optional: only touch policies attached to a specific security policy
                if target_policy_id and full.get("policyId") != target_policy_id:
                    updated_assignments.append(kept_id)
                    continue

                changed = False
                for opt in full.get("additionalMatchOptions", []):
                    if opt.get("type") != "NetworkListCondition":
                        continue

                    new_vals = []
                    for v in opt.get("values", []):
                        v_str = str(v)

                        # already an ID?
                        if v_str.isdigit():
                            new_vals.append(v)
                            continue

                        # name → resolve to SC- list id
                        resolved_id = _resolve_client_list_id_from_name(v_str)
                        if resolved_id:
                            new_vals.append(resolved_id)
                            if resolved_id != v:
                                changed = True
                        else:
                            # keep original if we couldn't resolve
                            new_vals.append(v)

                    if changed:
                        opt["values"] = new_vals

                # Remove read-only fields prior to PUT
                for ro in ("id", "updateDate", "used"):
                    full.pop(ro, None)

                if changed:
                    u = session.put(policy_url_template.format(policy_id=kept_id), json=full)
                    u.raise_for_status()
                    summary["fixed_conditions"] += 1

                updated_assignments.append(kept_id)

            except Exception as fix_err:
                summary["failed"] += 1
                summary["details"].append(
                    {"id": kept_id, "name": kept_name, "status": "update_failed", "error": str(fix_err)}
                )
                # keep it in the list anyway so we don't break assignments
                updated_assignments.append(kept_id)

        # 3) Replace the assignment list in the config
        try:
            put_resp = session.put(list_url, json={"ratePolicies": updated_assignments})
            put_resp.raise_for_status()
        except Exception as assign_err:
            summary["failed"] += 1
            summary["details"].append({"status": "assign_failed", "error": str(assign_err)})

    except Exception as e:
        summary["failed"] += 1
        summary["details"].append({"status": "failed", "error": str(e)})

    return summary
