test
parser.add_argument(
    "--version-notes",
    dest="version_notes",
    required=False,
    help="Optional Jira issue reference for version notes. Example: --version-notes ABC-123"
)

def set_config_version_notes(session, base_url, config_id, version, jira_issue=None, is_prod=False):
    """
    Writes version notes at the CONFIG VERSION level (not policy).
    If jira_issue is provided, uses: 'Jira Ticket Ref for <Env>: <jira_issue>'
    Otherwise uses default: 'Automatically created for <Env> onboarding'
    """
    env_label = "Prod" if is_prod else "NonProd"
    note = (
        f"Jira Ticket Ref for {env_label}: {jira_issue}"
        if jira_issue else
        f"Automatically created for {env_label} onboarding"
    )

    url = urljoin(base_url, f"/appsec/v1/configs/{config_id}/versions/{version}/version-notes")
    payload = {"notes": note}

    try:
        resp = session.put(url, json=payload)
        resp.raise_for_status()
        print(f"[SUCCESS] Version notes set for v{version} ({env_label}): {note}")
        return True
    except Exception as e:
        print(f"[WARN] Failed to set version notes for v{version} ({env_label}): {e}")
        return False

3) Call it from main()
A) When you create NonProd (new config path)

Right after you’ve created the NonProd policy (i.e., after policy_id = create_default_policy(...)), add:

# Set version notes for NonProd (v1)
set_config_version_notes(
    session=session,
    base_url=base_url,
    config_id=config_id,
    version=1,
    jira_issue=args.version_notes,
    is_prod=False
)


B) When you onboard Prod on an existing config

Inside your if existing_config_id and args.isProd: branch, after the PROD policy is created by onboard_prod_policy(...), add:

# Belt & braces: ensure version notes for Prod (v1) on existing config
set_config_version_notes(
    session=session,
    base_url=base_url,
    config_id=existing_config_id,
    version=1,
    jira_issue=args.version_notes,
    is_prod=True
)

That’s it. This will:

Use the Jira issue if Jenkins passes --version-notes ${params.JIRA_ISSUE}

Fall back to the default “Automatically created for … onboarding” if not provided

Write notes at the config version level for both NonProd and (later) Prod creations.


def ensure_config_hostnames(session, base_url, config_id, fqdn_list):
    """
    Ensure the security config's 'hostnames' includes all entries in fqdn_list.
    Tries the config-level hostnames endpoint first, then falls back to the
    versioned endpoint (some accounts expose one or the other).
    """
    wanted = set([h.strip().lower() for h in fqdn_list if h and h.strip()])

    def _get(url):
        resp = session.get(url)
        if resp.status_code == 404:
            return None, 404
        resp.raise_for_status()
        data = resp.json() if resp.text else {}
        current = set([h.strip().lower() for h in data.get("hostnames", [])])
        return current, resp.status_code

    def _put(url, all_hosts):
        payload = {"hostnames": sorted(all_hosts)}
        r = session.put(url, json=payload)
        r.raise_for_status()
        return True

    # Preferred (config-level) endpoint
    cfg_url = f"{base_url}/appsec/v1/configs/{config_id}/hostnames"
    # Fallback (some tenants expose hostnames per version)
    ver_url = f"{base_url}/appsec/v1/configs/{config_id}/versions/1/hostnames"

    # Try config-level GET
    current, code = _get(cfg_url)
    if code != 404:
        all_hosts = (current or set()) | wanted
        if all_hosts != (current or set()):
            _put(cfg_url, all_hosts)
        return {"where": "config", "before": sorted(current or []), "after": sorted(all_hosts)}

    # Fallback: version-level GET/PUT
    current, _ = _get(ver_url)
    all_hosts = (current or set()) | wanted
    if all_hosts != (current or set()):
        _put(ver_url, all_hosts)
    return {"where": "version", "before": sorted(current or []), "after": sorted(all_hosts)}

2) Call it from main()
A) When you’re doing Prod onboarding on an existing config

Immediately after onboard_prod_policy(...) returns (that’s the spot you just added the version-notes “belt & braces”), add:

# Also make sure the config’s 'Hostnames currently associated with this configuration'
# includes the PROD FQDNs we just onboarded.
ensure_config_hostnames(session, base_url, existing_config_id, args.fqdn)
return None



(Place it right before your return None in that Prod branch—i.e., just after the call to onboard_prod_policy(...) and after set_config_version_notes(..., is_prod=True).)

B) When you’re creating Non-Prod from scratch

After you create the config/policy (your current flow: create_security_config(...), then create_default_policy(...), then reassignments), add:

You can put this right after the create_default_policy(...) call (it’s harmless if the hostnames already match because the function will no-op).

# Belt & braces: make sure the config carries these Non-Prod FQDNs
ensure_config_hostnames(session, base_url, config_id, fqdn_list)

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

def ensure_config_hostnames(session, base_url, config_id, fqdn_list):
    """
    Ensure the security config's 'hostnames' includes all entries in fqdn_list.
    Handles both /configs/{id}/hostnames (preferred) and /configs/{id}/versions/1/hostnames (fallback).
    """
    wanted = set([h.strip().lower() for h in fqdn_list if h and h.strip()])

    def _get(url):
        resp = session.get(url)
        if resp.status_code == 404:
            return None, 404
        resp.raise_for_status()
        data = resp.json() if resp.text else {}
        current = set([h.strip().lower() for h in data.get("hostnames", [])])
        return current, resp.status_code

    def _put(url, all_hosts):
        payload = {"hostnames": sorted(all_hosts)}
        print(f"[INFO] Updating hostnames via {url} -> {payload}")
        r = session.put(url, json=payload)
        if r.status_code == 404:
            print("[WARN] 404 on PUT, endpoint may not be supported.")
            return False
        r.raise_for_status()
        return True

    # Try config-level first (preferred)
    cfg_url = f"{base_url}/appsec/v1/configs/{config_id}/hostnames"
    current, code = _get(cfg_url)
    if code != 404:
        all_hosts = (current or set()) | wanted
        if all_hosts != (current or set()):
            _put(cfg_url, all_hosts)
        print(f"[INFO] Hostnames updated on config {config_id}: {sorted(all_hosts)}")
        return

    # Fallback: version-level
    ver_url = f"{base_url}/appsec/v1/configs/{config_id}/versions/1/hostnames"
    current, _ = _get(ver_url)
    all_hosts = (current or set()) | wanted
    if all_hosts != (current or set()):
        _put(ver_url, all_hosts)
    print(f"[INFO] Hostnames updated on version 1 of config {config_id}: {sorted(all_hosts)}")


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

def ensure_config_hostnames(session, base_url, config_id, fqdn_list):
    """
    Ensures that the given FQDNs are explicitly associated with the Web Security Config.
    This uses the config-level hostnames endpoint so updates reflect in the GUI.
    """
    fqdn_list = sorted(set([f.strip().lower() for f in fqdn_list if f.strip()]))
    url = f"{base_url}/appsec/v1/configs/{config_id}/hostnames"

    # Retrieve existing hostnames
    resp = session.get(url)
    if resp.status_code == 404:
        print(f"[WARN] Hostnames endpoint not found for config {config_id}.")
        return
    resp.raise_for_status()
    existing = sorted(set(resp.json().get("hostnames", [])))

    # Merge and update if needed
    merged = sorted(set(existing) | set(fqdn_list))
    if merged != existing:
        payload = {"hostnames": merged}
        print(f"[INFO] Updating config-level hostnames: {payload}")
        put_resp = session.put(url, json=payload)
        put_resp.raise_for_status()
        print(f"[SUCCESS] Config {config_id} hostnames updated to: {merged}")
    else:
        print(f"[INFO] No hostname changes needed for config {config_id}. Current: {merged}")
#################################################################################################################

def ensure_config_hostnames(session, base_url, config_id, fqdn_list):
    fqdn_list = sorted(set([f.strip().lower() for f in fqdn_list if f.strip()]))

    # Try config-level endpoint first (GUI-level association)
    config_url = f"{base_url}/appsec/v1/configs/{config_id}/hostnames"
    version_url = f"{base_url}/appsec/v1/configs/{config_id}/versions/1/hostnames"

    for url in [config_url, version_url]:
        try:
            resp = session.get(url)
            if resp.status_code == 404:
                continue  # try the next endpoint
            resp.raise_for_status()
            existing = sorted(set(resp.json().get("hostnames", [])))
            merged = sorted(set(existing) | set(fqdn_list))
            if merged != existing:
                payload = {"hostnames": merged}
                print(f"[INFO] Updating hostnames via {url} -> {payload}")
                put_resp = session.put(url, json=payload)
                put_resp.raise_for_status()
                print(f"[SUCCESS] Hostnames updated on {url}: {merged}")
            else:
                print(f"[INFO] No hostname changes needed on {url}. Current: {merged}")
            return  # stop after first successful endpoint
        except Exception as e:
            print(f"[WARN] Hostnames update failed on {url}: {e}")

    print(f"[ERROR] No supported hostnames endpoint found for config {config_id}.")


***************************************************************************************************************************************************


def ensure_config_hostnames(session, base_url, config_id, fqdn_list):
    """
    Ensures that the given FQDNs are explicitly associated with the Web Security Config.
    Tries the versioned endpoint first, then falls back to the config-level endpoint.
    Merges with any existing hostnames (idempotent).
    """
    want = sorted(set([h.strip().lower() for h in fqdn_list if h and h.strip()]))
    if not want:
        print(f"[INFO] No FQDNs provided to associate with config {config_id}. Skipping.")
        return

    # Preferred (and observed working) endpoint: versions/1/hostnames
    url_versioned_get = f"{base_url}/appsec/v1/configs/{config_id}/versions/1/hostnames"
    url_versioned_put = url_versioned_get

    # Fallback: config-level hostnames endpoint
    url_cfg_get  = f"{base_url}/appsec/v1/configs/{config_id}/hostnames"
    url_cfg_post = url_cfg_get  # POST on the config-level endpoint

    def _merge_and_equal(existing, desired):
        existing_norm = sorted(set([h.strip().lower() for h in existing if h and h.strip()]))
        merged = sorted(set(existing_norm) | set(desired))
        return existing_norm, merged, (existing_norm == merged)

    # 1) Try versioned endpoint
    try:
        r = session.get(url_versioned_get)
        if r.ok:
            existing = r.json().get("hostnames", [])
            existing_norm, merged, no_change = _merge_and_equal(existing, want)

            if no_change:
                print(f"[INFO] Hostnames already up to date for version 1 of config {config_id}.")
                print(f"[INFO] Total hostnames associated with config {config_id}: {len(merged)} -> {merged}")
                return

            put = session.put(url_versioned_put, json={"hostnames": merged})
            put.raise_for_status()
            print(f"[SUCCESS] Hostnames updated on version 1 of config {config_id}.")
            print(f"[INFO] Total hostnames associated with config {config_id}: {len(merged)} -> {merged}")
            return
        else:
            # If GET isn't supported, continue to fallback
            pass
    except requests.exceptions.HTTPError as e:
        # Some tenants don’t support the versioned endpoint for PUT/GET
        print(f"[WARN] Versioned hostnames endpoint not supported or failed for config {config_id}: {e}")

    # 2) Fallback to config-level endpoint
    try:
        existing = []
        r2 = session.get(url_cfg_get)
        if r2.ok:
            existing = r2.json().get("hostnames", [])

        existing_norm, merged, no_change = _merge_and_equal(existing, want)
        if no_change:
            print(f"[INFO] Hostnames already up to date on config-level endpoint for config {config_id}.")
            print(f"[INFO] Total hostnames associated with config {config_id}: {len(merged)} -> {merged}")
            return

        # Config-level endpoint typically uses POST
        post = session.post(url_cfg_post, json={"hostnames": merged})
        post.raise_for_status()
        print(f"[SUCCESS] Hostnames updated on config {config_id} (config-level endpoint).")
        print(f"[INFO] Total hostnames associated with config {config_id}: {len(merged)} -> {merged}")
        return
    except requests.exceptions.HTTPError as e:
        print(f"[INFO] No supported hostnames endpoint found for config {config_id}. Details: {e}")

