import requests
from typing import Any, Callable, Dict, Iterable, List, Optional, Tuple

def reassign_dos_protection_rate_policies(
    session: requests.Session,
    base_url: str,
    config_id: str | int,
    version: str | int,
    access_group: str,
    template_policy_name_prefix: str = "Security Policy Template",
    template_bypass_name: str = "Security Policy Template Rate Controls Bypass List",
    sc_bypass_suffix: str = "Rate Controls Bypass List",
    activate_clones: bool = True,
    target_policy_id: str | None = None,
    debug: bool = True,
    **kwargs: Any,
) -> Dict[str, Any]:
    """
    Reassign & sanitize DoS rate policies for a given Security Config version.

    Steps
    -----
    1) Read current DoS assignment list for the config/version.
    2) For each attached rate policy:
       - If its name starts with the template prefix, clone it to "SC-<access_group> <suffix>".
       - Otherwise keep it.
    3) For each kept/cloned policy, inspect `additionalMatchOptions` and, for any
       `NetworkListCondition`, replace template list names with your SC list ID.
    4) PUT the updated policy (if changed) and PUT the updated assignment list.

    Optional helpers (via **kwargs)
    --------------------------------
    - search_client_lists_by_name: Callable[[requests.Session, str, str], List[Tuple[str, str]]]
      Should return a list of (listId, name). If not provided, we fall back to
      Network Lists v2 search: GET {base_url}/network-list/v2/network-lists?search=...
    """

    # -------- helpers ---------------------------------------------------------

    def _log(msg: str) -> None:
        if debug:
            print(msg)

    def _err(msg: str) -> None:
        print(msg)

    def _norm_str(x: Any) -> str:
        return str(x).strip()

    cfg = _norm_str(config_id)
    ver = _norm_str(version)

    # Basic sanity — avoid silent 404 churn
    _log(f"[DBG] DoS reassignment called with config_id='{cfg}', version='{ver}'")
    if not cfg.isdigit():
        _err(f"[ERROR] config_id is not numeric: '{cfg}'. Aborting DoS reassignment.")
        return {"processed": 0, "successful": 0, "failed": 1, "fixed_conditions": 0,
                "details": [{"status": "failed", "error": "non-numeric config_id"}]}
    if len(cfg) < 6:  # most AppSec config IDs are 6+ digits
        _err(f"[ERROR] config_id '{cfg}' looks too short; this typically causes 404s. Aborting.")
        return {"processed": 0, "successful": 0, "failed": 1, "fixed_conditions": 0,
                "details": [{"status": "failed", "error": f"suspicious config_id '{cfg}'"}]}

    # Endpoints
    list_url = f"{base_url}/appsec/v1/configs/{cfg}/versions/{ver}/dos-rates"
    clone_url = f"{base_url}/appsec/v1/rate-policies/clone"
    policy_url_template = f"{base_url}/appsec/v1/rate-policies/{{policy_id}}"

    # Allow using your project helper if passed in
    external_search_fn: Optional[
        Callable[[requests.Session, str, str], List[Tuple[str, str]]]
    ] = kwargs.get("search_client_lists_by_name")

    def _search_network_lists_by_name(name_fragment: str) -> List[Tuple[str, str]]:
        """
        Fallback resolver when no helper is supplied.
        Searches Network Lists v2 for IP/CIDR lists containing the fragment.
        Returns [(listId, name), ...]
        """
        try:
            # NOTE: network-lists API uses a different path; this usually works under the same host.
            url = f"{base_url}/network-list/v2/network-lists?search={requests.utils.quote(name_fragment)}&extended=true"
            r = session.get(url, timeout=30)
            r.raise_for_status()
            items = r.json().get("networkLists", []) or r.json().get("list", [])
            out: List[Tuple[str, str]] = []
            for it in items:
                # Common field names across variants
                lid = it.get("uniqueId") or it.get("listId") or it.get("id")
                nm = it.get("name")
                ltype = (it.get("type") or it.get("listType") or "").upper()
                if lid and nm and "IP" in ltype:  # match IP/CIDR-ish lists
                    out.append((str(lid), str(nm)))
            return out
        except Exception as e:
            _err(f"[WARN] Network Lists search failed for '{name_fragment}': {e}")
            return []

    def _resolve_list_id_by_name(name_or_id: str) -> str | None:
        """
        If the value is a numeric ID already, return as-is.
        Otherwise, search by name (prefer external helper if provided).
        """
        s = _norm_str(name_or_id)
        if s.isdigit():
            return s

        # Construct expected SC list name if the template name is provided
        expected = s
        if "Security Policy Template" in s or s == template_bypass_name:
            suffix = s.split("Security Policy Template", 1)[-1].strip()
            expected = f"SC-{access_group} {suffix}".strip()
        # If the caller already replaced values to "SC-<group> …", keep expected as-is.

        # Use external helper (if supplied), else fallback Network Lists v2
        matches: List[Tuple[str, str]] = []
        if external_search_fn:
            try:
                matches = external_search_fn(session, base_url, expected) or []
            except Exception as e:
                _err(f"[WARN] External list search failed for '{expected}': {e}")
        if not matches:
            matches = _search_network_lists_by_name(expected)

        # Pick the first exact case-insensitive name match, else first partial
        exact = [m for m in matches if _norm_str(m[1]).lower() == expected.lower()]
        if exact:
            return exact[0][0]
        return matches[0][0] if matches else None

    # -------- main logic ------------------------------------------------------

    summary: Dict[str, Any] = {"processed": 0, "successful": 0, "failed": 0,
                               "fixed_conditions": 0, "details": []}

    try:
        # 1) Read current DoS assignments
        _log(f"[DBG] GET assigned DoS policies: {list_url}")
        resp = session.get(list_url, timeout=30)
        resp.raise_for_status()
        assigned = resp.json().get("ratePolicies", [])
    except requests.HTTPError as he:
        _err(f"[ERROR] Failed to GET DoS assignments for config {cfg} v{ver}: {he} "
             f"(status {getattr(he.response, 'status_code', '?')})")
        return summary
    except Exception as e:
        _err(f"[ERROR] Unexpected error fetching assignments: {e}")
        return summary

    updated_assignment_ids: List[str] = []

    for rp in assigned:
        summary["processed"] += 1
        orig_id = str(rp.get("id"))
        orig_name = rp.get("name", "")
        kept_id = orig_id
        kept_name = orig_name

        # 2) Clone template-named rate policies to SC-<group> …
        if orig_name.startswith(template_policy_name_prefix):
            suffix = orig_name.replace(template_policy_name_prefix, "").strip()
            clone_name = f"SC-{access_group} {suffix}".strip()
            # If this clone already exists in the assignment list, reuse
            existing = next((x for x in assigned if x.get("name") == clone_name), None)
            if existing:
                kept_id = str(existing.get("id"))
                kept_name = clone_name
                _log(f"[DBG] Reusing existing cloned rate policy: {kept_name} ({kept_id})")
            else:
                try:
                    payload = {
                        "cloneFromRatePolicyId": int(orig_id) if orig_id.isdigit() else orig_id,
                        "name": clone_name,
                        "description": f"Cloned from {orig_name}",
                        "matchType": rp.get("matchType"),
                    }
                    _log(f"[DBG] Cloning rate policy '{orig_name}' -> '{clone_name}'")
                    c = session.post(clone_url, json=payload, timeout=60)
                    c.raise_for_status()
                    kept_id = str(c.json().get("id"))
                    kept_name = clone_name
                    if activate_clones and kept_id:
                        _log(f"[DBG] Activating cloned rate policy {kept_id} on STAGING")
                        try:
                            session.post(
                                policy_url_template.format(policy_id=kept_id) + "/activate",
                                json={"network": "STAGING"},
                                timeout=30,
                            )
                        except Exception as act_e:
                            _err(f"[WARN] Staging activation failed for {kept_id}: {act_e}")
                    summary["successful"] += 1
                    summary["details"].append({"template": orig_name, "clone": kept_name, "status": "success"})
                except Exception as ce:
                    _err(f"[WARN] Clone failed for '{orig_name}': {ce}. Keeping original.")
                    kept_id = orig_id
                    kept_name = orig_name
                    summary["failed"] += 1
                    summary["details"].append({"template": orig_name, "status": "clone_failed", "error": str(ce)})

        # 3) Fix NetworkListCondition values on the kept policy
        try:
            full_url = policy_url_template.format(policy_id=kept_id)
            d = session.get(full_url, timeout=30)
            d.raise_for_status()
            full = d.json()

            if target_policy_id and str(full.get("policyId")) != str(target_policy_id):
                # Only fixing a specific attached security policy; skip others
                updated_assignment_ids.append(kept_id)
                continue

            changed = False
            for opt in full.get("additionalMatchOptions", []) or []:
                if opt.get("type") != "NetworkListCondition":
                    continue
                values = opt.get("values", []) or []
                new_vals: List[Any] = []
                for v in values:
                    s = _norm_str(v)
                    # If it's not an ID, try to map to SC- list ID
                    if s.isdigit():
                        new_vals.append(s)
                    else:
                        # If it's *exactly* the template name, convert to SC-<group> name first
                        repl_name = s
                        if s == template_bypass_name or "Security Policy Template" in s:
                            suffix = s.split("Security Policy Template", 1)[-1].strip()
                            repl_name = f"SC-{access_group} {suffix}".strip()
                        list_id = _resolve_list_id_by_name(repl_name)
                        new_vals.append(list_id if list_id else v)
                        if list_id and list_id != s:
                            changed = True

                # Debug preview of the change
                try:
                    before = values
                    after = new_vals
                    if before != after:
                        _log(f"[DBG] Payload (NetworkListCondition) change for '{kept_name}':")
                        _log(f"      before: {before}")
                        _log(f"      after : {after}")
                except Exception:
                    pass

                opt["values"] = new_vals

            # scrub read-only fields
            for ro in ("id", "updateDate", "used", "createDate", "createdBy"):
                full.pop(ro, None)

            if changed:
                u = session.put(full_url, json=full, timeout=60)
                u.raise_for_status()
                summary["fixed_conditions"] += 1
                _log(f"[INFO] Updated DoS policy '{kept_name}' ({kept_id}) with new client list id(s).")

            updated_assignment_ids.append(kept_id)

        except requests.HTTPError as he:
            _err(f"[ERROR] Failed to update rate policy {kept_id} ('{kept_name}'): "
                 f"status {he.response.status_code} – {he}")
            summary["failed"] += 1
            summary["details"].append(
                {"id": kept_id, "name": kept_name, "status": "update_failed", "error": str(he)}
            )
            updated_assignment_ids.append(kept_id)
        except Exception as e:
            _err(f"[ERROR] Unexpected while updating rate policy {kept_id}: {e}")
            summary["failed"] += 1
            summary["details"].append(
                {"id": kept_id, "name": kept_name, "status": "update_failed", "error": str(e)}
            )
            updated_assignment_ids.append(kept_id)

    # 4) PUT the updated assignment list
    try:
        _log(f"[DBG] PUT new DoS assignment list ({len(updated_assignment_ids)} ids) -> {list_url}")
        put_resp = session.put(list_url, json={"ratePolicies": updated_assignment_ids}, timeout=30)
        put_resp.raise_for_status()
    except Exception as assign_err:
        _err(f"[ERROR] Failed to PUT assignment list: {assign_err}")
        summary["failed"] += 1
        summary["details"].append({"status": "assign_failed", "error": str(assign_err)})

    return summary
