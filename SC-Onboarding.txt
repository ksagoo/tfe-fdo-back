import requests
import json
from typing import Dict, List, Union, Any, Optional

def reassign_dos_protection_rate_policies(
    session: requests.Session,
    base_url: str,
    config_id: Union[str, int],
    version: Union[str, int],
    access_group: str,
    list_name_fragment: Optional[str] = None,
) -> Dict[str, Union[int, List[Dict[str, str]]]]:
    """
    Reassign DoS / Rate Limiting policies to use the correct Client List
    for the specified access_group.

    - Finds the correct client list (active or inactive).
    - Fetches all rate policies.
    - Builds a minimal valid payload for each policy update.
    - Updates only the bypass list field (or additionalMatchOptions).
    """
    summary: Dict[str, Union[int, List[Dict[str, str]]]] = {"successful": 0, "failed": 0, "details": []}
    fragment = (list_name_fragment or f"SC-{access_group} Rate Controls Bypass List").strip()
    print(f"[DBG] Matching fragment: '{fragment}' (case-insensitive)")

    # -------------------------
    # Helpers
    # -------------------------
    def _pretty_dump(label: str, data: Any):
        print(f"[DBG] {label} (formatted):")
        try:
            print(json.dumps(data, indent=2))
        except Exception:
            print(f"[DBG] {label} could not be pretty-printed; non-JSON type.")

    def _collect_list_candidates(obj: Any) -> List[Dict[str, Any]]:
        """Recursively traverse obj to collect dicts that look like 'list' records."""
        candidates: List[Dict[str, Any]] = []

        def has_id(d: Dict[str, Any]) -> bool:
            return any(k in d and d[k] for k in ("listId", "id", "uniqueId"))

        def is_candidate(d: Dict[str, Any]) -> bool:
            name = d.get("name")
            return isinstance(name, str) and has_id(d)

        def walk(node: Any):
            if isinstance(node, dict):
                if is_candidate(node):
                    candidates.append(node)
                for v in node.values():
                    walk(v)
            elif isinstance(node, list):
                for item in node:
                    walk(item)

        walk(obj)
        return candidates

    def _format_candidate_debug(d: Dict[str, Any]) -> str:
        return (
            f"name={d.get('name')} "
            f"id={d.get('listId') or d.get('id') or d.get('uniqueId')} "
            f"status={d.get('status')} "
            f"protection={d.get('protectionStatus')} "
            f"shared={d.get('shared')} "
            f"type={d.get('type')}"
        )

    # -------------------------
    # STEP 1: Resolve client list
    # -------------------------
    client_list_id: Optional[str] = None
    client_list_name: Optional[str] = None

    try:
        resp = session.get(
            f"{base_url}/client-list/v1/lists",
            params={"includeInactive": "true"},
        )
        resp.raise_for_status()
        data = resp.json()
        _pretty_dump("Raw Client Lists response", data)

        candidates = _collect_list_candidates(data)
        print(f"[DBG] Client Lists: discovered {len(candidates)} candidates")
        for it in candidates:
            print(f"    - {_format_candidate_debug(it)}")

        frag_lower = fragment.lower()
        for it in candidates:
            name = (it.get("name") or "").strip()
            if name and frag_lower in name.lower():
                client_list_id = str(it.get("listId") or it.get("id") or it.get("uniqueId"))
                client_list_name = name
                break

    except Exception as e:
        print(f"[WARN] Client Lists API lookup failed: {e}")

    if not client_list_id:
        print(f"[ERROR] No matching Client List found for fragment '{fragment}'. Cannot proceed.")
        return summary

    print(f"[INFO] Using list '{client_list_name}' (ID: {client_list_id}) for DoS reassignment.")

    # -------------------------
    # STEP 2: Fetch rate policies
    # -------------------------
    rate_url = f"{base_url}/appsec/v1/configs/{config_id}/versions/{version}/rate-policies"
    try:
        r = session.get(rate_url)
        r.raise_for_status()
        raw_policies = r.json()
        _pretty_dump("Raw rate policies response", raw_policies)
        policies = raw_policies.get("ratePolicies", [])
    except Exception as e:
        print(f"[ERROR] Failed to fetch rate policies: {e}")
        summary["failed"] += 1
        summary["details"].append({"policy": "N/A", "status": "failed", "error": str(e)})
        return summary

    if not policies:
        print("[INFO] No rate policies found for this config/version.")
        return summary

    print(f"[INFO] Found {len(policies)} rate policies to process.")

    # Helper to pick correct ID field
    def get_policy_id(p: dict) -> str:
        return str(
            p.get("id")
            or p.get("policyId")
            or p.get("uuid")
            or p.get("uniqueId")
            or ""
        )

    # -------------------------
    # STEP 3: Update each policy
    # -------------------------
    for policy in policies:
        policy_id = get_policy_id(policy)
        policy_name = policy.get("name") or "Unnamed Policy"
        rp_url = f"{base_url}/appsec/v1/configs/{config_id}/versions/{version}/rate-policies/{policy_id}"
        print(f"[DBG] Fetching details for policy '{policy_name}' using id={policy_id}")

        try:
            rp_resp = session.get(rp_url)
            rp_resp.raise_for_status()
            full_doc = rp_resp.json()

            # Build a minimal payload from scratch
            payload = {
                "name": full_doc.get("name"),
                "description": full_doc.get("description"),
                "matchType": full_doc.get("matchType"),
                "pathMatchType": full_doc.get("pathMatchType"),
                "requestType": full_doc.get("requestType"),
                "type": full_doc.get("type"),
                "sameActionOnIpv6": full_doc.get("sameActionOnIpv6", True),
                "averageThreshold": full_doc.get("averageThreshold"),
                "burstThreshold": full_doc.get("burstThreshold"),
                "burstWindow": full_doc.get("burstWindow"),
            }

            # Preserve action if present
            if "action" in full_doc:
                payload["action"] = full_doc["action"]

            # Update bypass list
            if "additionalMatchOptions" in full_doc:
                payload["additionalMatchOptions"] = []
                for opt in full_doc.get("additionalMatchOptions", []):
                    if isinstance(opt, dict) and opt.get("type") == "NetworkListCondition":
                        opt["values"] = [client_list_id]
                    payload["additionalMatchOptions"].append(opt)
            elif "matchCriteria" in full_doc:
                payload["matchCriteria"] = full_doc.get("matchCriteria", {})
                payload["matchCriteria"]["bypassNetworkLists"] = [client_list_id]

            print(f"[DBG] PUT URL: {rp_url}")
            print("[DBG] Payload being sent:")
            print(json.dumps(payload, indent=2))

            put_resp = session.put(rp_url, json=payload)
            put_resp.raise_for_status()
            summary["successful"] += 1
            summary["details"].append({"policy": policy_name, "status": "updated"})

            print(f"[INFO] Updated rate policy '{policy_name}' -> list {client_list_name} ({client_list_id})")

        except Exception as e:
            print(f"[ERROR] Failed updating rate policy '{policy_name}': {e}")
            summary["failed"] += 1
            summary["details"].append({"policy": policy_name, "status": "failed", "error": str(e)})

    print(f"[INFO] Reassignment complete. Success: {summary['successful']}, Failed: {summary['failed']}")
    return summary
