def reassign_dos_protection_rate_policies(
    session,
    base_url: str,
    config_id: int | str,
    version: int | str,
    access_group: str,
    template_policy_name_prefix: str = "Security Policy Template",
):
    """
    Make sure every DoS Rate Limiting policy attached to this *config version*
    uses the SC-<access_group> Rate Controls Bypass List, replacing any template
    list references that may still be present.

    Works with the nested endpoints:
      - GET  /appsec/v1/configs/{configId}/versions/{version}/dos-rates
      - GET  /appsec/v1/configs/{configId}/versions/{version}/rate-policies/{ratePolicyId}
      - PUT  /appsec/v1/configs/{configId}/versions/{version}/rate-policies/{ratePolicyId}
    """
    # Endpoints
    list_url = f"{base_url}/appsec/v1/configs/{config_id}/versions/{version}/dos-rates"
    nested_policy_url = (
        f"{base_url}/appsec/v1/configs/{config_id}/versions/{version}/rate-policies/{{policy_id}}"
    )

    # Resolve the target client list ID (the one we want)
    # Expected name pattern: "SC-<access_group> Rate Controls Bypass List"
    desired_list_name = f"SC-{access_group} Rate Controls Bypass List"
    desired_list_id = None

    def _is_int(s: str) -> bool:
        try:
            int(str(s).strip())
            return True
        except Exception:
            return False

    # Helper: resolve client-list id by name (exact; fallback to contains)
    def _resolve_client_list_id_by_name(name: str) -> str | None:
        # Reuse your existing helpers if you have them. If not, keep this minimal resolver:
        # GET /appsec/v1/client-list?search=<name> (if you have such helper already, call that)
        # Many teams already have: `search_client_lists_by_name(session, base_url, name)`
        try:
            # If you already have this helper in your codebase, prefer it:
            if "search_client_lists_by_name" in globals():
                matches = search_client_lists_by_name(session, base_url, name)
                # matches -> list of tuples (listId, name)
                if matches:
                    return str(matches[0][0])
        except Exception:
            pass
        return None

    # Try to find the ID of our SC-* list
    desired_list_id = _resolve_client_list_id_by_name(desired_list_name)

    if not desired_list_id:
        print(f"[WARN] Could not resolve client list id for '{desired_list_name}'. "
              f"Rate policy rewrite will be skipped.")
        return {"processed": 0, "successful": 0, "failed": 0, "fixed_conditions": 0, "details": []}

    summary = {"processed": 0, "successful": 0, "failed": 0, "fixed_conditions": 0, "details": []}

    try:
        # 1) Grab the list of assigned rate policies for this config version
        lr = session.get(list_url)
        lr.raise_for_status()
        assigned = lr.json().get("ratePolicies", [])

        if not assigned:
            print(f"[DBG] No DoS rate policies are assigned under config {config_id}, version {version}.")
            return summary

        print(f"[DBG] Found {len(assigned)} DoS policies attached to config {config_id}/v{version}.")

        for rp in assigned:
            summary["processed"] += 1
            pid = rp.get("id")
            pname = rp.get("name", f"(id {pid})")

            # 2) Fetch the full, nested policy
            get_url = nested_policy_url.format(policy_id=pid)
            try:
                pr = session.get(get_url)
                pr.raise_for_status()
                full = pr.json()
            except requests.exceptions.HTTPError as he:
                # If this ever appears, we’ll log and skip gracefully
                print(f"[DBG] FETCH failed for policy '{pname}' (id={pid}): {he}")
                summary["failed"] += 1
                summary["details"].append({"id": pid, "name": pname, "status": "fetch_failed", "error": str(he)})
                continue

            changed = False

            # 3) Rewrite NetworkListCondition values to the desired client list id
            for opt in full.get("additionalMatchOptions", []) or []:
                if opt.get("type") != "NetworkListCondition":
                    continue

                # Capture original for debug
                original_vals = list(opt.get("values", []))
                new_vals: list[str] = []

                for v in original_vals:
                    v_str = str(v).strip()
                    if _is_int(v_str):
                        # If it’s already our desired id, keep as-is; otherwise prefer replacing
                        if v_str == str(desired_list_id):
                            new_vals.append(v_str)
                        else:
                            # Replace any existing id with our desired id; we only need one list
                            new_vals.append(str(desired_list_id))
                        changed = True
                    else:
                        # It’s a name; if it looks like a template or anything else, replace
                        # with the SC-* id. (You can add stricter checks if needed.)
                        new_vals.append(str(desired_list_id))
                        changed = True

                # De-dupe and collapse to only the desired id
                new_vals = [str(desired_list_id)]
                opt["values"] = new_vals

                if changed:
                    print(f"[DBG] Policy '{pname}' (id={pid}) NetworkListCondition: "
                          f"{original_vals} -> {new_vals}")

            if not changed:
                # Nothing to update
                summary["details"].append({"id": pid, "name": pname, "status": "no_change"})
                continue

            # 4) Scrub read-only fields then PUT back to the nested endpoint
            for ro in ("id", "updateDate", "createDate", "createdBy", "used"):
                full.pop(ro, None)

            try:
                putr = session.put(get_url, json=full)
                putr.raise_for_status()
                summary["successful"] += 1
                summary["fixed_conditions"] += 1
                summary["details"].append({"id": pid, "name": pname, "status": "updated"})
            except requests.exceptions.HTTPError as he:
                print(f"[ERROR] PUT failed for policy '{pname}' (id={pid}): {he}")
                summary["failed"] += 1
                summary["details"].append({"id": pid, "name": pname, "status": "put_failed", "error": str(he)})

    except Exception as e:
        print(f"[ERROR] Unexpected error in reassign_dos_protection_rate_policies: {e}")
        summary["failed"] += 1
        summary["details"].append({"status": "failed", "error": str(e)})

    return summary
