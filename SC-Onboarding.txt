from typing import Optional, Union
import requests

def reassign_dos_protection_rate_policies(
    session: requests.Session,
    base_url: str,
    config_id: Union[str, int],
    version: Union[str, int],
    access_group: str,
    target_policy_id: Optional[Union[str, int]] = None,  # process only this policy if given
) -> dict:
    """
    For each rate policy attached to the given security policy(ies), rewrite the
    NetworkListCondition to point at the 'SC-<access_group>-Rate Controls Bypass List'
    (by *name*), then PUT the rate policy back.

    Uses the correct, policy-scoped endpoints:
      /appsec/v1/configs/{id}/versions/{v}/security-policies/{policyId}/rate-policies
    """
    cfg = str(config_id)
    ver = str(version)

    def _p(url: str) -> str:
        print(f"[DBG] {url}")
        return url

    # 1) discover which security policies to touch
    policies = []
    if target_policy_id is not None:
        policies = [str(target_policy_id)]
        print(f"[INFO] Restricting DoS updates to policyId={target_policy_id}")
    else:
        pol_url = _p(f"{base_url}/appsec/v1/configs/{cfg}/versions/{ver}/security-policies")
        try:
            r = session.get(pol_url)
            r.raise_for_status()
            policies = [str(p.get("policyId")) for p in r.json().get("policies", []) if p.get("policyId")]
        except Exception as e:
            print(f"[WARN] Failed to list security policies for config {cfg} v{ver}: {e}")
            return {"successful": 0, "failed": 1, "details": [{"stage": "list_policies", "error": str(e)}]}

    if not policies:
        print("[INFO] No security policies found; skipping DoS reassignment.")
        return {"successful": 0, "failed": 0, "details": []}

    print(f"[INFO] Processing DoS rate policies for {len(policies)} security policy(ies): {policies}")

    summary = {"successful": 0, "failed": 0, "details": []}
    new_list_name = f"SC-{access_group}-Rate Controls Bypass List"

    for policy_id in policies:
        # 2) list rate policies under this security policy
        list_url = _p(f"{base_url}/appsec/v1/configs/{cfg}/versions/{ver}/security-policies/{policy_id}/rate-policies")
        try:
            lr = session.get(list_url)
            lr.raise_for_status()
            rate_policies = lr.json().get("ratePolicies", [])
        except Exception as e:
            msg = f"Failed to list rate policies for policy {policy_id}: {e}"
            print(f"[WARN] {msg}")
            summary["failed"] += 1
            summary["details"].append({"policyId": policy_id, "stage": "list_rate_policies", "error": str(e)})
            continue

        if not rate_policies:
            print(f"[INFO] No rate policies attached to policy {policy_id}")
            continue

        print(f"[INFO] Found {len(rate_policies)} rate policies for policy {policy_id}")

        for rp in rate_policies:
            rp_id = rp.get("id") or rp.get("ratePolicyId")
            rp_name = rp.get("name", f"ratePolicy:{rp_id}")
            if not rp_id:
                print(f"[WARN] Skipping malformed rate policy entry: {rp}")
                continue

            get_rp_url = _p(f"{base_url}/appsec/v1/configs/{cfg}/versions/{ver}/security-policies/{policy_id}/rate-policies/{rp_id}")
            try:
                gr = session.get(get_rp_url)
                gr.raise_for_status()
                full = gr.json()
            except Exception as e:
                msg = f"Could not fetch rate policy {rp_id} ({rp_name}): {e}"
                print(f"[WARN] {msg}")
                summary["failed"] += 1
                summary["details"].append({"policyId": policy_id, "ratePolicyId": rp_id, "stage": "get_rate_policy", "error": str(e)})
                continue

            changed = False
            for opt in full.get("additionalMatchOptions", []):
                # Some payloads use objects; others nest under a key. Normalize to dict lookup.
                opt_type = opt.get("type") or opt.get("matchType")
                if str(opt_type) != "NetworkListCondition":
                    continue

                values = opt.get("values") or opt.get("value") or []
                if not isinstance(values, list):
                    values = [values]

                # Replace any template/default list names *by name* (no id dependency)
                new_values = []
                for v in values:
                    v_str = str(v).strip()
                    if v_str and v_str != new_list_name:
                        changed = True
                        new_values.append(new_list_name)
                    else:
                        new_values.append(v)

                # write back
                if "values" in opt:
                    opt["values"] = new_values
                else:
                    opt["value"] = new_values

            if not changed:
                print(f"[INFO] {rp_name}: no NetworkListCondition changes needed.")
                summary["details"].append({"policyId": policy_id, "ratePolicyId": rp_id, "name": rp_name, "status": "skipped"})
                continue

            # scrub common read-only fields to avoid 4xx
            for ro in ("id", "used", "createDate", "updateDate", "createdBy"):
                full.pop(ro, None)

            put_rp_url = get_rp_url  # same URL
            print(f"[DBG] PUT {put_rp_url} (setting NetworkListCondition -> {new_list_name})")
            try:
                pr = session.put(put_rp_url, json=full)
                pr.raise_for_status()
                summary["successful"] += 1
                summary["details"].append({"policyId": policy_id, "ratePolicyId": rp_id, "name": rp_name, "status": "updated"})
                print(f"[INFO] Updated rate policy {rp_name} ({rp_id}).")
            except Exception as e:
                print(f"[ERROR] Failed to update rate policy {rp_name} ({rp_id}): {e}")
                summary["failed"] += 1
                summary["details"].append({"policyId": policy_id, "ratePolicyId": rp_id, "name": rp_name, "stage": "put_rate_policy", "error": str(e)})

    print(f"[INFO] DoS reassignment done. Success: {summary['successful']}  Failed: {summary['failed']}")
    return summary
