import requests
import json
from typing import Dict, List, Union

def reassign_dos_protection_rate_policies(
    session: requests.Session,
    base_url: str,
    config_id: Union[str, int],
    version: Union[str, int],
    access_group: str,
    list_name_fragment: str = None,   # optional override
) -> Dict[str, Union[int, List[Dict[str, str]]]]:
    """
    Reassign DoS / Rate Limiting policies to use the correct Client List
    for the specified access_group.

    Looks up list via Client Lists API (v1), falls back to Network Lists API (v2),
    then applies it across all rate policies in the given config/version.

    Returns a summary dictionary:
    {
        "successful": <int>,
        "failed": <int>,
        "details": [ { "policy": <name>, "status": "updated|skipped|failed", "error": <optional> } ]
    }
    """
    summary = {"successful": 0, "failed": 0, "details": []}

    # ----------------------------------------------------------------------
    # STEP 1: Find matching client list
    # ----------------------------------------------------------------------
    fragment = list_name_fragment or f"SC-{access_group} Rate Controls Bypass List"
    client_list_id, client_list_name = None, None

    # Try Client Lists API (newer)
    try:
        resp = session.get(
            f"{base_url}/client-list/v1/lists",
            params={"includeInactive": "true"}  # include inactive lists too
        )
        resp.raise_for_status()
        data = resp.json()

        # Pretty-print the raw JSON for debug
        print("[DBG] Raw Client Lists response (formatted):")
        print(json.dumps(data, indent=2))

        if isinstance(data, list):
            lists = data
        elif isinstance(data, dict):
            lists = data.get("lists") or data.get("clientLists") or data.get("items") or []
        else:
            lists = []

        print(f"[DBG] Client Lists parsed {len(lists)} items")
        for it in lists:
            print(
                f"    - name={it.get('name')} "
                f"id={it.get('listId') or it.get('id')} "
                f"status={it.get('status')} "
                f"protection={it.get('protectionStatus')} "
                f"shared={it.get('shared')}"
            )

        # now apply filter (case-insensitive)
        for it in lists:
            name = (it.get("name") or "").strip()
            lid = it.get("listId") or it.get("id")
            if name and fragment.lower() in name.lower():
                client_list_id, client_list_name = lid, name
                break
    except Exception as e:
        print(f"[WARN] Client Lists API lookup failed: {e}")

    # Fallback to Network Lists API (legacy)
    if not client_list_id:
        try:
            resp = session.get(
                f"{base_url}/network-list/v2/network-lists",
                params={"page": 0, "pageSize": 1000},
            )
            resp.raise_for_status()
            payload = resp.json()
            lists = payload.get("networkLists", []) if isinstance(payload, dict) else []
            print(f"[DBG] Network Lists returned {len(lists)} items")
            for it in lists:
                print(
                    f"    - name={it.get('name')} "
                    f"id={it.get('uniqueId') or it.get('id')} "
                    f"type={it.get('type')} "
                    f"shared={it.get('shared')}"
                )
            for it in lists:
                name = (it.get("name") or "").strip()
                lid = it.get("uniqueId") or it.get("id")
                if name and fragment.lower() in name.lower():
                    client_list_id, client_list_name = lid, name
                    break
        except Exception as e:
            print(f"[WARN] Network Lists API lookup failed: {e}")

    if not client_list_id:
        print(f"[ERROR] No matching Client or Network List found for '{fragment}'. Cannot proceed.")
        return summary

    print(f"[INFO] Found matching list '{client_list_name}' (ID: {client_list_id})")

    # ----------------------------------------------------------------------
    # STEP 2: Get all rate policies
    # ----------------------------------------------------------------------
    rate_url = f"{base_url}/appsec/v1/configs/{config_id}/versions/{version}/rate-policies"
    try:
        r = session.get(rate_url)
        r.raise_for_status()
        policies = r.json().get("ratePolicies", [])
    except Exception as e:
        print(f"[ERROR] Failed to fetch rate policies: {e}")
        summary["failed"] += 1
        summary["details"].append({"policy": "N/A", "status": "failed", "error": str(e)})
        return summary

    if not policies:
        print("[INFO] No rate policies found for this config/version.")
        return summary

    print(f"[INFO] Found {len(policies)} rate policies to process.")

    # ----------------------------------------------------------------------
    # STEP 3: Loop and update each policy
    # ----------------------------------------------------------------------
    for policy in policies:
        policy_id = policy.get("id")
        policy_name = policy.get("name") or "Unnamed Policy"
        rp_url = f"{base_url}/appsec/v1/configs/{config_id}/versions/{version}/rate-policies/{policy_id}"

        try:
            rp_resp = session.get(rp_url)
            rp_resp.raise_for_status()
            data = rp_resp.json()
            changed = False

            # newer schema: additionalMatchOptions
            amo = data.get("additionalMatchOptions", [])
            if isinstance(amo, list):
                for opt in amo:
                    if isinstance(opt, dict) and opt.get("type") == "NetworkListCondition":
                        vals = opt.get("values", [])
                        if vals != [client_list_id]:
                            opt["values"] = [client_list_id]
                            changed = True

            # older schema: matchCriteria.bypassNetworkLists
            mc = data.get("matchCriteria")
            if not changed and isinstance(mc, dict):
                existing = mc.get("bypassNetworkLists", [])
                if existing != [client_list_id]:
                    mc["bypassNetworkLists"] = [client_list_id]
                    changed = True

            if not changed:
                summary["details"].append({"policy": policy_name, "status": "skipped"})
                continue

            # clean read-only fields
            for ro in ("id", "updateDate", "createDate", "used"):
                data.pop(ro, None)

            put_resp = session.put(rp_url, json=data)
            put_resp.raise_for_status()
            summary["successful"] += 1
            summary["details"].append({"policy": policy_name, "status": "updated"})

            print(f"[INFO] Updated rate policy '{policy_name}' -> list {client_list_name} ({client_list_id})")

        except Exception as e:
            print(f"[ERROR] Failed updating rate policy '{policy_name}': {e}")
            summary["failed"] += 1
            summary["details"].append({"policy": policy_name, "status": "failed", "error": str(e)})

    print(f"[INFO] Reassignment complete. Success: {summary['successful']}, Failed: {summary['failed']}")
    return summary
