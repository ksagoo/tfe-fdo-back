def reassign_dos_protection_rate_policies(
    session,
    base_url,
    config_id,
    version,
    access_group,
    template_policy_name_prefix="Security Policy Template",
):
    """
    Fix DoS rate policies so their NetworkListCondition (bypass) points to the
    cloned client list for this access group (SC-<access_group> ...).

    What this does (with DEBUG prints):
      1) Reads the assigned DoS rate policies for the config/version.
      2) For each policy:
         - If the name starts with the template prefix, clones it to "SC-<access_group> <suffix>"
           unless a clone already exists (reuses it if present).
         - Fetches the full (kept) policy, finds additionalMatchOptions where type == "NetworkListCondition",
           and resolves each value to the correct client-list ID:
             * If the value is an ID (digits), leave as-is.
             * If it's a name (often the template list name), derive the expected
               "SC-<access_group> <suffix>" and look it up. If found, replace with the ID.
         - PUTs the updated policy back if anything changed.
      3) Rewrites the config's dos-rates assignment with the kept/cloned IDs.

    Returns a summary with counts and details.
    """
    import re

    list_url = f"{base_url}/appsec/v1/configs/{config_id}/versions/{version}/dos-rates"
    clone_url = f"{base_url}/appsec/v1/rate-policies/clone"
    policy_url = f"{base_url}/appsec/v1/rate-policies"

    summary = {
        "processed": 0,
        "cloned": 0,
        "updated": 0,
        "failed": 0,
        "details": [],
    }

    def _is_id(s: str) -> bool:
        return bool(re.fullmatch(r"\d+", str(s or "")))

    def _derive_expected_sc_name(templateish_name: str) -> str:
        # e.g. "Security Policy Template Rate Controls Bypass List" -> "SC-<AG> Rate Controls Bypass List"
        if "Security Policy Template" in templateish_name:
            suffix = templateish_name.split("Security Policy Template", 1)[-1].strip()
            # If suffix starts without a space, add one to keep names natural
            if suffix and not suffix.startswith(" "):
                suffix = " " + suffix
            return f"SC-{access_group}{suffix}".strip()
        # otherwise just try to find by the incoming name
        return templateish_name.strip()

    def _resolve_client_list_id_from_name(name: str) -> str | None:
        expected = _derive_expected_sc_name(name)
        # DEBUG lookup
        print(f"[DEBUG]   Resolving client-list for name '{name}' -> expected '{expected}'")
        try:
            matches = search_client_lists_by_name(session, base_url, expected)
        except Exception as e:
            print(f"[WARN]    search_client_lists_by_name failed for '{expected}': {e}")
            return None
        if matches:
            list_id, list_name = matches[0]
            print(f"[DEBUG]   Found client list: id={list_id}, name='{list_name}'")
            return list_id
        print(f"[WARN]    No client list found matching '{expected}'")
        return None

    try:
        # 1) Read assignment list
        resp = session.get(list_url)
        resp.raise_for_status()
        assigned = resp.json().get("ratePolicies", [])  # list of {id, name, ...} or ids
        print(f"[DEBUG] DoS assignment list contains {len(assigned)} entries")

        # Normalize into [{id, name}] records
        normalized = []
        for p in assigned:
            if isinstance(p, dict):
                normalized.append({"id": p.get("id"), "name": p.get("name", "")})
            else:
                # if API ever returns bare IDs
                normalized.append({"id": p, "name": ""})

        kept_ids = []

        for rec in normalized:
            summary["processed"] += 1
            orig_id = rec["id"]
            # fetch meta to get name if not present
            if not rec["name"]:
                try:
                    meta = session.get(f"{policy_url}/{orig_id}")
                    meta.raise_for_status()
                    rec["name"] = meta.json().get("name", "")
                except Exception as e:
                    print(f"[WARN] Could not fetch name for policy {orig_id}: {e}")
                    rec["name"] = ""

            orig_name = rec["name"]
            kept_id = orig_id
            kept_name = orig_name

            # A) Clone if looks like a template copy (unless a same-name clone is already present)
            if orig_name.startswith(template_policy_name_prefix):
                suffix = orig_name.replace(template_policy_name_prefix, "").strip()
                clone_name = f"SC-{access_group} {suffix}".strip()
                existing = next((x for x in normalized if x["name"] == clone_name), None)
                if existing:
                    kept_id = existing["id"]
                    kept_name = clone_name
                    print(f"[INFO] Reusing existing cloned DoS policy '{clone_name}' (id={kept_id})")
                else:
                    try:
                        payload = {
                            "cloneFromRatePolicyId": orig_id,
                            "name": clone_name,
                            "description": f"Cloned from {orig_name}",
                            "matchType": None,  # server infers from source
                        }
                        c = session.post(clone_url, json=payload)
                        c.raise_for_status()
                        kept_id = c.json().get("id")
                        kept_name = clone_name
                        summary["cloned"] += 1
                        print(f"[INFO] Cloned DoS policy '{orig_name}' -> '{clone_name}' (id={kept_id})")
                    except Exception as e:
                        print(f"[WARN] Clone failed for '{orig_name}': {e} (keeping original)")
                        kept_id = orig_id
                        kept_name = orig_name

            # B) Fetch full policy and fix NetworkListCondition values
            try:
                full = session.get(f"{policy_url}/{kept_id}")
                full.raise_for_status()
                policy = full.json()

                opts = policy.get("additionalMatchOptions", [])
                if not opts:
                    print(f"[DEBUG] Policy '{kept_name}' has no additionalMatchOptions; skipping update.")
                    kept_ids.append(kept_id)
                    continue

                print(f"[DEBUG] Policy '{kept_name}' (id={kept_id}) â€” scanning NetworkListCondition values")
                changed_any = False

                for opt in opts:
                    if opt.get("type") != "NetworkListCondition":
                        continue
                    before_vals = opt.get("values", [])
                    print(f"[DEBUG]   BEFORE values: {before_vals}")

                    after_vals = []
                    for v in before_vals:
                        s = str(v)
                        if _is_id(s):
                            after_vals.append(v)
                            continue
                        resolved = _resolve_client_list_id_from_name(s)
                        after_vals.append(resolved if resolved else v)
                    if after_vals != before_vals:
                        opt["values"] = after_vals
                        changed_any = True
                        print(f"[DEBUG]   AFTER  values:  {after_vals}")

                # scrub read-only fields
                for ro in ("id", "updateDate", "used"):
                    policy.pop(ro, None)

                if changed_any:
                    u = session.put(f"{policy_url}/{kept_id}", json=policy)
                    try:
                        u.raise_for_status()
                        summary["updated"] += 1
                        print(f"[INFO] Updated DoS policy '{kept_name}' (id={kept_id}) with new client list IDs.")
                    except Exception as e:
                        print(f"[ERROR] PUT failed for policy '{kept_name}' (id={kept_id}): {e} / {u.text}")
                        summary["failed"] += 1
                        summary["details"].append(
                            {"id": kept_id, "name": kept_name, "status": "put_failed", "error": u.text}
                        )
                kept_ids.append(kept_id)

            except Exception as e:
                print(f"[ERROR] Could not update policy '{kept_name}' (id={kept_id}): {e}")
                summary["failed"] += 1
                summary["details"].append(
                    {"id": kept_id, "name": kept_name, "status": "fetch_or_update_failed", "error": str(e)}
                )
                kept_ids.append(kept_id)  # keep assignment intact even on failure

        # C) Replace assignment list with the kept/cloned IDs
        try:
            put_list = session.put(list_url, json={"ratePolicies": kept_ids})
            put_list.raise_for_status()
        except Exception as e:
            print(f"[ERROR] Updating DoS assignment list failed: {e} / {getattr(put_list, 'text', '')}")
            summary["failed"] += 1
            summary["details"].append({"status": "assign_put_failed", "error": str(e)})

    except Exception as outer:
        print(f"[ERROR] DoS reassignment flow failed: {outer}")
        summary["failed"] += 1
        summary["details"].append({"status": "outer_failed", "error": str(outer)})

    return summary
