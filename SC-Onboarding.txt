from typing import Optional, Union
import requests

def reassign_dos_protection_rate_policies(
    session: requests.Session,
    base_url: str,
    config_id: Union[int, str],
    version: Union[int, str],
    access_group: str,
    template_policy_name_prefix: str = "Security Policy Template",
    target_policy_id: Optional[str] = None,   # only touch policies attached to this security policy (optional)
    activate_clones: bool = True,             # keep your staging activation behavior
) -> dict:
    """
    For the given security config/version:
      1) Read the assigned DoS rate policies.
      2) For any policy whose name starts with the template prefix, clone it to 'SC-<access_group> <suffix>'.
         Otherwise keep the existing policy.
      3) For each kept/cloned policy, rewrite any additionalMatchOptions/NetworkListCondition values so
         any *names* that look like template lists are replaced with the 'SC-<access_group> â€¦' client list ID.
      4) PUT the updated policy and then PUT the updated assignments list back on the config.
    Emits lots of [DBG] lines so you can see what happened.
    """

    list_url = f"{base_url}/appsec/v1/configs/{config_id}/versions/{version}/dos-rates"
    clone_url = f"{base_url}/appsec/v1/rate-policies/clone"
    policy_url_template = f"{base_url}/appsec/v1/rate-policies/{{policy_id}}"

    summary = {
        "processed": 0,
        "successful": 0,
        "failed": 0,
        "fixed_conditions": 0,
        "details": [],
    }

    # --- small helper: find client-list by (expected) name fragment and return its ID ---
    def _find_client_list_id_by_name(fragment: str) -> Optional[str]:
        try:
            # Akamai appsec client lists search supports ?search=
            url = f"{base_url}/appsec/v1/client-lists?search={fragment}"
            r = session.get(url)
            r.raise_for_status()
            items = r.json().get("content", []) or r.json().get("lists", []) or []
            # match case-insensitively on name containment, prefer exact
            frag_low = fragment.lower().strip()
            exact = [x for x in items if x.get("name", "").lower() == frag_low]
            if exact:
                return str(exact[0].get("id"))
            partial = [x for x in items if frag_low in x.get("name", "").lower()]
            if partial:
                return str(partial[0].get("id"))
            return None
        except Exception as e:
            print(f"[DBG] client-list search failed for '{fragment}': {e}")
            return None

    try:
        # 1) Read current assignments
        resp = session.get(list_url)
        if resp.status_code == 404:
            print(f"[DBG] dos-rates endpoint 404 for this config/version, skipping DoS reassignment.")
            return summary
        resp.raise_for_status()
        assigned = resp.json().get("ratePolicies", [])
        print(f"[DBG] dos-rates assignments: {[ (p.get('id'), p.get('name')) for p in assigned ]}")

        updated_assignments = []

        for p in assigned:
            summary["processed"] += 1
            orig_name = p.get("name", "")
            orig_id = p.get("id")
            kept_id = orig_id
            kept_name = orig_name

            # 2) Clone if looks like template
            if orig_name.startswith(template_policy_name_prefix):
                suffix = orig_name.replace(template_policy_name_prefix, "").strip()
                clone_name = f"SC-{access_group} {suffix}".strip()
                print(f"[DBG] template policy detected -> clone as '{clone_name}'")

                # reuse if already present in assignment list
                existing = next((rp for rp in assigned if rp.get("name") == clone_name), None)
                if existing:
                    kept_id = existing.get("id")
                    kept_name = clone_name
                    print(f"[DBG] clone already exists in assignments -> reuse id {kept_id}")
                else:
                    try:
                        payload = {
                            "cloneFromRatePolicyId": orig_id,
                            "name": clone_name,
                            "description": f"Cloned from {orig_name}",
                            "matchType": p.get("matchType"),
                        }
                        c = session.post(clone_url, json=payload)
                        c.raise_for_status()
                        kept_id = c.json().get("id")
                        kept_name = clone_name
                        print(f"[DBG] cloned new rate policy id={kept_id} name='{kept_name}'")

                        if activate_clones and kept_id:
                            act = session.post(
                                policy_url_template.format(policy_id=kept_id) + "/activate",
                                json={"network": "STAGING"},
                            )
                            if act.status_code >= 400:
                                print(f"[DBG] staging activate of {kept_id} returned {act.status_code} (continuing)")
                        summary["successful"] += 1
                        summary["details"].append({"template": orig_name, "clone": kept_name, "status": "success"})
                    except Exception as clone_err:
                        kept_id = orig_id
                        kept_name = orig_name
                        summary["failed"] += 1
                        summary["details"].append(
                            {"template": orig_name, "status": "clone_failed", "error": str(clone_err)}
                        )
                        print(f"[DBG] clone failed for '{orig_name}': {clone_err} -> keep original")

            # 3) Fix NetworkListCondition values to point at SC- list IDs
            try:
                d = session.get(policy_url_template.format(policy_id=kept_id))
                d.raise_for_status()
                full = d.json()

                if target_policy_id is not None:
                    # only touch policies attached to a specific security policy id
                    if str(full.get("policyId")) != str(target_policy_id):
                        print(f"[DBG] skipping rate policy {kept_id} (attached to different security policy)")
                        updated_assignments.append(kept_id)
                        continue

                changed = False
                for opt in full.get("additionalMatchOptions", []):
                    if opt.get("type") != "NetworkListCondition":
                        continue

                    old_vals = opt.get("values", []) or []
                    new_vals = []

                    for v in old_vals:
                        v_str = str(v).strip()
                        # numeric -> already an ID
                        if v_str.isdigit():
                            new_vals.append(v_str)
                            continue

                        # Looks like a *name* (often the default template list name)
                        # Build the expected SC-<access_group> list name from any template-like name.
                        expected = v_str
                        if "Security Policy Template" in v_str:
                            suffix = v_str.split("Security Policy Template", 1)[-1].strip()
                            expected = f"SC-{access_group} {suffix}".strip()

                        resolved_id = _find_client_list_id_by_name(expected)
                        if resolved_id:
                            new_vals.append(resolved_id)
                            if resolved_id != v_str:
                                changed = True
                        else:
                            # No match found; keep original so we don't break the policy
                            new_vals.append(v_str)

                    if changed:
                        print(f"[DBG] Payload (NetworkListCondition) change for policy '{kept_name}': {new_vals}")
                        opt["values"] = new_vals

                # remove read-only fields before PUT
                for ro in ("id", "updateDate", "used", "createdDate", "createdBy"):
                    if ro in full:
                        full.pop(ro, None)

                if changed:
                    u = session.put(policy_url_template.format(policy_id=kept_id), json=full)
                    u.raise_for_status()
                    summary["fixed_conditions"] += 1
                    print(f"[DBG] Updated DoS policy '{kept_name}' ({kept_id}) with new client list ids.")

                updated_assignments.append(kept_id)

            except Exception as fix_err:
                summary["failed"] += 1
                summary["details"].append(
                    {"id": kept_id, "name": kept_name, "status": "update_failed", "error": str(fix_err)}
                )
                print(f"[DBG] failed to update policy {kept_id} '{kept_name}': {fix_err}")
                updated_assignments.append(kept_id)

        # 4) Write back the assignments list
        try:
            put_resp = session.put(list_url, json={"ratePolicies": updated_assignments})
            put_resp.raise_for_status()
            print(f"[DBG] wrote dos-rates assignments: {updated_assignments}")
        except Exception as assign_err:
            summary["failed"] += 1
            summary["details"].append({"status": "assign_failed", "error": str(assign_err)})
            print(f"[DBG] failed to PUT dos-rates assignments: {assign_err}")

    except Exception as e:
        summary["failed"] += 1
        summary["details"].append({"status": "failed", "error": str(e)})
        print(f"[DBG] top-level failure in reassign_dos_protection_rate_policies: {e}")

    return summary
