def reassign_dos_protection_rate_policies(
    session,
    base_url,
    config_id,
    version,
    access_group,
    template_policy_name_prefix="Security Policy Template",
    target_policy_id: Optional[str] = None,   # only touch policies attached to this security policy (optional)
    activate_clones: bool = True,             # keep your staging activation behavior
):
    """
    Fix DoS rate policies for a config/version:

    1) For every DoS rate policy currently assigned to the config/version:
       - If its name starts with the template prefix, clone to 'SC-<access_group> <suffix>'
         (or reuse existing clone if found); otherwise keep the original.
    2) For the kept/cloned policy, rewrite additionalMatchOptions -> NetworkListCondition
       'values' so that any template client list IDs or names are replaced with the
       corresponding 'SC-<access_group> â€¦' client-list ID (if found).
    3) PUT the cleaned policy back, then update the config's dos-rates assignment list.
    """

    list_url = f"{base_url}/appsec/v1/configs/{config_id}/versions/{version}/dos-rates"
    clone_url = f"{base_url}/appsec/v1/rate-policies/clone"
    policy_url = f"{base_url}/appsec/v1/rate-policies/{{policy_id}}"
    client_lists_url = f"{base_url}/client-list/v1/lists?includeDeprecated=true&includeDeleted=true&includeNetworkLists=true"

    summary = {
        "processed": 0,
        "successful": 0,
        "failed": 0,
        "fixed_conditions": 0,
        "details": [],
    }

    # -------- build client-list lookup & template->clone map (by id and by name) --------
    try:
        r = session.get(client_lists_url)
        r.raise_for_status()
        items = r.json().get("content", [])
    except Exception as e:
        summary["failed"] += 1
        summary["details"].append({"stage": "fetch_client_lists", "error": str(e)})
        return summary

    # normalize helpers
    def _norm(s): return (s or "").strip().lower()

    name_to_id = {}
    id_to_name = {}
    for it in items:
        lid = it.get("listId")
        nm  = it.get("name") or it.get("groupName") or ""
        if lid and nm:
            name_to_id[_norm(nm)] = lid
            id_to_name[str(lid)] = nm

    # map: template_id -> cloned_id, and template_name -> cloned_id
    template_to_clone_id = {}
    for it in items:
        tmpl_name = it.get("name") or ""
        tmpl_id   = str(it.get("listId", ""))
        if not tmpl_name or not tmpl_id:
            continue
        if tmpl_name.startswith("Security Policy Template"):
            suffix = tmpl_name.replace("Security Policy Template", "").strip()
            desired_name = f"SC-{access_group} {suffix}".strip()
            clone_id = name_to_id.get(_norm(desired_name))
            if clone_id:
                template_to_clone_id[tmpl_id] = clone_id
                template_to_clone_id[_norm(tmpl_name)] = clone_id  # name-based match too

    # resolver that accepts either an ID or a name and returns the SC- clone id if applicable
    def _resolve_clone_id(value: str) -> Optional[str]:
        v = str(value).strip()
        # direct id mapping?
        if v.isdigit():
            # if this id corresponds to a template list, map to its clone
            if v in template_to_clone_id:
                return template_to_clone_id[v]
            # id -> name -> check if that name is a template and mapped
            nm = id_to_name.get(v)
            if nm and _norm(nm) in template_to_clone_id:
                return template_to_clone_id[_norm(nm)]
            return None
        # name-based resolution
        vn = _norm(v)
        if vn in template_to_clone_id:
            return template_to_clone_id[vn]
        # if it looks like a template name, derive expected SC- name then look up id
        if "security policy template" in vn:
            suffix = v.split("Security Policy Template", 1)[-1].strip()
            desired = f"SC-{access_group} {suffix}".strip()
            cid = name_to_id.get(_norm(desired))
            if cid:
                return cid
        # final attempt: exact SC- name already
        if vn.startswith(_norm(f"SC-{access_group}")):
            return name_to_id.get(vn)
        return None

    # -------- read assignment list --------
    try:
        resp = session.get(list_url)
        resp.raise_for_status()
        assigned = resp.json().get("ratePolicies", [])
    except Exception as e:
        summary["failed"] += 1
        summary["details"].append({"stage": "fetch_dos_assignments", "error": str(e)})
        return summary

    updated_assignments = []

    for p in assigned:
        summary["processed"] += 1
        orig_name = p.get("name", "")
        orig_id   = p.get("id")

        kept_id = orig_id
        kept_name = orig_name

        # -------- clone template-named policies to SC-<access_group> <suffix> --------
        if orig_name.startswith(template_policy_name_prefix):
            suffix = orig_name.replace(template_policy_name_prefix, "").strip()
            clone_name = f"SC-{access_group} {suffix}".strip()
            # reuse existing clone if present among all policies returned
            existing = next((x for x in assigned if x.get("name") == clone_name), None)
            if existing:
                kept_id = existing.get("id")
                kept_name = clone_name
            else:
                try:
                    payload = {
                        "cloneFromRatePolicyId": orig_id,
                        "name": clone_name,
                        "description": f"Cloned from {orig_name}",
                        "matchType": p.get("matchType"),
                    }
                    c = session.post(clone_url, json=payload)
                    c.raise_for_status()
                    kept_id = c.json().get("id")
                    kept_name = clone_name

                    if activate_clones and kept_id:
                        try:
                            session.post(policy_url.format(policy_id=kept_id) + "/activate",
                                         json={"network": "STAGING"})
                        except Exception:
                            pass  # best-effort
                    summary["successful"] += 1
                    summary["details"].append({"template": orig_name, "clone": kept_name, "status": "cloned"})
                except Exception as clone_err:
                    # fallback to original
                    kept_id = orig_id
                    kept_name = orig_name
                    summary["failed"] += 1
                    summary["details"].append(
                        {"template": orig_name, "status": "clone_failed", "error": str(clone_err)}
                    )

        # -------- fetch full policy & rewrite NetworkListCondition values --------
        try:
            d = session.get(policy_url.format(policy_id=kept_id))
            d.raise_for_status()
            full = d.json()

            # optional scope: only touch policies tied to a specific security policy
            if target_policy_id and full.get("policyId") != target_policy_id:
                updated_assignments.append(kept_id)
                continue

            changed = False

            for opt in full.get("additionalMatchOptions", []) or []:
                if opt.get("type") != "NetworkListCondition":
                    continue

                new_vals = []
                for v in opt.get("values", []) or []:
                    v_str = str(v)
                    # try to resolve to SC- clone id if this value is a template id/name
                    repl = _resolve_clone_id(v_str)
                    if repl:
                        new_vals.append(repl)
                        if repl != v_str:
                            changed = True
                    else:
                        # leave as-is (already correct or unknown)
                        new_vals.append(v)

                # Only apply if any value changed
                if changed:
                    opt["values"] = new_vals

            # scrub read-only fields before PUT
            for ro in ("id", "updateDate", "used", "createDate"):
                if ro in full:
                    full.pop(ro, None)

            if changed:
                u = session.put(policy_url.format(policy_id=kept_id), json=full)
                u.raise_for_status()
                summary["fixed_conditions"] += 1
                summary["details"].append(
                    {"id": kept_id, "name": kept_name, "status": "networklist_rewritten"}
                )

            updated_assignments.append(kept_id)

        except Exception as fix_err:
            summary["failed"] += 1
            summary["details"].append(
                {"id": kept_id, "name": kept_name, "status": "update_failed", "error": str(fix_err)}
            )
            # still keep it in the assignment list to avoid breaking the config
            updated_assignments.append(kept_id)

    # -------- write back assignment list --------
    try:
        put_resp = session.put(list_url, json={"ratePolicies": updated_assignments})
        put_resp.raise_for_status()
    except Exception as assign_err:
        summary["failed"] += 1
        summary["details"].append({"stage": "assign_writeback_failed", "error": str(assign_err)})

    return summary
