assignments_str = [f"{p.get('name')}({p.get('id')})" for p in assigned]
_debug(f"DOS assignments on config {config_id} v{version}: {assignments_str}")


def reassign_dos_protection_rate_policies(
    session,
    base_url,
    config_id,
    version,
    access_group,
    template_policy_name_prefix="Security Policy Template",
):
    """
    For every DoS rate policy attached to this config/version:
      1) If the policy name starts with the template prefix, clone it to 'SC-<access_group> <suffix>'.
         Otherwise keep the existing policy as-is.
      2) In the kept/cloned policy, rewrite additionalMatchOptions of type 'NetworkListCondition'
         so that any template list names are replaced with the corresponding
         'SC-<access_group> Rate Controls Bypass List' (by ID).
      3) PUT the updated policy and then replace the config's dos-rates assignment list.

    Returns a summary dict and prints DEBUG lines.
    """

    if not access_group:
        raise ValueError("reassign_dos_protection_rate_policies: 'access_group' is required")

    list_url = f"{base_url}/appsec/v1/configs/{config_id}/versions/{version}/dos-rates"
    clone_url = f"{base_url}/appsec/v1/rate-policies/clone"
    policy_url_template = f"{base_url}/appsec/v1/rate-policies/{{policy_id}}"

    # ---- helpers -------------------------------------------------------------

    def _debug(msg):
        print(f"[DEBUG] {msg}")

    def _is_id_like(s: str) -> bool:
        s = str(s)
        return s.isdigit()

    def _target_client_list_name_for(access_group: str) -> str:
        # Your standard naming
        return f"SC-{access_group} Rate Controls Bypass List"

    def _resolve_client_list_id_by_name(name_fragment: str) -> str | None:
        """
        Try to resolve a client list ID by a (partial) name.
        Uses your existing helper if present; otherwise does a lightweight API search.
        Expected to return the first matching listId or None.
        """
        # Prefer an existing project helper if available
        try:
            helper = globals().get("search_client_lists_by_name") or globals().get("search_client_lists")
            if helper:
                matches = helper(session, base_url, name_fragment)
                # helper in your code tends to return list of tuples (listId, name)
                if matches:
                    return str(matches[0][0])
        except Exception:
            pass

        # Fallback: quick API search
        try:
            q = name_fragment.strip()
            nl_url = f"{base_url}/appsec/v1/network-lists?search={requests.utils.quote(q)}"
            r = session.get(nl_url)
            r.raise_for_status()
            data = r.json() or {}
            items = data.get("networkLists", []) or data.get("data", [])
            for it in items:
                nm = it.get("name", "")
                if q.lower() in nm.lower():
                    return str(it.get("listId") or it.get("id"))
        except Exception as e:
            _debug(f"Client-list search fallback failed for '{name_fragment}': {e}")

        return None

    # -------------------------------------------------------------------------

    summary = {
        "processed": 0,
        "successful": 0,
        "failed": 0,
        "fixed_conditions": 0,
        "details": [],
    }

    try:
        # 1) Read the current assignment list (policies attached to this config/version)
        resp = session.get(list_url)
        resp.raise_for_status()
        assigned = resp.json().get("ratePolicies", [])

        _debug(f"DOS assignments on config {config_id} v{version}: "
               f"{[f'{p.get('name')}({p.get('id')})' for p in assigned]}")

        updated_assignments: list[str] = []

        for p in assigned:
            summary["processed"] += 1
            orig_name = p.get("name", "")
            orig_id = p.get("id")

            kept_id = orig_id
            kept_name = orig_name

            # Clone if it looks like a template policy
            if orig_name.startswith(template_policy_name_prefix):
                suffix = orig_name.replace(template_policy_name_prefix, "").strip()
                clone_name = f"SC-{access_group} {suffix}".strip()

                _debug(f"Template DOS policy detected: '{orig_name}' -> cloning as '{clone_name}'")

                try:
                    clone_payload = {
                        "cloneFromRatePolicyId": orig_id,
                        "name": clone_name,
                        "description": f"Cloned from {orig_name}",
                        "matchType": p.get("matchType"),
                    }
                    c = session.post(clone_url, json=clone_payload)
                    if c.status_code == 409:
                        # Name already exists; try to find by name (best-effort)
                        _debug(f"Clone name '{clone_name}' already exists; using original for now.")
                        kept_id = orig_id
                        kept_name = orig_name
                    else:
                        c.raise_for_status()
                        kept_id = c.json().get("id")
                        kept_name = clone_name
                        _debug(f"Cloned DOS policy ID -> {kept_id}")
                        summary["successful"] += 1
                        summary["details"].append({"template": orig_name, "clone": kept_name, "status": "success"})
                except Exception as e:
                    _debug(f"Clone failed for '{orig_name}': {e}. Keeping original.")
                    kept_id = orig_id
                    kept_name = orig_name
                    summary["failed"] += 1
                    summary["details"].append({"template": orig_name, "status": "clone_failed", "error": str(e)})

            # 2) Fetch the kept policy (cloned or original) and fix NetworkListCondition
            try:
                d = session.get(policy_url_template.format(policy_id=kept_id))
                d.raise_for_status()
                full = d.json()

                # Walk additionalMatchOptions
                changed = False
                amo = full.get("additionalMatchOptions", [])
                for opt in amo:
                    if str(opt.get("type")) != "NetworkListCondition":
                        continue

                    old_vals = opt.get("values", [])
                    new_vals = []

                    for v in old_vals:
                        v_str = str(v)
                        if _is_id_like(v_str):
                            new_vals.append(v)  # already an ID
                            continue

                        # Determine the desired list name to use
                        target_name = _target_client_list_name_for(access_group)

                        # If the current value looks like a template name, we definitely switch;
                        # if it just contains "Rate Controls Bypass List", still switch to SC- list.
                        looks_templatey = ("Security Policy Template" in v_str) or ("Rate Controls Bypass List" in v_str)
                        if looks_templatey:
                            resolved_id = _resolve_client_list_id_by_name(target_name)
                            if resolved_id:
                                _debug(f"   - Replacing list '{v_str}' -> '{target_name}' (id {resolved_id}) "
                                       f"in DOS policy '{kept_name}'")
                                new_vals.append(resolved_id)
                                changed = True
                            else:
                                _debug(f"   - Could not resolve ID for '{target_name}'. Keeping original '{v_str}'.")
                                new_vals.append(v)
                        else:
                            new_vals.append(v)

                    opt["values"] = new_vals

                if changed:
                    # scrub read-only fields before PUT
                    for ro in ("id", "updateDate", "used", "createDate", "createdBy"):
                        full.pop(ro, None)

                    u = session.put(policy_url_template.format(policy_id=kept_id), json=full)
                    u.raise_for_status()
                    summary["fixed_conditions"] += 1
                    _debug(f"Updated DOS policy '{kept_name}' ({kept_id}) with new client list ids.")
                else:
                    _debug(f"No NetworkListCondition changes needed for DOS policy '{kept_name}' ({kept_id}).")

                updated_assignments.append(kept_id)

            except Exception as fix_err:
                _debug(f"Failed to update DOS policy '{kept_name}' ({kept_id}): {fix_err}")
                summary["failed"] += 1
                summary["details"].append(
                    {"id": kept_id, "name": kept_name, "status": "update_failed", "error": str(fix_err)}
                )
                # Still keep it in the list so we don't break the config
                updated_assignments.append(kept_id)

        # 3) Replace the assignment list
        try:
            put_resp = session.put(list_url, json={"ratePolicies": updated_assignments})
            put_resp.raise_for_status()
            _debug(f"Replaced DOS assignments on config {config_id} v{version}: {updated_assignments}")
        except Exception as assign_err:
            _debug(f"Failed to PUT new DOS assignments: {assign_err}")
            summary["failed"] += 1
            summary["details"].append({"status": "assign_failed", "error": str(assign_err)})

    except Exception as e:
        _debug(f"Top-level DOS reassignment error: {e}")
        summary["failed"] += 1
        summary["details"].append({"status": "failed", "error": str(e)})

    return summary
