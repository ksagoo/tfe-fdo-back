def reassign_dos_protection_rate_policies(
    session,
    base_url,
    config_id,
    version,
    access_group,
    template_policy_name_prefix="Security Policy Template",
    template_bypass_name="Security Policy Template Rate Controls Bypass List",
    sc_bypass_suffix="Rate Controls Bypass List",
    activate_clones=True,
    target_policy_id=None,  # optional: only touch rate policies that belong to a specific security policy id
):
    """
    Debug version: verbose logging around each network call and transformation.
    """

    list_url = f"{base_url}/appsec/v1/configs/{config_id}/versions/{version}/dos-rates"
    clone_url = f"{base_url}/appsec/v1/rate-policies/clone"
    policy_url = lambda pid: f"{base_url}/appsec/v1/rate-policies/{pid}"
    lists_url = f"{base_url}/appsec/v1/client-list/definitions"

    def _get_all_client_lists():
        print(f"[DBG] GET client lists: {lists_url}")
        try:
            r = session.get(lists_url, params={})
            print(f"[DBG] -> status {r.status_code}")
            r.raise_for_status()
            data = r.json()
            items = data.get("clientLists", []) or data.get("items", []) or []
            by_name = {}
            by_id = {}
            for it in items:
                lid = str(it.get("id") or it.get("listId") or "").strip()
                nm = (it.get("name") or "").strip()
                if lid:
                    by_id[lid] = nm
                if nm:
                    by_name[nm.lower()] = lid
            print(f"[DBG] Client lists found: {len(items)}")
            # small sample for sanity
            for i, (lid, nm) in enumerate(by_id.items()):
                if i >= 3: break
                print(f"[DBG]   list sample: id={lid} name={nm}")
            return by_name, by_id
        except Exception as e:
            print(f"[WARN] Could not fetch client lists: {e}")
            return {}, {}

    def _resolve_bypass_ids():
        by_name, by_id = _get_all_client_lists()
        template_id = by_name.get(template_bypass_name.lower())
        sc_name = f"SC-{access_group} {sc_bypass_suffix}".strip()
        sc_id = by_name.get(sc_name.lower())
        print(f"[DBG] Template bypass name -> id: '{template_bypass_name}' -> {template_id}")
        print(f"[DBG] SC bypass name       -> id: '{sc_name}' -> {sc_id}")
        return template_id, sc_id, sc_name

    summary = {"processed": 0, "successful": 0, "failed": 0, "fixed_conditions": 0, "details": []}

    try:
        # read rate policies assigned to this config/version
        print(f"[DBG] GET assigned DoS policies: {list_url}")
        resp = session.get(list_url)
        print(f"[DBG] -> status {resp.status_code}")
        resp.raise_for_status()
        assigned = resp.json().get("ratePolicies", []) or []
        print(f"[DBG] Assigned DoS policies count: {len(assigned)}")
        for rp in assigned:
            print(f"[DBG]   assigned: id={rp.get('id')} name='{rp.get('name')}'")

        if not assigned:
            print("[INFO] No DoS rate policies assigned to this config/version.")
            return summary

        template_list_id, sc_list_id, sc_list_name = _resolve_bypass_ids()
        if not sc_list_id:
            print(f"[WARN] SC bypass list not found by name: '{sc_list_name}'. Create it first, then re-run.")
        if not template_list_id:
            print(f"[WARN] Template bypass list id not found for name '{template_bypass_name}'. "
                  f"Will still try name-based replacement.")

        new_assignment_ids = []

        for rp in assigned:
            summary["processed"] += 1
            orig_id = rp.get("id")
            orig_name = rp.get("name") or ""
            kept_id = orig_id
            kept_name = orig_name

            # 1) clone away from template-named policies (once)
            if orig_name.startswith(template_policy_name_prefix):
                suffix = orig_name.replace(template_policy_name_prefix, "", 1).strip()
                clone_name = f"SC-{access_group} {suffix}".strip()
                print(f"[DBG] Template-named policy detected -> will use clone name '{clone_name}'")

                existing = next((p for p in assigned if (p.get("name") or "").strip() == clone_name), None)
                if existing:
                    kept_id = existing.get("id")
                    kept_name = clone_name
                    print(f"[DBG] Reusing existing clone: id={kept_id} name='{kept_name}'")
                else:
                    try:
                        payload = {
                            "cloneFromRatePolicyId": orig_id,
                            "name": clone_name,
                            "description": f"Cloned from {orig_name}",
                            "matchType": rp.get("matchType"),
                        }
                        print(f"[DBG] POST clone: {clone_url}")
                        print(f"[DBG] Payload: {payload}")
                        c = session.post(clone_url, json=payload)
                        print(f"[DBG] -> status {c.status_code}")
                        c.raise_for_status()
                        kept_id = c.json().get("id")
                        kept_name = clone_name
                        if activate_clones and kept_id:
                            act_url = policy_url(kept_id) + "/activate"
                            print(f"[DBG] POST activate clone (staging): {act_url}")
                            a = session.post(act_url, json={"network": "STAGING"})
                            print(f"[DBG] -> status {a.status_code}")
                        summary["successful"] += 1
                        summary["details"].append({"template": orig_name, "clone": kept_name, "status": "success"})
                        print(f"[DOS] Cloned '{orig_name}' -> '{kept_name}' (id {kept_id})")
                    except Exception as ce:
                        kept_id = orig_id
                        kept_name = orig_name
                        summary["failed"] += 1
                        summary["details"].append({"template": orig_name, "status": "clone_failed", "error": str(ce)})
                        print(f"[WARN] Clone failed for '{orig_name}': {ce}")

            # 2) load full policy, optionally filter by security policy id
            try:
                p_url = policy_url(kept_id)
                print(f"[DBG] GET rate-policy detail: {p_url}")
                p = session.get(p_url)
                print(f"[DBG] -> status {p.status_code}")
                p.raise_for_status()
                full = p.json()

                if target_policy_id:
                    print(f"[DBG] target_policy_id filter: want={target_policy_id}, policyId={full.get('policyId')}")
                    if str(full.get("policyId")) != str(target_policy_id):
                        new_assignment_ids.append(kept_id)
                        continue

                changed = False
                # dump current match options for visibility
                print(f"[DBG] Current additionalMatchOptions for '{kept_name}':")
                for opt in full.get("additionalMatchOptions", []) or []:
                    print(f"[DBG]   type={opt.get('type')} values={opt.get('values')}")

                for opt in full.get("additionalMatchOptions", []) or []:
                    if (opt.get("type") or "").strip() != "NetworkListCondition":
                        continue

                    vals = opt.get("values", []) or []
                    new_vals = []
                    for v in vals:
                        v_str = str(v).strip()

                        # Id-based replacement first
                        if template_list_id and v_str == str(template_list_id) and sc_list_id:
                            new_vals.append(sc_list_id)
                            changed = True
                            continue

                        # Name-based (tenants sometimes return names)
                        if v_str.lower() == template_bypass_name.lower():
                            new_vals.append(sc_list_id if sc_list_id else v)
                            changed = True
                            continue

                        # Already SC id?
                        if sc_list_id and v_str == str(sc_list_id):
                            new_vals.append(v)
                            continue

                        new_vals.append(v)

                    if new_vals != vals:
                        print(f"[DBG] NetworkListCondition change for '{kept_name}': {vals} -> {new_vals}")
                        opt["values"] = new_vals

                if changed:
                    # scrub read-only fields
                    for ro in ("id", "updateDate", "used", "etag"):
                        if ro in full:
                            print(f"[DBG] Stripping read-only field: {ro}")
                            full.pop(ro, None)

                    print(f"[DBG] PUT rate-policy update: {p_url}")
                    # small, readable preview of the changed portion
                    try:
                        changed_opts = [o for o in full.get("additionalMatchOptions", []) or []
                                        if (o.get("type") or "") == "NetworkListCondition"]
                        print(f"[DBG] Payload (NetworkListCondition): {changed_opts}")
                    except Exception:
                        pass

                    u = session.put(p_url, json=full)
                    print(f"[DBG] -> status {u.status_code}")
                    u.raise_for_status()
                    summary["fixed_conditions"] += 1
                    print(f"[DOS] Updated policy '{kept_name}' ({kept_id}) with SC client list id '{sc_list_id}'.")
                else:
                    print(f"[DBG] No change needed for '{kept_name}'.")

                new_assignment_ids.append(kept_id)

            except Exception as ue:
                summary["failed"] += 1
                summary["details"].append({"id": kept_id, "name": kept_name, "status": "update_failed", "error": str(ue)})
                print(f"[ERROR] Failed to update DoS policy '{kept_name}' ({kept_id}): {ue}")
                new_assignment_ids.append(kept_id)

        # 3) write assignment list back (even if nothing changed)
        try:
            print(f"[DBG] PUT dos-rates assignment: {list_url}")
            print(f"[DBG] Payload: {{'ratePolicies': {new_assignment_ids}}}")
            put = session.put(list_url, json={"ratePolicies": new_assignment_ids})
            print(f"[DBG] -> status {put.status_code}")
            put.raise_for_status()
        except Exception as ae:
            summary["failed"] += 1
            summary["details"].append({"status": "assign_failed", "error": str(ae)})
            print(f"[WARN] Could not update dos-rates assignment list: {ae}")

    except Exception as e:
        summary["failed"] += 1
        summary["details"].append({"status": "failed", "error": str(e)})
        print(f"[ERROR] reassign_dos_protection_rate_policies: {e}")

    return summary
