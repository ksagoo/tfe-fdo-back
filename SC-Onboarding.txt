# --- DoS / Rate Policies reassignment with config->policy fallback -----------------
def reassign_dos_protection_rate_policies(
    session: requests.Session,
    base_url: str,
    config_id: str | int,
    version: str | int,
    access_group: str,
    template_policy_name_prefix: str = "Security Policy Template",
    target_policy_id: Optional[str] = None,   # only touch policies attached to this security policy (optional)
    activate_clones: bool = True,             # keep staging activation behaviour
) -> Dict[str, Any]:
    """
    Reassign/clean DoS rate-limiting policies for a security config version.

    Behaviour:
      1) Discover rate policies:
           - Try legacy config-level: /configs/{id}/versions/{v}/dos-rates
           - If 404, fall back to policy-level: /policies/{policyId}/rate-policies
      2) For each attached rate policy:
           - If its name starts with the template prefix, clone it to
             'SC-{access_group} <suffix>' (or reuse existing clone).
           - On the kept/cloned policy, fix additionalMatchOptions/NetworkListCondition
             values so ANY client-list name becomes the correct client-list **ID**
             (resolving to the 'SC-{access_group} …' list when a template-ish name is seen).
      3) PUT the cleaned policy back.
      4) If we used the legacy config-level mode, replace the assignments with the kept/cloned ids.

    Returns a small summary dict and prints helpful DBG lines.
    """

    # ---------------- helpers ----------------

    def _debug(msg: str): print(f"[DBG] {msg}")

    def _norm(s: Optional[str]) -> str:
        return (s or "").strip()

    def _list_rate_policies_with_fallback(sess) -> Tuple[List[Dict[str, Any]], Dict[str, str]]:
        """Return (rate_policies, meta). meta['mode'] is 'config' or 'policy'."""
        cfg_url = f"{base_url}/appsec/v1/configs/{config_id}/versions/{version}/dos-rates"
        r = sess.get(cfg_url)
        if r.status_code == 200:
            data = r.json().get("ratePolicies", [])
            _debug(f"discovered {len(data)} rate policies via CONFIG endpoint")
            return data, {"mode": "config", "source": cfg_url}
        if r.status_code not in (404,):
            # real error; surface it
            try:
                r.raise_for_status()
            finally:
                _debug(f"config-level dos-rates failed: {r.status_code} {r.text[:260]}")

        # fallback to policy-scoped
        index_url = f"{base_url}/appsec/v1/configs/{config_id}/versions/{version}/policies"
        ir = sess.get(index_url)
        ir.raise_for_status()
        policies = ir.json().get("policies", [])
        collected: List[Dict[str, Any]] = []
        for p in policies:
            pid = p.get("policyId") or p.get("id")
            if not pid:
                continue
            rp_url = f"{base_url}/appsec/v1/policies/{pid}/rate-policies"
            rr = sess.get(rp_url)
            if rr.status_code == 200:
                arr = rr.json().get("ratePolicies", [])
                for item in arr:
                    item["_ownerPolicyId"] = pid   # remember owner for clarity
                collected.extend(arr)
            elif rr.status_code == 404:
                continue
            else:
                # surface non-404 errors
                try:
                    rr.raise_for_status()
                finally:
                    _debug(f"policy-level list failed for policy {pid}: "
                          f"{rr.status_code} {rr.text[:260]}")
        _debug(f"discovered {len(collected)} rate policies via POLICY endpoints")
        return collected, {"mode": "policy", "source": index_url}

    def _get_rate_policy(sess, policy_id: str) -> Dict[str, Any]:
        url = f"{base_url}/appsec/v1/rate-policies/{policy_id}"
        r = sess.get(url)
        r.raise_for_status()
        return r.json()

    def _put_rate_policy(sess, policy_id: str, body: Dict[str, Any]) -> None:
        url = f"{base_url}/appsec/v1/rate-policies/{policy_id}"
        r = sess.put(url, json=body)
        r.raise_for_status()

    def _clone_rate_policy(sess, from_id: str, name: str, desc: str, match_type: Optional[str]) -> Optional[str]:
        payload = {
            "cloneFromRatePolicyId": from_id,
            "name": name,
            "description": desc,
        }
        if match_type:  # older APIs need this
            payload["matchType"] = match_type
        r = sess.post(f"{base_url}/appsec/v1/rate-policies/clone", json=payload)
        r.raise_for_status()
        return r.json().get("id")

    def _activate_staging(sess, policy_id: str) -> None:
        try:
            url = f"{base_url}/appsec/v1/rate-policies/{policy_id}/activate"
            sess.post(url, json={"network": "STAGING"})
        except Exception as e:
            _debug(f"staging activation best-effort failed for {policy_id}: {e}")

    def _search_client_lists_by_name(sess, fragment: str) -> List[Tuple[str,str]]:
        """
        Return list of (listId, listName) whose names contain the fragment (case-insensitive).
        Uses the search param if available; otherwise fetches the first page.
        """
        fragment = _norm(fragment).lower()
        out: List[Tuple[str,str]] = []
        url = f"{base_url}/appsec/v1/client-lists"
        try:
            r = sess.get(url, params={"search": fragment} if fragment else None)
            r.raise_for_status()
            data = r.json().get("lists", r.json().get("clientLists", []))
            for item in data:
                lid = str(item.get("listId") or item.get("id") or "")
                name = _norm(item.get("name") or item.get("listName") or "")
                if not lid or not name:
                    continue
                if not fragment or fragment in name.lower():
                    out.append((lid, name))
        except Exception as e:
            _debug(f"client-lists search failed: {e}")
        return out

    def _resolve_client_list_id_from_value(val: str) -> Optional[str]:
        """
        If 'val' looks numeric, return as-is (already an id).
        Otherwise treat it as a name and try to resolve the SC-{access_group} version:
          - If the name includes the template prefix, derive suffix and build SC- name
          - Else, try direct match to SC- name if it already starts with SC-
          - Else, try best-effort search by the provided name
        """
        s = _norm(val)
        if s.isdigit():
            return s  # already an id

        expected_name = s
        if template_policy_name_prefix.lower() in s.lower():
            suffix = s.lower().split(template_policy_name_prefix.lower(), 1)[-1].strip()
            expected_name = f"SC-{access_group} {suffix}".strip()
        elif not s.startswith("SC-"):
            # Most teams use 'Rate Controls Bypass List' etc. under SC- prefix
            expected_name = f"SC-{access_group} {s}".strip()

        # First, try expected_name
        matches = _search_client_lists_by_name(session, expected_name)
        if matches:
            # prefer exact (case-insensitive) match, else first
            for lid, nm in matches:
                if nm.lower() == expected_name.lower():
                    return lid
            return matches[0][0]

        # fallback: try the raw input name
        matches = _search_client_lists_by_name(session, s)
        if matches:
            return matches[0][0]

        _debug(f"no client-list id resolved for value '{val}'")
        return None

    # ---------------- main flow ----------------

    summary: Dict[str, Any] = {"processed": 0, "successful": 0, "failed": 0, "fixed_conditions": 0, "details": []}

    # 1) discover rate policies
    try:
        assigned, meta = _list_rate_policies_with_fallback(session)
    except Exception as e:
        _debug(f"discovery failed: {e}")
        return summary

    if not assigned:
        print("[INFO] No rate policies discovered; skipping DoS reassignment.")
        return summary

    # In config mode we’ll rebuild the assignment list
    updated_assignment_ids: List[str] = []
    in_config_mode = (meta.get("mode") == "config")

    # Keep list of names in the discovered set (for quick reuse checks)
    discovered_names = {p.get("name"): p.get("id") for p in assigned if p.get("id")}

    for rp in assigned:
        summary["processed"] += 1
        orig_id = rp.get("id")
        orig_name = _norm(rp.get("name") or "")
        kept_id = orig_id
        kept_name = orig_name

        # clone if this looks like a template policy
        if orig_name.startswith(template_policy_name_prefix):
            suffix = orig_name.replace(template_policy_name_prefix, "", 1).strip()
            clone_name = f"SC-{access_group} {suffix}".strip()

            # reuse if this clone already exists in the discovered set
            if clone_name in discovered_names:
                kept_id = discovered_names[clone_name]
                kept_name = clone_name
                _debug(f"reusing existing cloned rate policy: '{clone_name}' ({kept_id})")
            else:
                try:
                    kept_id = _clone_rate_policy(session, orig_id, clone_name, f"Cloned from {orig_name}", rp.get("matchType"))
                    kept_name = clone_name
                    if kept_id and activate_clones:
                        _activate_staging(session, kept_id)
                    summary["successful"] += 1
                    summary["details"].append({"template": orig_name, "clone": kept_name, "status": "cloned"})
                    _debug(f"cloned rate policy '{orig_name}' -> '{kept_name}' ({kept_id})")
                except Exception as ce:
                    kept_id = orig_id
                    kept_name = orig_name
                    summary["failed"] += 1
                    summary["details"].append({"template": orig_name, "status": "clone_failed", "error": str(ce)})
                    _debug(f"clone failed for '{orig_name}': {ce}")

        # 2) fix the kept policy’s NetworkListCondition values (names -> IDs)
        try:
            full = _get_rate_policy(session, kept_id)

            # optional: only touch policies attached to a specific security policy
            if target_policy_id and (full.get("policyId") != target_policy_id):
                if in_config_mode:
                    updated_assignment_ids.append(kept_id)
                continue

            changed = False
            for opt in full.get("additionalMatchOptions", []) or []:
                if opt.get("type") != "NetworkListCondition":
                    continue
                values = opt.get("values") or []
                new_vals: List[str] = []
                for v in values:
                    v_str = str(v)
                    resolved = _resolve_client_list_id_from_value(v_str)
                    if resolved and resolved != v_str:
                        changed = True
                        new_vals.append(resolved)
                    else:
                        new_vals.append(v_str)
                opt["values"] = new_vals

                # small readable preview
                try:
                    _debug(f"payload (NetworkListCondition) for '{kept_name}': {new_vals}")
                except Exception:
                    pass

            # scrub read-only fields before PUT
            for ro in ("id", "updateDate", "used", "createDate", "createdBy"):
                if ro in full:
                    full.pop(ro, None)

            if changed:
                _put_rate_policy(session, kept_id, full)
                summary["fixed_conditions"] += 1
                _debug(f"updated DoS policy '{kept_name}' ({kept_id}) with client-list IDs.")
            summary["successful"] += 1
            if in_config_mode:
                updated_assignment_ids.append(kept_id)

        except Exception as ue:
            summary["failed"] += 1
            summary["details"].append({"id": kept_id, "name": kept_name, "status": "update_failed", "error": str(ue)})
            _debug(f"update failed for '{kept_name}' ({kept_id}): {ue}")
            if in_config_mode:
                updated_assignment_ids.append(kept_id)

    # 3) replace assignment list only if we were in config-mode
    if in_config_mode:
        try:
            list_url = f"{base_url}/appsec/v1/configs/{config_id}/versions/{version}/dos-rates"
            put_body = {"ratePolicies": updated_assignment_ids}
            pr = session.put(list_url, json=put_body)
            pr.raise_for_status()
            _debug(f"updated config-level dos-rates assignment with {len(updated_assignment_ids)} ids")
        except Exception as ae:
            summary["failed"] += 1
            summary["details"].append({"status": "assign_failed", "error": str(ae)})
            _debug(f"assignment PUT failed: {ae}")

    return summary
