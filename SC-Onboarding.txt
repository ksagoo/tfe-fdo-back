def activate_client_list_and_wait(session, base_url, list_id, network="STAGING", timeout=120, interval=10):
    """
    Activates a client list and polls until it reaches ACTIVE status.
    Returns True if activation succeeds, False otherwise.
    """
    activate_url = urljoin(base_url, f"/client-list/v1/lists/{list_id}/activate")
    status_url = urljoin(base_url, f"/client-list/v1/lists/{list_id}")
    headers = {"accept": "application/json", "content-type": "application/json"}

    try:
        # Step 1: Trigger activation
        response = session.put(activate_url, json={"network": network}, headers=headers)
        response.raise_for_status()
        print(f"[INFO] Activation triggered for client list {list_id} on {network}")
    except Exception as e:
        print(f"[ERROR] Failed to activate client list {list_id}: {e}")
        return False

    # Step 2: Poll for ACTIVE status
    start = time.time()
    while time.time() - start < timeout:
        try:
            status_resp = session.get(status_url, headers=headers)
            status_resp.raise_for_status()
            status = status_resp.json().get("status", "").upper()
            if status == "ACTIVE":
                print(f"[INFO] Client list {list_id} is now ACTIVE")
                return True
            else:
                print(f"[WAIT] Client list {list_id} status: {status} — retrying in {interval}s")
        except Exception as e:
            print(f"[WARN] Failed to fetch client list status: {e}")
        time.sleep(interval)

    print(f"[ERROR] Timeout waiting for client list {list_id} to become ACTIVE")
    return False







# Process only Security Policy Template lists
for cl in client_lists:
    original_name = cl.get("name", "")

    # Skip non-template lists
    if "Security Policy Template" not in original_name:
        continue

    # Skip already cloned lists
    if original_name.startswith("SC-"):
        continue

    # Skip ASN Block Lists
    if "ASN Block List" in original_name:
        print(f"[INFO] Skipping ASN Block List: {original_name}")
        continue

import requests
import json
from typing import Dict, List, Union, Any, Optional

def reassign_dos_protection_rate_policies(
    session: requests.Session,
    base_url: str,
    config_id: Union[str, int],
    version: Union[str, int],
    access_group: str,
    list_name_fragment: Optional[str] = None,
) -> Dict[str, Union[int, List[Dict[str, str]]]]:
    summary = {"successful": 0, "failed": 0, "details": []}
    fragment = (list_name_fragment or f"SC-{access_group} Rate Controls Bypass List").strip()

    def _collect_list_candidates(obj: Any) -> List[Dict[str, Any]]:
        candidates = []
        def walk(node):
            if isinstance(node, dict):
                if "name" in node and any(k in node for k in ("listId", "id", "uniqueId")):
                    candidates.append(node)
                for v in node.values():
                    walk(v)
            elif isinstance(node, list):
                for item in node:
                    walk(item)
        walk(obj)
        return candidates

    # Step 1: Resolve client list
    client_list_id = None
    client_list_name = None
    try:
        resp = session.get(f"{base_url}/client-list/v1/lists", params={"includeInactive": "true"})
        resp.raise_for_status()
        candidates = _collect_list_candidates(resp.json())
        frag_lower = fragment.lower()
        for it in candidates:
            name = (it.get("name") or "").strip()
            if name and frag_lower in name.lower():
                client_list_id = str(it.get("listId") or it.get("id") or it.get("uniqueId"))
                client_list_name = name
                break
    except Exception as e:
        print(f"[ERROR] Failed to fetch client lists: {e}")
        return summary

    if not client_list_id:
        print(f"[ERROR] No matching Client List found for fragment '{fragment}'")
        return summary

    print(f"[INFO] Using list '{client_list_name}' (ID: {client_list_id})")

    # Step 2: Fetch rate policies
    rate_url = f"{base_url}/appsec/v1/configs/{config_id}/versions/{version}/rate-policies"
    try:
        r = session.get(rate_url)
        r.raise_for_status()
        policies = r.json().get("ratePolicies", [])
    except Exception as e:
        print(f"[ERROR] Failed to fetch rate policies: {e}")
        return summary

    def get_policy_id(p: dict) -> str:
        return str(p.get("id") or p.get("policyId") or p.get("uuid") or p.get("uniqueId") or "")

    # Step 3: Update each policy
    for policy in policies:
        policy_id = get_policy_id(policy)
        policy_name = policy.get("name") or "Unnamed Policy"
        rp_url = f"{base_url}/appsec/v1/configs/{config_id}/versions/{version}/rate-policies/{policy_id}"
        print(f"\n[INFO] Updating policy '{policy_name}' (id={policy_id})")

        try:
            rp_resp = session.get(rp_url)
            rp_resp.raise_for_status()
            full_doc = rp_resp.json()

            # Step 3a: Patch client list reference inside additionalMatchOptions
            found = False
            match_options = full_doc.get("additionalMatchOptions", [])
            for cond in match_options:
                cond_type = cond.get("type", "").lower()
                if "network" in cond_type and isinstance(cond.get("values"), list):
                    cond["values"] = [client_list_id]
                    found = True

            if not found:
                print(f"[WARN] No network condition found in '{policy_name}' — skipping update")
                summary["details"].append({"policy": policy_name, "status": "skipped", "reason": "no client list condition"})
                continue

            # Step 3b: Reuse full JSON as payload
            payload = full_doc

            print(f"[DBG] PUT URL: {rp_url}")
            print("[DBG] Updated Payload:")
            print(json.dumps(payload, indent=2))

            put_resp = session.put(rp_url, json=payload)
            put_resp.raise_for_status()
            summary["successful"] += 1
            summary["details"].append({"policy": policy_name, "status": "updated"})
            print(f"[INFO] Updated '{policy_name}' with new client list")

            # Step 4: Verify update
            verify_resp = session.get(rp_url)
            verify_resp.raise_for_status()
            verify_doc = verify_resp.json()
            print(f"[VERIFY] Full rate policy JSON for '{policy_name}':")
            print(json.dumps(verify_doc, indent=2))

        except Exception as e:
            print(f"[ERROR] Failed updating '{policy_name}': {e}")
            summary["failed"] += 1
            summary["details"].append({"policy": policy_name, "status": "failed", "error": str(e)})

    print(f"\n[INFO] Done. Success: {summary['successful']}, Failed: {summary['failed']}")
    return summary




@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
def reassign_dos_rate_policies_gui_visible(
    session: requests.Session,
    base_url: str,
    config_id: Union[str, int],
    version: Union[str, int],
    access_group: str,
    list_name_fragment: Optional[str] = None,
) -> Dict[str, Union[int, List[Dict[str, str]]]]:
    summary = {"successful": 0, "failed": 0, "details": []}
    fragment = (list_name_fragment or f"SC-{access_group} Rate Controls Bypass List").strip()

    def _collect_list_candidates(obj: Any) -> List[Dict[str, Any]]:
        candidates = []
        def walk(node):
            if isinstance(node, dict):
                if "name" in node and any(k in node for k in ("listId", "id", "uniqueId")):
                    candidates.append(node)
                for v in node.values():
                    walk(v)
            elif isinstance(node, list):
                for item in node:
                    walk(item)
        walk(obj)
        return candidates

    # Step 1: Resolve client list
    client_list_id = None
    try:
        resp = session.get(f"{base_url}/client-list/v1/lists", params={"includeInactive": "true"})
        resp.raise_for_status()
        candidates = _collect_list_candidates(resp.json())
        for it in candidates:
            name = (it.get("name") or "").strip()
            if name and fragment.lower() in name.lower():
                client_list_id = str(it.get("listId") or it.get("id") or it.get("uniqueId"))
                break
    except Exception as e:
        print(f"[ERROR] Failed to fetch client lists: {e}")
        return summary

    if not client_list_id:
        print(f"[ERROR] No matching Client List found for fragment '{fragment}'")
        return summary

    print(f"[INFO] Using Client List ID: {client_list_id}")

    # Step 2: Fetch rate policies
    rate_url = f"{base_url}/appsec/v1/configs/{config_id}/versions/{version}/rate-policies"
    try:
        r = session.get(rate_url)
        r.raise_for_status()
        policies = r.json().get("ratePolicies", [])
    except Exception as e:
        print(f"[ERROR] Failed to fetch rate policies: {e}")
        return summary

    def get_policy_id(p: dict) -> str:
        return str(p.get("id") or p.get("policyId") or p.get("uuid") or p.get("uniqueId") or "")

    # Step 3: Update each policy
    for policy in policies:
        policy_id = get_policy_id(policy)
        policy_name = policy.get("name") or "Unnamed Policy"
        rp_url = f"{base_url}/appsec/v1/configs/{config_id}/versions/{version}/rate-policies/{policy_id}"
        print(f"[INFO] Updating policy '{policy_name}' (id={policy_id})")

        try:
            rp_resp = session.get(rp_url)
            rp_resp.raise_for_status()
            full_doc = rp_resp.json()

            # Build payload with GUI-visible condition
            new_condition = {
                "type": "NetworkListCondition",
                "positiveMatch": True,
                "values": [client_list_id]
            }

            existing_conditions = full_doc.get("additionalMatchConditions", [])
            # Remove any previous NetworkListCondition to avoid duplicates
            filtered_conditions = [
                c for c in existing_conditions if c.get("type") != "NetworkListCondition"
            ]
            filtered_conditions.append(new_condition)

            payload = {
                "name": full_doc.get("name"),
                "description": full_doc.get("description"),
                "threshold": full_doc.get("threshold"),
                "burstThreshold": full_doc.get("burstThreshold"),
                "durationSeconds": full_doc.get("durationSeconds"),
                "clientIdentifier": full_doc.get("clientIdentifier"),
                "action": {
                    "type": full_doc.get("action", {}).get("type", "alert")
                },
                "additionalMatchConditions": filtered_conditions
            }

            print(f"[DBG] PUT URL: {rp_url}")
            print("[DBG] Payload:")
            print(json.dumps(payload, indent=2))

            put_resp = session.put(rp_url, json=payload)
            put_resp.raise_for_status()
            summary["successful"] += 1
            summary["details"].append({"policy": policy_name, "status": "updated"})
            print(f"[INFO] Updated '{policy_name}'")

            # Step 4: Verify update
            verify_resp = session.get(rp_url)
            verify_resp.raise_for_status()
            verify_doc = verify_resp.json()
            print(f"[VERIFY] Match Conditions for '{policy_name}':")
            print(json.dumps(verify_doc.get("additionalMatchConditions", []), indent=2))

        except Exception as e:
            print(f"[ERROR] Failed updating '{policy_name}': {e}")
            summary["failed"] += 1
            summary["details"].append({"policy": policy_name, "status": "failed", "error": str(e)})

    print(f"[INFO] Done. Success: {summary['successful']}, Failed: {summary['failed']}")
    return summary


#########################################################################
import requests
import json
from typing import Dict, List, Union, Any, Optional

def reassign_dos_protection_rate_policies(
    session: requests.Session,
    base_url: str,
    config_id: Union[str, int],
    version: Union[str, int],
    access_group: str,
    list_name_fragment: Optional[str] = None,
) -> Dict[str, Union[int, List[Dict[str, str]]]]:
    summary: Dict[str, Union[int, List[Dict[str, str]]]] = {"successful": 0, "failed": 0, "details": []}
    fragment = (list_name_fragment or f"SC-{access_group} Rate Controls Bypass List").strip()
    print(f"[DBG] Matching fragment: '{fragment}' (case-insensitive)")

    def _pretty_dump(label: str, data: Any):
        print(f"[DBG] {label} (formatted):")
        try:
            print(json.dumps(data, indent=2))
        except Exception:
            print(f"[DBG] {label} could not be pretty-printed.")

    def _collect_list_candidates(obj: Any) -> List[Dict[str, Any]]:
        candidates: List[Dict[str, Any]] = []

        def has_id(d: Dict[str, Any]) -> bool:
            return any(k in d and d[k] for k in ("listId", "id", "uniqueId"))

        def is_candidate(d: Dict[str, Any]) -> bool:
            name = d.get("name")
            return isinstance(name, str) and has_id(d)

        def walk(node: Any):
            if isinstance(node, dict):
                if is_candidate(node):
                    candidates.append(node)
                for v in node.values():
                    walk(v)
            elif isinstance(node, list):
                for item in node:
                    walk(item)

        walk(obj)
        return candidates

    # STEP 1: Resolve client list
    client_list_id = None
    client_list_name = None

    try:
        resp = session.get(f"{base_url}/client-list/v1/lists", params={"includeInactive": "true"})
        resp.raise_for_status()
        data = resp.json()
        _pretty_dump("Client Lists", data)

        candidates = _collect_list_candidates(data)
        for it in candidates:
            name = (it.get("name") or "").strip()
            if name and fragment.lower() in name.lower():
                client_list_id = str(it.get("listId") or it.get("id") or it.get("uniqueId"))
                client_list_name = name
                break

    except Exception as e:
        print(f"[WARN] Failed to fetch client lists: {e}")

    if not client_list_id:
        print(f"[ERROR] No matching Client List found for fragment '{fragment}'")
        return summary

    print(f"[INFO] Using list '{client_list_name}' (ID: {client_list_id})")

    # STEP 2: Fetch rate policies
    rate_url = f"{base_url}/appsec/v1/configs/{config_id}/versions/{version}/rate-policies"
    try:
        r = session.get(rate_url)
        r.raise_for_status()
        raw_policies = r.json()
        _pretty_dump("Rate Policies", raw_policies)
        policies = raw_policies.get("ratePolicies", [])
    except Exception as e:
        print(f"[ERROR] Failed to fetch rate policies: {e}")
        return summary

    if not policies:
        print("[INFO] No rate policies found.")
        return summary

    def get_policy_id(p: dict) -> str:
        return str(p.get("id") or p.get("policyId") or p.get("uuid") or p.get("uniqueId") or "")

    # STEP 3: Update each policy
    for policy in policies:
        policy_id = get_policy_id(policy)
        policy_name = policy.get("name") or "Unnamed Policy"
        rp_url = f"{base_url}/appsec/v1/configs/{config_id}/versions/{version}/rate-policies/{policy_id}"
        print(f"[INFO] Processing policy '{policy_name}' (id={policy_id})")

        try:
            rp_resp = session.get(rp_url)
            rp_resp.raise_for_status()
            full_doc = rp_resp.json()

            # Build minimal schema-aligned payload
            payload = {
                "name": full_doc.get("name"),
                "description": full_doc.get("description"),
                "averageThreshold": full_doc.get("averageThreshold"),
                "burstThreshold": full_doc.get("burstThreshold"),
                "burstWindow": full_doc.get("burstWindow", 5),
                "clientIdentifier": full_doc.get("clientIdentifier"),
                "matchType": full_doc.get("matchType"),
                "pathMatchType": full_doc.get("pathMatchType"),
                "requestType": full_doc.get("requestType"),
                "sameActionOnIpv6": full_doc.get("sameActionOnIpv6", True),
                "type": full_doc.get("type"),
                "action": {
                    "type": full_doc.get("action", {}).get("type", "alert")
                },
                "matchCriteria": {
                    "bypassNetworkLists": [client_list_id]
                }
            }

            print(f"[DBG] PUT URL: {rp_url}")
            print("[DBG] Payload being sent:")
            print(json.dumps(payload, indent=2))

            put_resp = session.put(rp_url, json=payload)
            put_resp.raise_for_status()
            summary["successful"] += 1
            summary["details"].append({"policy": policy_name, "status": "updated"})
            print(f"[INFO] Updated rate policy '{policy_name}'")

        except Exception as e:
            print(f"[ERROR] Failed updating '{policy_name}': {e}")
            summary["failed"] += 1
            summary["details"].append({"policy": policy_name, "status": "failed", "error": str(e)})

    print(f"[INFO] Reassignment complete. Success: {summary['successful']}, Failed: {summary['failed']}")
    return summary
