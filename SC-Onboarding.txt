from typing import Optional, Union, List, Dict, Any

def reassign_dos_protection_rate_policies(
    session,
    base_url: str,
    config_id: Union[str, int],
    version: Union[str, int],
    access_group: str,
    template_policy_name_prefix: str = "Security Policy Template",
    template_bypass_name: str = "Security Policy Template Rate Controls Bypass List",
    sc_bypass_suffix: str = "Rate Controls Bypass List",
    activate_clones: bool = True,
    target_policy_id: Optional[str] = None,
    debug: bool = True,
):
    """
    For every DoS rate policy attached to this config/version:
      1) If the policy name starts with the template prefix, clone it to 'SC-<access_group> <suffix>'.
         Otherwise keep the existing policy id as-is.
      2) On the kept/cloned policy, fix additionalMatchOptions -> NetworkListCondition so that any
         template client list names (or ids) are replaced by the corresponding 'SC-<access_group> â€¦' list id.
      3) PUT the updated policy (if changed), then PUT the config's dos-rates assignments.

    Notes:
      - Safe for Python 3.8/3.9 (no PEP604 union syntax).
      - Emits debug prints when `debug=True`.
      - Does not change your existing call sites.
    """

    list_url = "{}/appsec/v1/configs/{}/versions/{}/dos-rates".format(base_url, config_id, version)
    clone_url = "{}/appsec/v1/rate-policies/clone".format(base_url)
    policy_url_template = "{}/appsec/v1/rate-policies/{{policy_id}}".format(base_url)

    summary = {
        "processed": 0,
        "successful": 0,
        "failed": 0,
        "fixed_conditions": 0,
        "details": [],
    }

    # --- helper: resolve a Client List ID we should use in the NetworkListCondition ---
    # tries exact provided id, exact name, and then derives "SC-<access_group> <suffix>" if it looks like a template
    def _resolve_list_id_by_name_or_id(name_or_id: Optional[Union[str, int]]) -> Optional[str]:
        if name_or_id is None:
            return None

        s = str(name_or_id).strip()
        if not s:
            return None

        # If it's already a numeric id, return it (Akamai client-list ids are numeric strings)
        if s.isdigit():
            return s

        # If it looks like a template list name, derive the expected SC- name
        # e.g. "Security Policy Template Rate Controls Bypass List"  ->  "SC-<AG> Rate Controls Bypass List"
        candidate_names = [s]
        if s.startswith("Security Policy Template"):
            suffix = s.split("Security Policy Template", 1)[-1].strip()
            if suffix:
                candidate_names.insert(0, "SC-{} {}".format(access_group, suffix))

        # Search by name until we find a hit
        for nm in candidate_names:
            try:
                # Your codebase already has these helpers; reusing them:
                #   - search_client_lists_by_name(session, base_url, needle) -> List[Tuple[listId, name]]
                hits = search_client_lists_by_name(session, base_url, nm)  # type: ignore
                if hits:
                    return str(hits[0][0])
            except Exception:
                # If helper isn't available or fails, fall back to no resolution
                pass

        return None  # not found

    try:
        # 1) Read the current assignment list
        if debug:
            print("[DBG] GET dos policies:", list_url)

        resp = session.get(list_url)
        if resp.status_code == 404:
            # Some tenants expose dos policies at /dos-protection end-points only after features are enabled.
            if debug:
                print("[DBG] dos-rates endpoint 404 for this config/version; skipping DoS reassignment.")
            return summary

        resp.raise_for_status()
        assigned = resp.json().get("ratePolicies", [])  # List[Dict[str, Any]]

        if debug:
            names = ["{} ({})".format(p.get("name"), p.get("id")) for p in assigned]
            print("[DBG] Found {} assigned DoS rate policies: {}".format(len(assigned), names))

        updated_assignments: List[str] = []

        for p in assigned:
            summary["processed"] += 1
            orig_name = p.get("name") or ""
            orig_id = p.get("id")
            kept_id = orig_id
            kept_name = orig_name

            # 1a) Clone if it's a template-named policy
            if orig_name.startswith(template_policy_name_prefix):
                suffix = orig_name.replace(template_policy_name_prefix, "", 1).strip()
                clone_name = "SC-{} {}".format(access_group, suffix).strip()

                # reuse if a policy with that clone_name is already part of the assignment list
                existing = next((rp for rp in assigned if (rp.get("name") or "") == clone_name), None)
                if existing:
                    kept_id = existing.get("id")
                    kept_name = clone_name
                    if debug:
                        print("[DBG] Reusing existing cloned policy '{}' ({})".format(kept_name, kept_id))
                else:
                    # Clone a new rate policy
                    payload = {
                        "cloneFromRatePolicyId": orig_id,
                        "name": clone_name,
                        "description": "Cloned from {}".format(orig_name),
                        "matchType": p.get("matchType"),
                    }
                    try:
                        c = session.post(clone_url, json=payload)
                        c.raise_for_status()
                        kept_id = c.json().get("id")
                        kept_name = clone_name
                        if debug:
                            print("[DBG] Cloned template policy '{}' -> '{}' ({})".format(orig_name, kept_name, kept_id))

                        if activate_clones and kept_id:
                            act_url = policy_url_template.format(policy_id=kept_id) + "/activate"
                            session.post(act_url, json={"network": "STAGING"})  # best-effort; ignore errors
                        summary["successful"] += 1
                        summary["details"].append({"template": orig_name, "clone": kept_name, "status": "success"})
                    except Exception as clone_err:
                        # Fallback to the original template policy id if clone fails
                        kept_id = orig_id
                        kept_name = orig_name
                        if debug:
                            print("[WARN] Clone failed for '{}': {}".format(orig_name, clone_err))
                        summary["failed"] += 1
                        summary["details"].append(
                            {"template": orig_name, "status": "clone_failed", "error": str(clone_err)}
                        )

            # 2) Fix the NetworkListCondition values on the *kept* policy (cloned or original)
            try:
                full_url = policy_url_template.format(policy_id=kept_id)
                d = session.get(full_url)
                d.raise_for_status()
                full = d.json()  # Dict[str, Any]

                # If caller asked us to touch only policies attached to a specific security policy id
                if target_policy_id and str(full.get("policyId")) != str(target_policy_id):
                    updated_assignments.append(kept_id)
                    continue

                changed = False
                amo = full.get("additionalMatchOptions", []) or []
                for opt in amo:
                    if (opt.get("type") or "").lower() != "networklistcondition":
                        continue

                    values = opt.get("values", []) or []
                    new_vals = []
                    for v in values:
                        v_str = str(v).strip()
                        if v_str.isdigit():
                            # already an id
                            new_vals.append(v_str)
                            continue

                        # try resolve to SC- list id
                        resolved = _resolve_list_id_by_name_or_id(v_str)
                        if resolved:
                            new_vals.append(resolved)
                            if resolved != v_str:
                                changed = True
                                if debug:
                                    print("[DBG]   replaced client list '{}' -> id {}".format(v_str, resolved))
                        else:
                            new_vals.append(v_str)  # keep as-is if not resolvable

                    # Special case: if the option refers to the *template* bypass-list name exactly,
                    # also try to map it directly to 'SC-<AG> Rate Controls Bypass List'
                    # (defensive in case the template name isn't in 'values' verbatim).
                    if template_bypass_name in values:
                        derived_name = "SC-{} {}".format(access_group, sc_bypass_suffix)
                        derived_id = _resolve_list_id_by_name_or_id(derived_name)
                        if derived_id and derived_id not in new_vals:
                            new_vals.append(derived_id)
                            changed = True
                            if debug:
                                print("[DBG]   added derived SC bypass list id {} for '{}'".format(derived_id, template_bypass_name))

                    opt["values"] = new_vals

                if changed:
                    # remove read-only fields before PUT
                    for ro in ("id", "updateDate", "used", "createdDate", "createdBy"):
                        full.pop(ro, None)

                    u = session.put(full_url, json=full)
                    u.raise_for_status()
                    summary["fixed_conditions"] += 1

                    if debug:
                        # small readable preview of the changed part
                        try:
                            changed_opts_preview = [
                                o for o in full.get("additionalMatchOptions", [])
                                if (o.get("type") or "").lower() == "networklistcondition"
                            ]
                            print("[DBG] Payload (NetworkListCondition) PUT:", changed_opts_preview)
                        except Exception:
                            pass

                updated_assignments.append(kept_id)

            except Exception as fix_err:
                if debug:
                    print("[WARN] Failed to update DoS policy '{}' ({}): {}".format(kept_name, kept_id, fix_err))
                summary["failed"] += 1
                summary["details"].append(
                    {"id": kept_id, "name": kept_name, "status": "update_failed", "error": str(fix_err)}
                )
                updated_assignments.append(kept_id)  # keep it in the list anyway

        # 3) Replace the config's assignment list
        try:
            put_resp = session.put(list_url, json={"ratePolicies": updated_assignments})
            put_resp.raise_for_status()
            if debug:
                print("[DBG] Updated dos-rates assignment list ->", updated_assignments)
        except Exception as assign_err:
            if debug:
                print("[WARN] Failed to PUT dos-rates assignment list:", assign_err)
            summary["failed"] += 1
            summary["details"].append({"status": "assign_failed", "error": str(assign_err)})

    except Exception as e:
        if debug:
            print("[DBG] Top-level failure in reassign_dos_protection_rate_policies:", e)
        summary["failed"] += 1
        summary["details"].append({"status": "failed", "error": str(e)})

    return summary
