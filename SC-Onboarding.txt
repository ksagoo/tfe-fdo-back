def reassign_dos_protection_rate_policies(
    session,
    base_url,
    config_id,
    version,
    *args,
    **kwargs,
):
    """
    Clone template DoS rate policies and reassign them to SC-<access_group> clones,
    then fix their Match Criteria ('NetworkListCondition') so the client list used
    is the SC-<access_group> 'Rate Controls Bypass List'.

    Drop-in: works with existing call sites (extra positional/keyword args ignored).

    Expected kwargs (optional):
      - access_group: str  (used to build SC- names)
      - template_policy_name_prefix: str (default: 'Security Policy Template')
      - activate_clones: bool (default: True)  -> activate cloned policies in STAGING
      - debug: bool (default: True)

    Returns a summary dict.
    """
    access_group = kwargs.get("access_group") or kwargs.get("group") or ""
    template_policy_name_prefix = kwargs.get("template_policy_name_prefix", "Security Policy Template")
    activate_clones = kwargs.get("activate_clones", True)
    debug = kwargs.get("debug", True)

    def _debug(msg):
        if debug:
            print(f"[DEBUG] {msg}")

    list_url = f"{base_url}/appsec/v1/configs/{config_id}/versions/{version}/dos-rates"
    clone_url = f"{base_url}/appsec/v1/rate-policies/clone"
    policy_url_template = f"{base_url}/appsec/v1/rate-policies/{{policy_id}}"

    # The target client list name we want inside NetworkListCondition
    desired_list_name = f"SC-{access_group} Rate Controls Bypass List".strip()

    summary = {
        "processed": 0,
        "successful": 0,
        "failed": 0,
        "fixed_conditions": 0,
        "details": [],
    }

    # Helper to show current assignment brief
    def _brief_assignments(assign):
        items = []
        for p in (assign or []):
            nm = p.get("name")
            pid = p.get("id")
            items.append(f"{nm}({pid})")
        return items

    try:
        # 1) Read current assignments
        resp = session.get(list_url)
        resp.raise_for_status()
        assigned = resp.json().get("ratePolicies", [])
        _debug(
            "DOS assignments on config {} v{}: {}".format(
                config_id, version, _brief_assignments(assigned)
            )
        )

        updated_assignment_ids = []

        for rp in assigned:
            summary["processed"] += 1
            orig_id = rp.get("id")
            orig_name = rp.get("name") or ""

            kept_id = orig_id
            kept_name = orig_name

            # 2) Clone template policies to SC-<access_group>...
            if orig_name.startswith(template_policy_name_prefix):
                suffix = orig_name.replace(template_policy_name_prefix, "").strip()
                clone_name = f"SC-{access_group} {suffix}".strip()

                # If a clone with the target name already exists in assignment list, reuse it
                existing = next((x for x in assigned if (x.get("name") or "") == clone_name), None)
                if existing:
                    kept_id = existing.get("id")
                    kept_name = clone_name
                    _debug(f"Reusing existing clone: {kept_name} ({kept_id})")
                else:
                    try:
                        payload = {
                            "cloneFromRatePolicyId": orig_id,
                            "name": clone_name,
                            "description": f"Cloned from {orig_name}",
                            "matchType": rp.get("matchType", "DOS"),
                        }
                        c = session.post(clone_url, json=payload)
                        c.raise_for_status()
                        kept_id = c.json().get("id")
                        kept_name = clone_name
                        _debug(f"Cloned DOS policy: {orig_name} -> {kept_name} ({kept_id})")

                        if activate_clones and kept_id:
                            act = session.post(
                                policy_url_template.format(policy_id=kept_id) + "/activate",
                                json={"network": "STAGING"},
                            )
                            # best-effort; don't raise
                            _debug(f"Staging activation requested for {kept_name} ({kept_id}); status={act.status_code}")
                        summary["successful"] += 1
                        summary["details"].append(
                            {"template": orig_name, "clone": kept_name, "status": "success"}
                        )
                    except Exception as e:
                        # Fall back to template id if cloning fails
                        _debug(f"Clone failed for {orig_name}: {e}")
                        kept_id = orig_id
                        kept_name = orig_name
                        summary["failed"] += 1
                        summary["details"].append(
                            {"template": orig_name, "status": "clone_failed", "error": str(e)}
                        )

            # 3) Fetch full policy and try to fix NetworkListCondition → values
            try:
                d = session.get(policy_url_template.format(policy_id=kept_id))
                d.raise_for_status()
                full = d.json()

                changed = False
                amo = full.get("additionalMatchOptions", [])
                for opt in amo:
                    if opt.get("type") != "NetworkListCondition":
                        continue

                    values = opt.get("values", [])
                    new_vals = []
                    for v in values:
                        v_str = str(v).strip()
                        # Keep numeric IDs as-is
                        if v_str.isdigit():
                            new_vals.append(v)
                            continue

                        # If it still references a template or anything else, use our SC- name
                        # (By name — this is accepted by the API; IDs also work but name is simpler
                        #  and avoids needing extra lookups.)
                        if "Security Policy Template" in v_str or v_str != desired_list_name:
                            new_vals.append(desired_list_name)
                            changed = True
                        else:
                            new_vals.append(v)

                    if changed:
                        opt["values"] = new_vals
                        _debug(
                            "Updated NetworkListCondition for policy {} ({}): {}".format(
                                kept_name, kept_id, new_vals
                            )
                        )

                # Remove a few read-only keys that can block PUT
                for ro in ("id", "updateDate", "used", "createdDate", "createdBy"):
                    full.pop(ro, None)

                if changed:
                    u = session.put(policy_url_template.format(policy_id=kept_id), json=full)
                    u.raise_for_status()
                    summary["fixed_conditions"] += 1
                    _debug(f"PUT policy OK: {kept_name} ({kept_id}) with updated client list values")

                updated_assignment_ids.append(kept_id)

            except Exception as e:
                _debug(f"Failed to update DOS policy {kept_name} ({kept_id}): {e}")
                summary["failed"] += 1
                summary["details"].append(
                    {"id": kept_id, "name": kept_name, "status": "update_failed", "error": str(e)}
                )
                # still keep the policy in assignments so we don't break the config
                updated_assignment_ids.append(kept_id)

        # 4) Replace the assignment list in the config
        try:
            put_resp = session.put(list_url, json={"ratePolicies": updated_assignment_ids})
            put_resp.raise_for_status()
            _debug("Updated config dos-rates assignment list: {}".format(updated_assignment_ids))
        except Exception as e:
            _debug(f"Failed to update dos-rates assignment list: {e}")
            summary["failed"] += 1
            summary["details"].append({"status": "assign_failed", "error": str(e)})

    except Exception as e:
        _debug(f"Top-level failure in reassign_dos_protection_rate_policies: {e}")
        summary["failed"] += 1
        summary["details"].append({"status": "failed", "error": str(e)})

    return summary
