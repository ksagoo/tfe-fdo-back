def reassign_dos_protection_rate_policies(
    session,
    base_url,
    config_id,
    version,
    access_group,
    template_policy_name_prefix="Security Policy Template",
    target_policy_id=None,          # optional: only touch policies attached to this security policy id
    activate_clones=True,           # keep your staging activation behavior
):
    """
    Makes DoS/rate policy assignments tenant- and version-compatible.

    What it does:
      1) Detects which assignment endpoint your tenant uses:
         - legacy:   /appsec/v1/configs/{configId}/versions/{version}/dos-rates
         - unified:  /appsec/v1/configs/{configId}/versions/{version}/rate-policies
      2) For each attached policy:
           - If its name starts with the template prefix, clone to "SC-<access_group> <suffix>"
             (re-using an existing clone if already present).
           - Otherwise keep it.
      3) For each kept/cloned policy, try to rewrite additionalMatchOptions/NetworkListCondition
         values from template client list *names* to their SC- list *ids* (best effort).
      4) PUT the cleaned policy (if changed), then update the assignment list.

    Notes:
      - Keeps your current call signature. No changes needed at call sites.
      - Requires your module's `search_client_lists_by_name(session, base_url, fragment)` helper
        if you want name->id replacement; otherwise we skip that step with a debug note.
    """

    import requests

    def _dbg(msg):
        print(f"[DBG] {msg}")

    # ---- endpoint detection -------------------------------------------------
    # Weâ€™ll try /dos-rates first (legacy). If 404, flip to /rate-policies.
    dos_rates_list = f"{base_url}/appsec/v1/configs/{config_id}/versions/{version}/dos-rates"
    unified_list   = f"{base_url}/appsec/v1/configs/{config_id}/versions/{version}/rate-policies"

    clone_url = f"{base_url}/appsec/v1/rate-policies/clone"  # same for both
    policy_url_template = f"{base_url}/appsec/v1/rate-policies/{{policy_id}}"

    list_url = dos_rates_list
    api_mode = "dos-rates"

    try:
        r = session.get(list_url)
        if r.status_code == 404:
            api_mode = "rate-policies"
            list_url = unified_list
            r = session.get(list_url)
        r.raise_for_status()
        _dbg(f"Using assignment endpoint mode: {api_mode} -> {list_url}")
    except Exception as e:
        print(f"[WARN] Cannot read DoS/rate assignments for this config/version: {e}")
        print("[WARN] Skipping DoS reassignment.")
        return {"processed": 0, "successful": 0, "failed": 1, "fixed_conditions": 0,
                "details": [{"status": "failed", "error": str(e)}]}

    # ---- helpers ------------------------------------------------------------

    # Optional helper from your module (if present) to search client lists by name.
    search_client_lists_by_name = globals().get("search_client_lists_by_name")

    def _resolve_client_list_id_from_name(name: str):
        """
        Try to find the SC- client list id from a template-like name.
        If we see 'Security Policy Template ...', we derive target 'SC-<access_group> ...'.
        Falls back to searching the incoming name fragment.
        """
        if search_client_lists_by_name is None:
            _dbg("No 'search_client_lists_by_name' found in globals; skipping list name->id replacement.")
            return None

        expected = name
        if "Security Policy Template" in name:
            suffix = name.split("Security Policy Template", 1)[-1].strip()
            expected = f"SC-{access_group} {suffix}".strip()

        try:
            matches = search_client_lists_by_name(session, base_url, expected)
            # Expect tuples like (listId, name) -> take first id
            return matches[0][0] if matches else None
        except Exception as e:
            _dbg(f"Client list lookup failed for '{expected}': {e}")
            return None

    # ---- main flow ----------------------------------------------------------
    summary = {"processed": 0, "successful": 0, "failed": 0, "fixed_conditions": 0, "details": []}

    try:
        assigned = r.json().get("ratePolicies", [])  # both endpoints return list with policy ids/names
    except Exception:
        assigned = []

    if not isinstance(assigned, list):
        print(f"[WARN] Unexpected assignment payload: {assigned!r}")
        assigned = []

    # Resolve a snapshot of all names in current assignment set for quick reuse checks
    assigned_by_name = {p.get("name"): p for p in assigned if isinstance(p, dict)}

    updated_assignments = []

    for p in assigned:
        if not isinstance(p, dict):
            continue
        summary["processed"] += 1

        orig_name = p.get("name", "")
        orig_id   = p.get("id")

        kept_id = orig_id
        kept_name = orig_name

        # ---- clone template-named policies to SC-<access_group> <suffix> ----
        if orig_name.startswith(template_policy_name_prefix):
            suffix = orig_name.replace(template_policy_name_prefix, "").strip()
            clone_name = f"SC-{access_group} {suffix}".strip()

            existing = assigned_by_name.get(clone_name)
            if existing:
                kept_id = existing.get("id")
                kept_name = clone_name
                _dbg(f"Reuse existing clone: '{clone_name}' (id={kept_id})")
            else:
                try:
                    payload = {
                        "cloneFromRatePolicyId": orig_id,
                        "name": clone_name,
                        "description": f"Cloned from {orig_name}",
                        # some tenants require matchType; include if present on source:
                        **({"matchType": p.get("matchType")} if p.get("matchType") else {}),
                    }
                    c = session.post(clone_url, json=payload)
                    c.raise_for_status()
                    kept_id = c.json().get("id")
                    kept_name = clone_name
                    _dbg(f"Cloned rate policy: '{orig_name}' -> '{clone_name}' (id={kept_id})")

                    if activate_clones and kept_id:
                        try:
                            act = session.post(policy_url_template.format(policy_id=kept_id) + "/activate",
                                               json={"network": "STAGING"})
                            _dbg(f"Activated clone in STAGING: id={kept_id}, status={act.status_code}")
                        except Exception as act_err:
                            _dbg(f"Activation warning (ignored): {act_err}")

                    summary["successful"] += 1
                    summary["details"].append({"template": orig_name, "clone": kept_name, "status": "success"})
                except Exception as clone_err:
                    kept_id = orig_id
                    kept_name = orig_name
                    summary["failed"] += 1
                    summary["details"].append({"template": orig_name, "status": "clone_failed", "error": str(clone_err)})
                    _dbg(f"Clone FAILED for '{orig_name}': {clone_err}")

        # ---- attempt to fix NetworkListCondition values (name->id) ----------
        try:
            d = session.get(policy_url_template.format(policy_id=kept_id))
            d.raise_for_status()
            full = d.json()

            # If caller limited to one security policy, respect that:
            if target_policy_id and full.get("policyId") != target_policy_id:
                updated_assignments.append(kept_id)
                continue

            changed = False
            for opt in full.get("additionalMatchOptions", []) or []:
                if opt.get("type") != "NetworkListCondition":
                    continue

                new_vals = []
                for v in opt.get("values", []) or []:
                    # numeric => looks like already an id
                    v_str = str(v)
                    if v_str.isdigit():
                        new_vals.append(v)
                        continue

                    resolved = _resolve_client_list_id_from_name(v_str)
                    if resolved and resolved != v:
                        changed = True
                        new_vals.append(resolved)
                    else:
                        new_vals.append(v)

                if changed:
                    # small readable preview in logs
                    try:
                        preview = [{"before": opt.get("values", []), "after": new_vals}]
                        _dbg(f"NetworkListCondition change for policy '{kept_name}': {preview}")
                    except Exception:
                        pass
                    opt["values"] = new_vals

            # scrub read-only fields before PUT
            for ro in ("id", "updateDate", "used", "createdDate", "createdBy"):
                full.pop(ro, None)

            if changed:
                u = session.put(policy_url_template.format(policy_id=kept_id), json=full)
                u.raise_for_status()
                summary["fixed_conditions"] += 1
                _dbg(f"Updated DoS policy '{kept_name}' (id={kept_id}) with resolved client list ids.")

            updated_assignments.append(kept_id)

        except Exception as fix_err:
            summary["failed"] += 1
            summary["details"].append(
                {"id": kept_id, "name": kept_name, "status": "update_failed", "error": str(fix_err)}
            )
            _dbg(f"Update FAILED for policy '{kept_name}' (id={kept_id}): {fix_err}")
            updated_assignments.append(kept_id)

    # ---- write back the assignment list ------------------------------------
    try:
        put_payload = {"ratePolicies": updated_assignments}
        pr = session.put(list_url, json=put_payload)
        pr.raise_for_status()
        _dbg(f"Assignment list updated via {api_mode}.")
    except Exception as assign_err:
        summary["failed"] += 1
        summary["details"].append({"status": "assign_failed", "error": str(assign_err)})
        print(f"[WARN] Failed to update assignment list: {assign_err}")

    return summary
