#!/usr/bin/env python
# ===============================================================
#  Akamai Entitlement Validator
# ===============================================================
#  Description:
#     Validates whether a given FQDN and access group have
#     corresponding entitlements across:
#       • CPS (Certificate Provisioning System)
#       • AppSec (Security Configurations)
#       • PAPI (Property Manager hostnames)
#
#  This tool supports automated pre-validation during onboarding,
#  ensuring that each FQDN is correctly linked to its Akamai entities.
#
# ---------------------------------------------------------------
#  Usage:
#     python akamai_entitlement_validator.py \
#        --section DEV \
#        --fqdn espspos-dev-059test.hsbc.com.hk \
#        --access-group ServiceNow-itilUser
#
# ---------------------------------------------------------------
#  Output:
#     output/cps_raw.json
#     output/appsec_raw.json
#     output/papi_raw.json
#     output/entitlement_summary.json
#
# ---------------------------------------------------------------
#  Exit Codes:
#     0 = Authorized (at least one match found)
#     1 = Unauthorized (no matches found)
# ===============================================================

import os
import sys
import json
import argparse
import traceback
from requests import Session
from akamai.edgegrid import EdgeGridAuth
from configparser import ConfigParser
from os.path import expanduser

# ===============================================================
#  REGION SETTINGS
#  Update with contract/group IDs for your environment
# ===============================================================
REGION_SETTINGS = {
    "GLOBAL": {"contract_id": "ctr_1-2YI4WYRH", "group_id": "grp_154041"},
    "APAC":   {"contract_id": "ctr_1-5A82LRIN", "group_id": "grp_272084"},
    "EMEA":   {"contract_id": "ctr_1-5A82MHB8", "group_id": "grp_272093"},
    "LATAM":  {"contract_id": "ctr_1-5A85K4K9", "group_id": "grp_272089"},
    "AMER":   {"contract_id": "ctr_1-5A85K4K9", "group_id": "grp_272090"},
    "DEV":    {"contract_id": "ctr_1-5A82MTA",  "group_id": "grp_272095"}
}


# ===============================================================
#  SESSION SETUP
# ===============================================================
def setup_session(section):
    """Create an authenticated Akamai session using .edgerc credentials."""
    edgerc = os.path.join(expanduser("~"), ".edgerc")
    parser = ConfigParser()
    parser.read(edgerc)

    if not parser.has_section(section):
        raise ValueError(f"Missing section [{section}] in .edgerc")

    base_url = "https://" + parser.get(section, "host")
    session = Session()
    session.auth = EdgeGridAuth(
        client_token=parser.get(section, "client_token"),
        client_secret=parser.get(section, "client_secret"),
        access_token=parser.get(section, "access_token")
    )
    session.headers.update({
        "Content-Type": "application/json",
        "Accept": "application/json"
    })
    return session, base_url


# ===============================================================
#  JSON OUTPUT HELPER
# ===============================================================
def write_json_safely(filename, response):
    """Write API response safely as JSON or text fallback."""
    os.makedirs("output", exist_ok=True)
    path = os.path.join("output", filename)
    try:
        parsed = response.json()
        with open(path, "w") as f:
            json.dump(parsed, f, indent=4)
    except Exception:
        with open(path, "w") as f:
            f.write(response.text)
    return path


# ===============================================================
#  CPS LOOKUP
# ===============================================================
def check_cps(session, base_url, contract_id, fqdn, access_group):
    """Query CPS for enrollments matching the FQDN and access group."""
    url = f"{base_url}/cps/v2/enrollments?contractId={contract_id}"
    print(f"[INFO] CPS lookup: {url}")
    result = {"found": False, "url": url, "matches": []}

    try:
        resp = session.get(url, timeout=(10, 60))
        write_json_safely("cps_raw.json", resp)

        if resp.status_code != 200:
            print(f"[FAILURE] CPS API returned {resp.status_code}")
            return result

        data = resp.json()
        fqdn_lower = fqdn.lower()
        ag_lower = access_group.lower()

        for cert in data.get("enrollments", []):
            cn = (cert.get("csr") or {}).get("cn", "")
            sans = (cert.get("csr") or {}).get("sans", [])
            all_values = " ".join([cn] + sans).lower()

            if fqdn_lower in all_values and ag_lower in json.dumps(cert).lower():
                expires = (cert.get("certificate") or {}).get("notAfter", "")
                result["matches"].append({
                    "cn": cn,
                    "sans": sans,
                    "expires": expires
                })

        result["found"] = bool(result["matches"])
        print(f"[RESULT] CPS: {'FOUND' if result['found'] else 'NOT FOUND'}")

    except Exception as e:
        print(f"[ERROR] CPS lookup failed: {e}")
        traceback.print_exc()

    return result


# ===============================================================
#  APPSEC LOOKUP
# ===============================================================
def check_appsec(session, base_url, contract_id, group_id, access_group):
    """Query AppSec configurations and match by access group in name."""
    url = f"{base_url}/appsec/v1/configs?contractId={contract_id}&groupId={group_id}"
    print(f"[INFO] AppSec lookup: {url}")
    result = {"found": False, "url": url, "matches": []}

    try:
        resp = session.get(url, timeout=(10, 60))
        write_json_safely("appsec_raw.json", resp)

        if resp.status_code != 200:
            print(f"[FAILURE] AppSec API returned {resp.status_code}")
            return result

        data = resp.json()
        ag = access_group.lower()

        for cfg in data.get("configurations", []):
            name = cfg.get("name", "")
            if ag in name.lower():
                result["matches"].append({
                    "id": cfg.get("id"),
                    "name": name,
                    "latestVersion": cfg.get("latestVersion"),
                    "stagingVersion": cfg.get("stagingVersion"),
                    "productionVersion": cfg.get("productionVersion"),
                    "targetProduct": cfg.get("targetProduct")
                })

        result["found"] = bool(result["matches"])
        print(f"[RESULT] AppSec: {'FOUND' if result['found'] else 'NOT FOUND'}")

    except Exception as e:
        print(f"[ERROR] AppSec lookup failed: {e}")
        traceback.print_exc()

    return result


# ===============================================================
#  PAPI LOOKUP
# ===============================================================
def check_papi(session, base_url, fqdn, access_group):
    """Query PAPI for hostnames that match the given FQDN and access group."""
    url = f"{base_url}/papi/v1/hostnames"
    print(f"[INFO] PAPI lookup: {url}")
    result = {"found": False, "url": url, "matches": []}

    try:
        resp = session.get(url, timeout=(10, 60))
        write_json_safely("papi_raw.json", resp)

        if resp.status_code != 200:
            print(f"[FAILURE] PAPI API returned {resp.status_code}")
            return result

        data = resp.json()
        items = (data.get("hostnames") or {}).get("items", [])
        fqdn_lower = fqdn.lower()
        ag_lower = access_group.lower()

        for entry in items:
            cname_from = entry.get("cnameFrom", "")
            property_name = entry.get("propertyName", "")
            fqdn_match = cname_from.lower() == fqdn_lower
            group_match = ag_lower in property_name.lower()

            if fqdn_match:
                result["matches"].append({
                    "propertyName": property_name,
                    "cnameFrom": cname_from,
                    "contractId": entry.get("contractId"),
                    "groupId": entry.get("groupId")
                })
                if group_match:
                    result["found"] = True

        result["found"] = result["found"] or bool(result["matches"])
        print(f"[RESULT] PAPI: {'FOUND' if result['found'] else 'NOT FOUND'}")

    except Exception as e:
        print(f"[ERROR] PAPI lookup failed: {e}")
        traceback.print_exc()

    return result


# ===============================================================
#  MAIN VALIDATION LOGIC
# ===============================================================
def validate_entitlement(section, access_group, fqdn):
    """Perform entitlement validation across CPS, AppSec, and PAPI."""
    print("==============================================================")
    print("  Akamai Entitlement Validator Suite")
    print("==============================================================")
    print(f"Section:      {section}")
    print(f"Access Group: {access_group}")
    print(f"FQDN:         {fqdn}")
    print("--------------------------------------------------------------")

    os.makedirs("output", exist_ok=True)

    region = REGION_SETTINGS.get(section.upper())
    if not region:
        print(f"[ERROR] Invalid section: {section}")
        sys.exit(1)

    session, base_url = setup_session(section)
    contract_id = region["contract_id"]
    group_id = region["group_id"]

    results = {
        "section": section,
        "access_group": access_group,
        "fqdn": fqdn,
        "cps": check_cps(session, base_url, contract_id, fqdn, access_group),
        "appsec": check_appsec(session, base_url, contract_id, group_id, access_group),
        "papi": check_papi(session, base_url, fqdn, access_group)
    }

    validated_by = [k.upper() for k, v in results.items() if isinstance(v, dict) and v.get("found")]
    results["validated_by"] = validated_by
    results["authorized"] = bool(validated_by)

    print("--------------------------------------------------------------")
    print(f"[SUMMARY] Validation Result: {'AUTHORIZED' if results['authorized'] else 'UNAUTHORIZED'}")
    print(f"[SUMMARY] Validated By: {', '.join(validated_by) if validated_by else 'None'}")
    print("--------------------------------------------------------------")

    with open("output/entitlement_summary.json", "w") as f:
        json.dump(results, f, indent=4)

    print("[INFO] Summary written to output/entitlement_summary.json")
    print("==============================================================\n")

    return 0 if results["authorized"] else 1


# ===============================================================
#  ENTRY POINT
# ===============================================================
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Akamai Entitlement Validator")
    parser.add_argument("--section", required=True, help="Section in .edgerc (e.g., DEV, APAC, EMEA)")
    parser.add_argument("--access-group", required=True, help="Akamai Access Group name")
    parser.add_argument("--fqdn", required=True, help="FQDN to validate")

    args = parser.parse_args()
    sys.exit(validate_entitlement(args.section, args.access_group, args.fqdn))
