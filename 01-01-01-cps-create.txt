"""
Akamai Entitlement Check Script - LDAP Lookup & Group Membership Script

Description:
    Query the internal LDAP/AD API and retrieve user details, including group
    memberships. Supports listing, membership checks, substring search,
    exporting JSON, comparing two users, and validating Akamai Access Groups.

New in this version:
    --check-access-group-only
        Runs ONLY the Akamai PAPI validation step. Does not call LDAP at all.
        Useful in environments (e.g. Jenkins) where outbound proxy is required
        for Akamai but breaks LDAP.

        - If the group exists:
              YES groupName="<NAME>" groupId="<ID>"
        - If not found:
              NO pattern="<SEARCH_STRING>"

Parameters:
    --base (optional)        Base LDAP API URL (default: HSBC LDAP endpoint)
    --user (required)        Primary user ID (e.g., 45384191)
    --user-b (optional)      Second user ID for comparison
    --summary (optional)     Print user summary
    --groups (optional)      Print only group memberships
    --is-member (optional)   Check membership (substring or exact match)
    --exact (optional)       Require exact match for --is-member
    --find (optional)        Find groups containing substring
    --save-json (optional)   Save raw JSON for inspection
    --verify-ca (optional)   Path to CA cert for LDAP TLS verification
    --access-group (opt)     Access Group name (validated via PAPI, used for LDAP search)
    --region (optional)      Region (required if --access-group is provided)
    --edgerc-file (optional) Path to .edgerc file (default ~/.edgerc)
    --section-name (opt)     Section inside .edgerc (default: default)
    --check-access-group-only (opt)
                             Run only PAPI Access Group validation step
    --timeout (optional)     LDAP request timeout in seconds (default: 20)
    --retries (optional)     LDAP retry attempts (default: 3)
    --retry-backoff (opt)    Backoff factor for LDAP retries (default: 0.5)
    --debug (optional)       Enable debug output
"""


if args.check_access_group_only:
    if not args.access_group or not args.region:
        print("ERROR: --access-group and --region are required with --check-access-group-only")
        return
    gid = access_group_exists(
        args.access_group,
        edgerc_file=os.path.expanduser(args.edgerc_file),
        section_name=args.section_name,
        region=args.region,
        debug=args.debug
    )
    if gid:
        print(f"YES groupName=\"{args.access_group}\" groupId=\"{gid}\"")
    else:
        print(f"NO pattern=\"{args.access_group}\"")
    return

ap.add_argument("--check-access-group-only", action="store_true",
                help="Only validate access group via PAPI and exit (YES/NO with details).")


python entitlement_check.py \
  --check-access-group-only \
  --region APAC \
  --access-group "HSBC-APAC-VL"



#!/usr/bin/env python3
"""
Akamai Entitlement Check Script - LDAP Lookup & Group Membership Script

Description:
    Query the internal LDAP/AD API and retrieve user details, including group
    memberships. Supports listing, membership checks, substring search,
    exporting JSON, and comparing a primary user against another user.
    HTTPS certificate verification can be enabled with a provided CA file;
    otherwise warnings are suppressed by default.

    Additionally, when --access-group is provided, the script first validates
    that the given Akamai Access Group exists (via PAPI/EdgeGrid), before
    using that string as the substring for LDAP membership checks.

Parameters:
    --base (optional)        Base API URL (default: HSBC LDAP endpoint)
    --user (required)        Primary user ID (e.g., 45384191)
    --user-b (optional)      Second user ID for comparison
    --summary (optional)     Print user summary
    --groups (optional)      Print only group memberships
    --is-member (optional)   Check if user is in a group (substring or exact match)
    --exact (optional)       Require exact match for --is-member
    --find (optional)        Find groups by substring
    --save-json (optional)   Save raw JSON response to a file
    --verify-ca (optional)   Path to CA certificate for TLS verification (LDAP only)
    --access-group (opt)     Access Group name (validated via PAPI, used for LDAP search)
    --region (optional)      Region (required if --access-group is provided)
    --edgerc-file (optional) Path to .edgerc file (for PAPI auth, default ~/.edgerc)
    --section-name (opt)     Section inside .edgerc (default: default)
    --timeout (optional)     LDAP request timeout in seconds (default: 20)
    --retries (optional)     Retry attempts on LDAP failures (default: 3)
    --retry-backoff (opt)    Backoff factor for LDAP retries (default: 0.5)
    --debug (optional)       Enable debug logging

Usage Examples:
    # Print summary of a user
    python entitlement_check.py --user 45384191 --summary

    # List groups only
    python entitlement_check.py --user 45384191 --groups

    # Check membership (substring match)
    python entitlement_check.py --user 45384191 --is-member "ServiceNowDEV-Fulfiller"

    # Check membership (exact match)
    python entitlement_check.py --user 45384191 \
        --is-member "CN=InfoDir-ServiceNowDEV-Fulfiller,OU=ServiceNow,OU=Applications,OU=Groups,DC=InfoDir,DC=Prod,DC=HSBC" \
        --exact

    # Find groups containing substring
    python entitlement_check.py --user 45384191 --find "ServiceNowDEV-Fulfiller"

    # Save JSON for inspection
    python entitlement_check.py --user 45384191 --save-json ldap.json

    # Run with CA cert verification (LDAP TLS)
    python entitlement_check.py --user 45384191 --summary --verify-ca "/C/Users/45384191/certs/certs.pem"

    # Validate Access Group via PAPI and check LDAP membership
    python entitlement_check.py --region APAC --user 45384191 \
        --access-group "HSBC-APAC-VL" \
        --edgerc-file ~/.edgerc --section-name default \
        --verify-ca "/C/Users/45384191/certs/certs.pem"

Note:
    --verify-ca applies only to the LDAP call, not to the Akamai PAPI (EdgeGrid) calls.
"""

import argparse
import json
import os
import sys
import requests
import urllib3
from typing import Any, Dict, List, Tuple, Optional
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
from akamai.edgegrid import EdgeGridAuth, EdgeRc

# Suppress warnings if running insecure mode
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# --- Region to Contract ID Mapping ---
REGION_SETTINGS = {
    "Global": {"contract_id": "V-5A82RH"},
    "APAC": {"contract_id": "V-5A82LRN"},
    "EMEA": {"contract_id": "V-5A82MHB"},
    "LATAM": {"contract_id": "V-5A854K9"},
    "AMER": {"contract_id": "V-5A854K9"},
    "DEV": {"contract_id": "V-5A82MTA"},
}

# --- LDAP Helpers ---

def _headers_from_env(
    override_bearer: Optional[str] = None,
    override_cookies: Optional[str] = None,
    debug: bool = False
) -> Dict[str, str]:
    headers = {"Accept": "application/json"}
    bearer = override_bearer if override_bearer else os.getenv("LDAP_BEARER")
    cookies = override_cookies if override_cookies else os.getenv("LDAP_COOKIES")
    if bearer:
        headers["Authorization"] = f"Bearer {bearer}"
    if cookies:
        headers["Cookie"] = cookies
    if debug:
        print(f"[DEBUG] LDAP headers: Authorization={'yes' if bearer else 'no'}, Cookie={'yes' if cookies else 'no'}")
    return headers

def make_ldap_session(retries: int, backoff: float, debug: bool = False) -> requests.Session:
    retry_cfg = Retry(
        total=retries,
        connect=retries,
        read=retries,
        status=retries,
        backoff_factor=backoff,
        status_forcelist=(502, 503, 504),
        allowed_methods=frozenset(["GET", "HEAD", "OPTIONS"]),
        raise_on_status=False,
        respect_retry_after_header=True,
    )
    adapter = HTTPAdapter(max_retries=retry_cfg)
    sess = requests.Session()
    sess.mount("http://", adapter)
    sess.mount("https://", adapter)
    if debug:
        print(f"[DEBUG] LDAP session retries={retries}, backoff={backoff}")
    return sess

def fetch_user_json(
    base_url: str,
    user_id: str,
    *,
    ca_path: Optional[str] = None,
    headers: Optional[Dict[str, str]] = None,
    timeout: float = 20.0,
    session: Optional[requests.Session] = None,
    debug: bool = False
) -> Dict[str, Any]:
    url = f"{base_url.rstrip('/')}/{user_id}"
    if debug:
        print(f"[DEBUG] LDAP GET {url} (timeout={timeout}, verify={'file' if ca_path else 'False'})")
    sess = session or requests.Session()
    resp = sess.get(
        url,
        headers=headers or {"Accept": "application/json"},
        timeout=timeout,
        verify=(ca_path if ca_path else False),
    )
    resp.raise_for_status()
    return resp.json()

def _extract_groups(payload: Dict[str, Any]) -> List[str]:
    groups = payload.get("memberOf", [])
    return sorted([str(g) for g in groups], key=str.casefold) if isinstance(groups, list) else []

# --- Akamai PAPI Helpers ---

def setup_edgegrid_session(edgerc_file: str, section_name: str):
    edgerc = EdgeRc(edgerc_file)
    base_url = f"https://{edgerc.get(section_name, 'host')}/"
    client_token = edgerc.get(section_name, 'client_token')
    client_secret = edgerc.get(section_name, 'client_secret')
    access_token = edgerc.get(section_name, 'access_token')

    session = requests.Session()
    session.auth = EdgeGridAuth(
        client_token=client_token,
        client_secret=client_secret,
        access_token=access_token
    )
    return session, base_url

def get_akamai_group_id(group_name: str, contract_id: str, session: requests.Session, base_url: str) -> Optional[str]:
    url = f"{base_url}papi/v1/groups?contractId={contract_id}"
    resp = session.get(url, headers={"Accept": "application/json"})
    resp.raise_for_status()
    groups = resp.json()["groups"]["items"]
    for group in groups:
        if group["groupName"] == group_name:
            return group["groupId"]
    return None

def access_group_exists(group_name: str, *, edgerc_file: str, section_name: str,
                        region: str, debug: bool = False) -> Optional[str]:
    contract_id = REGION_SETTINGS[region]["contract_id"]
    if debug:
        print(f"[DEBUG] Region {region} maps to contract {contract_id}")
        print(f"[DEBUG] Validating Access Group '{group_name}' in PAPI ...")
    session, base_url = setup_edgegrid_session(edgerc_file, section_name)
    gid = get_akamai_group_id(group_name, contract_id, session, base_url)
    if debug:
        if gid:
            print(f"[DEBUG] Access Group '{group_name}' found with groupId {gid}")
        else:
            print(f"[DEBUG] Access Group '{group_name}' not found in PAPI")
    return gid

# --- Main ---

def main():
    ap = argparse.ArgumentParser(description="Fetch and query LDAP/AD details with optional Akamai Access Group validation.")
    ap.add_argument("--base", default="https://apprunner.hk.hsbc/cached-ldap-looker-upper/api/v1/ldap",
                    help="Base API URL (default: HSBC LDAP endpoint)")
    ap.add_argument("--user", required=True, help="Primary user ID (e.g. 45384191)")
    ap.add_argument("--user-b", help="Second user ID for comparison")
    ap.add_argument("--summary", action="store_true", help="Print user summary")
    ap.add_argument("--groups", action="store_true", help="List only groups")
    ap.add_argument("--is-member", metavar="GROUP", help="Check membership (substring or exact match)")
    ap.add_argument("--exact", action="store_true", help="Use exact match for --is-member")
    ap.add_argument("--find", metavar="PATTERN", help="Find groups by substring")
    ap.add_argument("--save-json", metavar="PATH", help="Save fetched JSON to file")
    ap.add_argument("--verify-ca", metavar="CA_PATH", help="Path to CA cert for LDAP TLS verification")
    ap.add_argument("--access-group", help="Access Group name (validated via PAPI, used for LDAP search)")
    ap.add_argument("--region", choices=REGION_SETTINGS.keys(), help="Region (required if --access-group is provided)")
    ap.add_argument("--edgerc-file", default="~/.edgerc", help="Path to .edgerc file")
    ap.add_argument("--section-name", default="default", help="Section inside .edgerc file")
    ap.add_argument("--timeout", type=float, default=20.0, help="LDAP request timeout in seconds (default: 20)")
    ap.add_argument("--retries", type=int, default=3, help="LDAP retry attempts (default: 3)")
    ap.add_argument("--retry-backoff", type=float, default=0.5, help="Exponential backoff factor (default: 0.5)")
    ap.add_argument("--debug", action="store_true", help="Enable debug output")

    args = ap.parse_args()

    # If access group provided, validate via PAPI first
    if args.access_group:
        if not args.region:
            print("ERROR: --region is required when using --access-group")
            sys.exit(1)
        gid = access_group_exists(args.access_group,
                                  edgerc_file=os.path.expanduser(args.edgerc_file),
                                  section_name=args.section_name,
                                  region=args.region,
                                  debug=args.debug)
        if not gid:
            print(f"ERROR: Access Group '{args.access_group}' not found in PAPI for region {args.region}.")
            sys.exit(1)

    # Prepare LDAP headers and session
    ldap_headers = _headers_from_env(debug=args.debug)
    ldap_sess = make_ldap_session(args.retries, args.retry_backoff, debug=args.debug)

    # Fetch primary user
    u1 = fetch_user_json(args.base, args.user,
                         ca_path=args.verify_ca,
                         headers=ldap_headers,
                         timeout=args.timeout,
                         session=ldap_sess,
                         debug=args.debug)

    if args.save_json:
        with open(args.save_json, "w", encoding="utf-8") as f:
            json.dump(u1, f, indent=2)

    # Single-user checks
    did_any = False
    if args.is_member and not args.access_group:
        mode = "exact" if args.exact else "substring"
        print(f"[SEARCH] pattern='{args.is_member}' (mode={mode})")
        matches = [g for g in _extract_groups(u1)
                   if (g.strip().casefold() == args.is_member.strip().casefold() if args.exact else args.is_member.lower() in g.lower())]
        print("YES" if matches else "NO")
        for m in matches: print(m)
        did_any = True

    if args.access_group:
        mode = "exact" if args.exact else "substring"
        print(f"[SEARCH] pattern='{args.access_group}' (mode={mode})")
        matches = [g for g in _extract_groups(u1)
                   if (g.strip().casefold() == args.access_group.strip().casefold() if args.exact else args.access_group.lower() in g.lower())]
        print("YES" if matches else "NO")
        for m in matches: print(m)
        did_any = True

    if args.find:
        print(f"[FIND] pattern='{args.find}'")
        for g in _extract_groups(u1):
            if args.find.lower() in g.lower():
                print(g)
        did_any = True

    if args.groups:
        for g in _extract_groups(u1):
            print(g)
        did_any = True

    if args.summary:
        print(json.dumps({k: u1.get(k) for k in ("displayName","mail","sAMAccountName","employeeID","department","company")}, indent=2))
        did_any = True

    if not did_any:
        print("No action selected. Use --summary, --groups, --is-member, --find, or --access-group.")

if __name__ == "__main__":
    main()
