# ==============================================================
# AppSec Check — Final Schema-Correct Version
# ==============================================================

import json
import os
import traceback


def check_appsec(session, base_url, fqdn, region, contract_id, group_id, access_group, debug=False):
    """
    Validates AppSec configuration entitlements using correct schema.

    Steps:
      1. Query /appsec/v1/configs?contractId=&groupId=
      2. Filter configs whose name contains the access_group
      3. Within those, search fqdn in productionHostnames (if key present)
      4. Marks FOUND or PARTIAL MATCH accordingly

    Always writes raw + parsed JSON when debug=True.
    """

    def safe_lower(v):
        if isinstance(v, str):
            return v.lower().strip()
        return str(v).lower().strip() if v else ""

    fqdn_lower = safe_lower(fqdn)
    ag_lower = safe_lower(access_group)

    result = {
        "found": False,
        "partial": False,
        "url": f"{base_url}/appsec/v1/configs?contractId={contract_id}&groupId={group_id}",
        "matches": [],
        "partial_matches": [],
    }

    try:
        url = result["url"]
        print(f"[INFO] AppSec lookup: {url}")
        resp = session.get(url, timeout=30)

        # Always save raw HTTP response in debug mode
        if debug:
            _write_raw_http(fqdn, "appsec", resp.text)

        if resp.status_code == 403:
            print("[WARN] AppSec access denied (HTTP 403)")
            result["partial_matches"].append({"reason": "access_denied"})
            return result

        if resp.status_code != 200:
            print(f"[ERROR] AppSec lookup failed with HTTP {resp.status_code}")
            if debug:
                _write_debug_json(fqdn, "appsec", {"status_code": resp.status_code, "response": resp.text[:500]})
            return result

        try:
            data = resp.json()
        except Exception as e:
            print(f"[ERROR] AppSec JSON decode failed: {e}")
            if debug:
                _write_debug_json(fqdn, "appsec", {"error": str(e), "raw": resp.text[:400]})
            return result

        if debug:
            _write_debug_json(fqdn, "appsec", data)

        configs = data.get("configurations", [])
        print(f"[DEBUG] AppSec configs returned: {len(configs)}")

        for cfg in configs:
            cfg_name = safe_lower(cfg.get("name"))
            cfg_id = cfg.get("id")

            if ag_lower not in cfg_name:
                continue  # skip unrelated configs

            prod_hosts = cfg.get("productionHostnames", [])

            # Skip configs without hostname data (not yet deployed)
            if not isinstance(prod_hosts, list) or not prod_hosts:
                if debug:
                    print(f"[DEBUG] Config '{cfg.get('name')}' (ID {cfg_id}) has no productionHostnames")
                continue

            if debug:
                print(f"[DEBUG] Checking '{cfg.get('name')}' for {fqdn_lower} in productionHostnames ({len(prod_hosts)} entries)")

            for hn in prod_hosts:
                hn_lower = safe_lower(hn)

                if fqdn_lower == hn_lower:
                    result["matches"].append({
                        "id": cfg_id,
                        "hostname": hn,
                        "matchType": "full",
                        "reason": "fqdn_in_productionHostnames",
                    })
                    result["found"] = True

                elif fqdn_lower in hn_lower:
                    result["partial_matches"].append({
                        "id": cfg_id,
                        "hostname": hn,
                        "matchType": "partial",
                        "reason": "partial_fqdn_in_productionHostnames",
                    })
                    result["partial"] = True

        print(f"[RESULT] AppSec: {'FOUND' if result['found'] else ('PARTIAL MATCH' if result['partial'] else 'NOT FOUND')}")

        if debug:
            if result["matches"]:
                print(f"[DEBUG] Full matches ({len(result['matches'])}):")
                for m in result["matches"]:
                    print(f"  → {m}")
            if result["partial_matches"]:
                print(f"[DEBUG] Partial matches ({len(result['partial_matches'])}):")
                for p in result["partial_matches"]:
                    print(f"  → {p}")
            if not result["found"] and not result["partial"]:
                print("[DEBUG] No AppSec matches found — check debug_appsec_*.json")

        return result

    except Exception as e:
        print(f"[ERROR] AppSec lookup failed: {e}")
        if debug:
            traceback.print_exc()
        return result


# ==============================================================
# Helper functions
# ==============================================================

def _write_raw_http(fqdn, category, raw_text):
    """Writes raw HTTP response to a .txt file."""
    os.makedirs("output", exist_ok=True)
    safe_name = fqdn.replace(".", "_")
    file_path = f"output/debug_{category}_raw_{safe_name}.txt"
    try:
        with open(file_path, "w", encoding="utf-8") as f:
            f.write(raw_text or "")
        print(f"[DEBUG] Raw {category} HTTP saved to {file_path}")
    except Exception as e:
        print(f"[WARN] Could not write {category} raw HTTP: {e}")


def _write_debug_json(fqdn, category, data):
    """Writes parsed JSON output to a .json file."""
    os.makedirs("output", exist_ok=True)
    safe_name = fqdn.replace(".", "_")
    file_path = f"output/debug_{category}_{safe_name}.json"
    try:
        with open(file_path, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2)
        print(f"[DEBUG] Parsed {category} JSON saved to {file_path}")
    except Exception as e:
        print(f"[WARN] Could not write {category} debug JSON: {e}")
