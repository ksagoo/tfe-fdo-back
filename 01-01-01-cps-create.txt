#!/usr/bin/env python
# ============================================================
#  Akamai Entitlement Validator (Level 2)
# ============================================================
#  Purpose:
#    Validates that a given Access Group is authorized for a
#    target FQDN or certificate based on:
#      • CPS enrollment ownership
#      • AppSec configuration mappings
#      • PAPI property hostname mappings
#
#  Notes:
#    - Uses region-based contract/group mapping (REGION_SETTINGS)
#    - Performs safe GET calls (no modification)
#    - Dumps all API JSON responses under ./output/
#    - Returns SUCCESS if any system shows valid ownership
# ============================================================
import os, sys, json, argparse, traceback
from akamai.edgegrid import EdgeGridAuth
import requests
from urllib.parse import urljoin
from requests.sessions import Session

# =====================================================
# Region Settings
# =====================================================
REGION_SETTINGS = {
    "DEV": {"contract_id": "ctr_1-ABCD123", "group_id": "grp_12345"},
    "APAC": {"contract_id": "ctr_1-EFGH456", "group_id": "grp_67890"},
    "PROD": {"contract_id": "ctr_1-IJKL789", "group_id": "grp_54321"}
}

# =====================================================
# Setup Session (uses one section for all APIs)
# =====================================================
def setup_session(section):
    import akamai.edgegrid.edgegrid as edgegrid
    from configparser import ConfigParser
    from os.path import expanduser

    edgerc = os.path.join(expanduser("~"), ".edgerc")
    parser = ConfigParser()
    parser.read(edgerc)

    if not parser.has_section(section):
        raise ValueError(f"Missing section [{section}] in .edgerc")

    base_url = "https://" + parser.get(section, "host")
    s = Session()
    s.auth = EdgeGridAuth(
        client_token=parser.get(section, "client_token"),
        client_secret=parser.get(section, "client_secret"),
        access_token=parser.get(section, "access_token")
    )
    s.headers.update({"Content-Type": "application/json"})
    return s, base_url


# =====================================================
# CPS Lookup
# =====================================================
def check_cps(session, base_url, contract_id, fqdn):
    url = f"{base_url}/cps/v2/enrollments?contractId={contract_id}"
    print(f"[INFO] CPS lookup: {url}")
    result = {"found": False, "url": url}
    try:
        resp = session.get(url, timeout=(10, 60))
        with open("output/cps_raw.json", "w") as f:
            f.write(resp.text)

        if resp.status_code != 200:
            print(f"[FAILURE] CPS API returned {resp.status_code}")
            return result

        data = resp.json()
        for cert in data.get("enrollments", []):
            cn = cert.get("csr", {}).get("cn")
            sans = cert.get("csr", {}).get("sans", [])
            if fqdn == cn or fqdn in sans:
                result["found"] = True
                break

        print(f"[RESULT] CPS: {'FOUND' if result['found'] else 'NOT FOUND'}")
    except Exception as e:
        print(f"[ERROR] CPS lookup failed: {e}")
        traceback.print_exc()
    return result


# =====================================================
# AppSec Lookup
# =====================================================
def check_appsec(session, base_url, contract_id, group_id, fqdn):
    url = f"{base_url}/appsec/v1/configs?contractId={contract_id}&groupId={group_id}"
    print(f"[INFO] AppSec lookup: {url}")
    result = {"found": False, "url": url}
    try:
        resp = session.get(url, timeout=(10, 60))
        with open("output/appsec_raw.json", "w") as f:
            f.write(resp.text)

        if resp.status_code != 200:
            print(f"[FAILURE] AppSec API returned {resp.status_code}")
            return result

        data = resp.json()
        for cfg in data.get("configurations", []):
            if fqdn in json.dumps(cfg):
                result["found"] = True
                break

        print(f"[RESULT] AppSec: {'FOUND' if result['found'] else 'NOT FOUND'}")
    except Exception as e:
        print(f"[ERROR] AppSec lookup failed: {e}")
        traceback.print_exc()
    return result


# =====================================================
# PAPI Lookup
# =====================================================
def check_papi(session, base_url, fqdn):
    url = f"{base_url}/papi/v1/hostnames"
    print(f"[INFO] PAPI lookup: {url}")
    result = {"found": False, "url": url}
    try:
        resp = session.get(url, timeout=(10, 60))
        with open("output/papi_raw.json", "w") as f:
            f.write(resp.text)

        if resp.status_code != 200:
            print(f"[FAILURE] PAPI API returned {resp.status_code}")
            return result

        data = resp.json()
        for item in data.get("hostnames", []):
            if fqdn in json.dumps(item):
                result["found"] = True
                break

        print(f"[RESULT] PAPI: {'FOUND' if result['found'] else 'NOT FOUND'}")
    except Exception as e:
        print(f"[ERROR] PAPI lookup failed: {e}")
        traceback.print_exc()
    return result


# =====================================================
# Main Validation
# =====================================================
def validate_entitlement(section, access_group, fqdn, dry_run=False, debug=False, json_only=False):
    print("\n=====================================================")
    print("Akamai Entitlement Validator Suite")
    print("=====================================================")
    print(f"Section:      {section}")
    print(f"Access Group: {access_group}")
    print(f"FQDN:         {fqdn}")
    print("-----------------------------------------------------")

    os.makedirs("output", exist_ok=True)
    region = REGION_SETTINGS.get(section.upper())
    if not region:
        print(f"[ERROR] Invalid section: {section}")
        sys.exit(1)

    contract_id = region["contract_id"]
    group_id = region["group_id"]
    session, base_url = setup_session(section)

    results = {
        "section": section,
        "access_group": access_group,
        "fqdn": fqdn,
        "cps": check_cps(session, base_url, contract_id, fqdn),
        "appsec": check_appsec(session, base_url, contract_id, group_id, fqdn),
        "papi": check_papi(session, base_url, fqdn)
    }

    results["authorized"] = any([
        results["cps"]["found"],
        results["appsec"]["found"],
        results["papi"]["found"]
    ])
    status = "AUTHORIZED" if results["authorized"] else "UNAUTHORIZED"

    print("-----------------------------------------------------")
    print(f"[SUMMARY] Validation result: {status}")
    print("-----------------------------------------------------")

    with open("output/entitlement_summary.json", "w") as f:
        json.dump(results, f, indent=4)

    print("[INFO] Validation summary written to output/entitlement_summary.json\n")
    return 0 if results["authorized"] else 1


# =====================================================
# CLI Entry
# =====================================================
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Akamai Entitlement Validator")
    parser.add_argument("--section", required=True, help="Section name in .edgerc (e.g., DEV, APAC, PROD)")
    parser.add_argument("--access-group", required=True, help="Akamai access group name")
    parser.add_argument("--fqdn", required=True, help="Certificate common name (FQDN)")
    parser.add_argument("--dry-run", action="store_true", help="Simulate only, no live API calls")
    parser.add_argument("--debug", action="store_true", help="Enable verbose debug logging")
    parser.add_argument("--json-only", action="store_true", help="Output summary JSON only")

    args = parser.parse_args()
    sys.exit(validate_entitlement(args.section, args.access_group, args.fqdn, args.dry_run, args.debug, args.json_only))
