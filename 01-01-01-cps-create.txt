def reverse_fqdn_lookup(session, base_url, fqdn, access_group, debug=False):
    """
    Reverse lookup for a given FQDN via PAPI hostnames search.
    Returns a dict:
      found, groupId, propertyName, accessGroupName, strippedPropertyName,
      matchAccessGroup (bool), matchType ("full"/"partial"/"none")
    """
    import os, re
    from urllib.parse import urljoin

    # ---------------- helpers ----------------
    def sanitize_filename(name: str) -> str:
        return re.sub(r"[^a-zA-Z0-9_.-]+", "_", name)

    def normalize(s: str) -> str:
        # remove non-alphanum and lowercase for robust equality
        return re.sub(r"[^a-z0-9]", "", (s or "").strip().lower())

    _group_cache = {}

    def get_group_name_by_id(session, base_url, group_id):
        """
        Try PAPI /groups first; if not found, try Identity Management groups.
        Cache results in-memory for speed.
        """
        if not group_id:
            return f"[unknown:{group_id}]"

        if group_id in _group_cache:
            return _group_cache[group_id]

        # 1) PAPI groups
        try:
            url = f"{base_url}/papi/v1/groups"
            hdrs = {"accept": "application/json", "PAPI-Use-Prefixes": "true"}
            r = session.get(url, headers=hdrs, timeout=20)
            if r.status_code == 200:
                data = r.json() or {}
                items = (data.get("groups") or {}).get("items", [])
                for g in items:
                    gid = g.get("groupId", "")
                    if gid.replace("grp_", "") == group_id.replace("grp_", ""):
                        name = g.get("groupName") or f"[unknown:{group_id}]"
                        _group_cache[group_id] = name
                        return name
        except Exception:
            pass  # fall through

        # 2) Identity Management groups (works with your earlier check)
        try:
            url = urljoin(base_url + "/", "identity-management/v3/user-admin/groups")
            r = session.get(url, headers={"accept": "application/json"}, timeout=20)
            if r.status_code == 200:
                groups = r.json() or []
                # id field naming varies; match by either 'groupId' or 'id'
                for g in groups:
                    gid = str(g.get("groupId") or g.get("id") or "")
                    if gid.replace("grp_", "") == group_id.replace("grp_", ""):
                        name = g.get("groupName") or g.get("name") or f"[unknown:{group_id}]"
                        _group_cache[group_id] = name
                        return name
        except Exception:
            pass

        return f"[unknown:{group_id}]"

    def strip_property_name(prop: str) -> str:
        """
        Remove leading SD-, SD_, SD  and trailing -Prod / -NonProd (any case, -, _, space tolerant).
        Then trim.
        """
        if not prop:
            return ""
        s = prop.strip()
        # strip leading SD[-_ ]?
        s = re.sub(r"^sd[-_ ]?", "", s, flags=re.IGNORECASE)
        # strip trailing [-_ ]?(prod|non[-_ ]?prod)$
        s = re.sub(r"[-_ ]?(?:non[-_ ]?prod|prod)$", "", s, flags=re.IGNORECASE)
        return s.strip()

    # ---------------- function body ----------------
    result = {
        "found": False,
        "groupId": None,
        "propertyName": None,
        "accessGroupName": None,
        "strippedPropertyName": None,
        "matchAccessGroup": None,
        "matchType": "none",
    }

    fqdn = (fqdn or "").strip().lower()
    url = f"{base_url}/papi/v1/hostnames?search={fqdn}"

    if debug:
        print("\n===== Starting Reverse FQDN Lookup =====")
        print(f"[INFO] Performing PAPI reverse lookup: {url}")

    try:
        resp = session.get(url, headers={"accept": "application/json", "PAPI-Use-Prefixes": "true"}, timeout=30)

        if debug:
            os.makedirs("output", exist_ok=True)
            with open(f"output/reverse_lookup_{sanitize_filename(fqdn)}.json", "w", encoding="utf-8") as f:
                f.write(resp.text)

        if resp.status_code != 200:
            print(f"[ERROR] PAPI reverse lookup failed: HTTP {resp.status_code}")
            return result

        data = resp.json() or {}
        if debug:
            # keep your raw capture
            from json import dump
            with open(f"output/raw_reverse_lookup_{sanitize_filename(fqdn)}.json", "w", encoding="utf-8") as f:
                dump(data, f, indent=2)

        # Accept all known shapes
        host_entries = []
        if isinstance(data, list):
            host_entries = data
        elif isinstance(data, dict):
            if "items" in data:
                host_entries = data["items"]
            elif "hostnames" in data:
                hn = data["hostnames"]
                if isinstance(hn, dict) and "items" in hn:
                    host_entries = hn["items"]
                elif isinstance(hn, list):
                    host_entries = hn

        if debug:
            print(f"[DEBUG] Total host entries returned: {len(host_entries)}")

        if not host_entries:
            if debug:
                print(f"[WARN] No hostname entries found for {fqdn}")
                print("===== Reverse Lookup Complete =====\n")
            return result

        # Try for a full hit, else first partial
        full_hit = None
        partial_hit = None
        for entry in host_entries:
            if not isinstance(entry, dict):
                continue
            cname_from = str(entry.get("cnameFrom", "")).lower()
            cname_to   = str(entry.get("stagingCnameTo", "")).lower()
            edge_host  = str(entry.get("stagingEdgeHostnameId", "")).lower()

            if fqdn == cname_from or fqdn == cname_to or fqdn == edge_host:
                full_hit = entry
                break
            if fqdn in cname_from or fqdn in cname_to:
                if partial_hit is None:
                    partial_hit = entry

        hit = full_hit or partial_hit
        if not hit:
            if debug:
                print(f"[WARN] No results found for {fqdn}")
                print("===== Reverse Lookup Complete =====\n")
            return result

        group_id      = hit.get("groupId", "")
        property_name = hit.get("propertyName", "UNKNOWN")
        ag_name_from_id = get_group_name_by_id(session, base_url, group_id)
        stripped = strip_property_name(property_name)

        # final, robust comparison against the CLI-supplied access group
        match_access = normalize(stripped) == normalize(access_group)

        result.update({
            "found": True,
            "groupId": group_id,
            "propertyName": property_name,
            "accessGroupName": ag_name_from_id,   # for display only
            "strippedPropertyName": stripped,
            "matchAccessGroup": match_access,
            "matchType": "full" if full_hit else "partial",
        })

        # ---------- compact normal-mode output ----------
        print(f"\nFQDN:        {fqdn}")
        print(f"Access Group: {ag_name_from_id}")
        print(f"Property:    {property_name}")
        print(f"Match:       {'TRUE' if match_access else 'FALSE'}")

        if debug:
            print("\n===== Reverse FQDN Lookup Result =====")
            print(f"[INFO] Stripped Property Name: {stripped}")
            print(f"[INFO] Property â†” AccessGroup Match: {match_access}")
            print(f"[INFO] Match Type: {'FULL' if full_hit else 'PARTIAL'}")
            print("===== Reverse Lookup Complete =====\n")

        return result

    except Exception as e:
        print(f"[ERROR] reverse_fqdn_lookup failed: {e}")
        return result
