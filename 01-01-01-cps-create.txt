import re
import time
import requests

SEP = "—" * 68  # nice single separator

def reverse_fqdn_lookup(session, base_url, fqdn, access_group, debug=False):
    """
    Reverse lookup a single FQDN via PAPI and compare the property name to the access group.

    Returns dict:
      found, groupId, propertyName, accessGroupName, strippedPropertyName,
      matchAccessGroup (bool), matchType ('full'|'partial'|'none')
    """

    # ------------------------ helpers ------------------------

    def get_group_name_by_id(sess, base, gid):
        """Try PAPI groups, then identity API, to resolve group display name."""
        if not gid:
            return None
        gid_clean = str(gid).replace("grp_", "")
        try:
            r = sess.get(f"{base}/papi/v1/groups",
                         headers={"accept": "application/json", "PAPI-Use-Prefixes": "true"},
                         timeout=20)
            if r.status_code == 200:
                data = r.json() or {}
                items = (data.get("groups") or {}).get("items", []) or []
                for g in items:
                    if str(g.get("groupId", "")).replace("grp_", "") == gid_clean:
                        return g.get("groupName") or None
        except Exception:
            pass

        # Fallback: identity groups (not always available, but cheap to try)
        try:
            r = sess.get(f"{base}/identity-management/v3/user-admin/groups",
                         headers={"accept": "application/json"}, timeout=20)
            if r.status_code == 200:
                for g in (r.json() or []):
                    cand = str(g.get("groupId") or g.get("id") or "")
                    if cand.replace("grp_", "") == gid_clean:
                        return g.get("groupName") or g.get("name") or None
        except Exception:
            pass

        return None

    def strip_env_suffix(n: str) -> str:
        # remove only when at the end, case-insensitive
        n_low = n.lower()
        if n_low.endswith("-nonprod"):
            return n[:-8]
        if n_low.endswith("-prod"):
            return n[:-4]
        return n

    def normalize_name(name: str) -> str:
        """Lower, remove leading 'sd-', drop env suffix, remove non-alphanumerics."""
        if not name:
            return ""
        n = name.strip().lower()
        if n.startswith("sd-"):  # first 3 chars only
            n = n[3:]
        n = strip_env_suffix(n)
        n = re.sub(r"[^a-z0-9]", "", n)  # crush dashes/underscores/spaces/punct
        return n

    def print_card(title_fqdn, ag_display, prop_display, match_bool):
        # aligned, compact, one card per fqdn
        print(SEP)
        print(f"{'FQDN:':13} {title_fqdn}")
        print(f"{'Access Group:':13} {ag_display}")
        print(f"{'Property:':13} {prop_display}")
        print(f"{'Match:':13} {'TRUE' if match_bool else 'FALSE'}")
        print(SEP)

    # ------------------------ init ------------------------

    fqdn_l = (fqdn or "").strip().lower()
    access_group_display = access_group or ""
    ag_norm = normalize_name(access_group_display)

    result = {
        "found": False,
        "groupId": None,
        "propertyName": None,
        "accessGroupName": None,
        "strippedPropertyName": None,
        "matchAccessGroup": None,
        "matchType": "none",
    }

    url = f"{base_url}/papi/v1/hostnames?search={fqdn_l}"
    if debug:
        print("\n[INFO] PAPI reverse lookup:", url)

    # ------------------------ request (+retry) ------------------------
    for attempt in range(3):
        try:
            resp = session.get(
                url,
                headers={"accept": "application/json", "PAPI-Use-Prefixes": "true"},
                timeout=30,
            )
            break
        except requests.exceptions.RequestException as e:
            if attempt < 2:
                if debug:
                    print(f"[WARN] Reverse lookup attempt {attempt+1} failed: {e} — retrying…")
                time.sleep(2 ** attempt)
            else:
                print(f"[ERROR] Reverse lookup failed after retries: {e}")
                return result

    if resp.status_code != 200:
        print(f"[ERROR] Reverse lookup HTTP {resp.status_code}")
        return result

    data = resp.json() or {}
    # accept any of the 3 shapes we’ve seen
    if isinstance(data, list):
        host_entries = data
    else:
        host_entries = (
            (data.get("items"))
            or (data.get("hostnames", {}).get("items") if isinstance(data.get("hostnames"), dict) else None)
            or (data.get("hostnames") if isinstance(data.get("hostnames"), list) else None)
            or []
        )

    if not host_entries:
        if debug:
            print(f"[WARN] No hostnames in response for {fqdn_l}")
        # still print a card so you see this fqdn in output
        print_card(fqdn_l, access_group_display, "<none>", False)
        return result

    # ------------------------ choose best match ------------------------
    full_hit = None
    partial_hit = None
    for e in host_entries:
        if not isinstance(e, dict):
            continue
        cname_from = str(e.get("cnameFrom", "")).lower()
        cname_to   = str(e.get("stagingCnameTo", "")).lower()
        edge_host  = str(e.get("stagingEdgeHostnameId", "")).lower()

        if fqdn_l == cname_from or fqdn_l == cname_to or fqdn_l == edge_host:
            full_hit = e
            break  # prefer strict equality
        if fqdn_l in cname_from or fqdn_l in cname_to:
            if partial_hit is None:
                partial_hit = e

    hit = full_hit or partial_hit
    if not hit:
        if debug:
            print(f"[WARN] No match found for {fqdn_l}")
        print_card(fqdn_l, access_group_display, "<none>", False)
        return result

    # ------------------------ compare normalized names ------------------------
    group_id = hit.get("groupId")
    property_name = hit.get("propertyName") or ""

    prop_norm = normalize_name(property_name)
    ag_name_from_id = get_group_name_by_id(session, base_url, group_id)

    # final equality on normalized forms
    match_flag = (prop_norm == ag_norm)

    # update result
    result.update({
        "found": True,
        "groupId": group_id,
        "propertyName": property_name,
        "accessGroupName": ag_name_from_id,
        "strippedPropertyName": prop_norm,
        "matchAccessGroup": match_flag,
        "matchType": "full" if full_hit else "partial",
    })

    # ------------------------ clean, consistent output ------------------------
    print_card(fqdn_l, access_group_display, property_name, match_flag)

    if debug:
        print(f"[DEBUG] matchType:        {'full' if full_hit else 'partial'}")
        print(f"[DEBUG] groupId:          {group_id}")
        print(f"[DEBUG] groupName(id):    {ag_name_from_id or 'UNKNOWN'}")
        print(f"[DEBUG] accessGroup(norm):{ag_norm}")
        print(f"[DEBUG] property(norm):   {prop_norm}")

    return result
