 def reverse_fqdn_lookup(session, base_url, fqdn, access_group, debug=False):
    """
    Perform a reverse FQDN lookup using Akamai PAPI APIs.
    Returns dict:
      {
        'found': bool,
        'groupId': str,
        'propertyName': str,
        'accessGroupName': str,
        'strippedPropertyName': str,
        'matchAccessGroup': bool,
        'matchType': 'full' | 'partial' | 'none'
      }
    """
    import re, time
    import requests
    from urllib.parse import urljoin

    # ---------------- Helper functions ----------------
    def normalize_all(s):
        """Normalize name by removing prefixes, suffixes, symbols and lowercasing."""
        s = (s or "").strip()
        s = re.sub(r"^sd[-_ ]?", "", s, flags=re.IGNORECASE)
        s = re.sub(r"[-_ ]?(?:non[-_ ]?prod|prod)$", "", s, flags=re.IGNORECASE)
        s = re.sub(r"[-_]{2,}", "-", s)
        return re.sub(r"[^a-z0-9]", "", s.lower())

    _group_cache = {}

    def get_group_name_by_id(session, base_url, group_id):
        """Resolve Akamai groupId â†’ human-readable name via PAPI or IM APIs."""
        if not group_id:
            return f"[unknown:{group_id}]"

        if group_id in _group_cache:
            return _group_cache[group_id]

        try:
            papi_url = f"{base_url}/papi/v1/groups"
            headers = {"accept": "application/json", "PAPI-Use-Prefixes": "true"}
            resp = session.get(papi_url, headers=headers, timeout=20)
            if resp.status_code == 200:
                data = resp.json() or {}
                items = (data.get("groups") or {}).get("items", [])
                for g in items:
                    gid = g.get("groupId", "")
                    if gid.replace("grp_", "") == group_id.replace("grp_", ""):
                        name = g.get("groupName") or f"[unknown:{group_id}]"
                        _group_cache[group_id] = name
                        return name
        except Exception:
            pass

        # fallback: identity management API
        try:
            im_url = urljoin(base_url + "/", "identity-management/v3/user-admin/groups")
            resp = session.get(im_url, headers={"accept": "application/json"}, timeout=20)
            if resp.status_code == 200:
                for g in resp.json() or []:
                    gid = str(g.get("groupId") or g.get("id") or "")
                    if gid.replace("grp_", "") == group_id.replace("grp_", ""):
                        name = g.get("groupName") or g.get("name") or f"[unknown:{group_id}]"
                        _group_cache[group_id] = name
                        return name
        except Exception:
            pass

        return f"[unknown:{group_id}]"

    # ---------------- Core Logic ----------------
    result = {
        "found": False,
        "groupId": None,
        "propertyName": None,
        "accessGroupName": None,
        "strippedPropertyName": None,
        "matchAccessGroup": None,
        "matchType": "none",
    }

    fqdn = (fqdn or "").strip().lower()
    papi_url = f"{base_url}/papi/v1/hostnames?search={fqdn}"

    if debug:
        print(f"\n===== Starting Reverse FQDN Lookup =====")
        print(f"[INFO] Performing PAPI reverse lookup: {papi_url}")

    # Retry logic for transient Akamai API timeouts
    for attempt in range(3):
        try:
            resp = session.get(
                papi_url,
                headers={"accept": "application/json", "PAPI-Use-Prefixes": "true"},
                timeout=30
            )
            break
        except requests.exceptions.RequestException as e:
            if attempt < 2:
                print(f"[WARN] Lookup timeout, retrying ({attempt + 1}/3)...")
                time.sleep(2 ** attempt)
                continue
            else:
                print(f"[ERROR] reverse_fqdn_lookup failed after retries: {e}")
                return result

    if resp.status_code != 200:
        print(f"[ERROR] PAPI reverse lookup failed: HTTP {resp.status_code}")
        return result

    data = resp.json() or {}
    host_entries = []

    if isinstance(data, list):
        host_entries = data
    elif isinstance(data, dict):
        if "items" in data:
            host_entries = data["items"]
        elif "hostnames" in data:
            hn = data["hostnames"]
            if isinstance(hn, dict) and "items" in hn:
                host_entries = hn["items"]
            elif isinstance(hn, list):
                host_entries = hn

    if not host_entries:
        if debug:
            print(f"[WARN] No hostnames found for {fqdn}")
        return result

    # Identify best hit
    full_hit = None
    partial_hit = None
    for entry in host_entries:
        if not isinstance(entry, dict):
            continue
        cname_from = str(entry.get("cnameFrom", "")).lower()
        cname_to = str(entry.get("stagingCnameTo", "")).lower()
        edge_host = str(entry.get("stagingEdgeHostnameId", "")).lower()

        if fqdn in (cname_from, cname_to, edge_host):
            full_hit = entry
            break
        if fqdn in cname_from or fqdn in cname_to:
            partial_hit = partial_hit or entry

    hit = full_hit or partial_hit
    if not hit:
        if debug:
            print(f"[WARN] No matching hostname entry found for {fqdn}")
        return result

    group_id = hit.get("groupId", "")
    property_name = hit.get("propertyName", "UNKNOWN")
    access_group_name = get_group_name_by_id(session, base_url, group_id)

    # --- Normalization + Comparison ---
    stripped_prop = property_name.strip()
    stripped_prop_norm = normalize_all(stripped_prop)
    access_group_norm = normalize_all(access_group)

    match_access = stripped_prop_norm == access_group_norm

    result.update({
        "found": True,
        "groupId": group_id,
        "propertyName": property_name,
        "accessGroupName": access_group_name,
        "strippedPropertyName": stripped_prop,
        "matchAccessGroup": match_access,
        "matchType": "full" if full_hit else "partial",
    })

    # ---------------- Output ----------------
    print(f"\nFQDN:        {fqdn}")
    print(f"Access Group: {access_group}")
    print(f"Property:    {property_name}")
    print(f"Match:       {'TRUE' if match_access else 'FALSE'}")

    if debug:
        print(f"[DEBUG] Stripped Property Name: {stripped_prop}")
        print(f"[DEBUG] Normalized Property:    {stripped_prop_norm}")
        print(f"[DEBUG] Normalized AccessGroup: {access_group_norm}")
        print(f"[DEBUG] Match Type: {'FULL' if full_hit else 'PARTIAL'}")
        print(f"[DEBUG] Group ID: {group_id} ({access_group_name})")

    return result
