#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# =============================================================================
# Akamai FQDN ➜ Access Group Lookup Utility (v3)
# =============================================================================
#
# Description:
#   Performs reverse lookups to determine the Akamai Access Group responsible
#   for a given Fully Qualified Domain Name (FQDN).
#
#   The script queries the Akamai Property Manager (PAPI) API to resolve
#   property-level metadata and map hostnames to their associated group.
#
#   Supports multiple FQDNs, structured JSON output for pipelines, and
#   optional dry-run and debug modes.
#
# Features:
#   • Multi-FQDN lookup (multiple --fqdn flags)
#   • Optional --output JSON file for Jenkins or CI/CD usage
#   • --debug for detailed trace logging (URLs, HTTP codes, JSON fragments)
#   • --dry_run to always return success (useful for pipelines)
#   • Pretty terminal output when --json not used
#
# Usage:
#   python akamai_fqdn_access_group_lookup_v3.py \
#       --section GLOBAL \
#       --fqdn ybtaf.hsbc.com.cn \
#       --fqdn fusion-onboard-ifc.hsbc.com.cn \
#       --output entitlement_map.json
#
# Example Output:
#   {
#     "ybtaf.hsbc.com.cn": {
#       "accessGroupName": "CET-APAC-CNYBISystem",
#       "groupId": "grp_282359"
#     },
#     "fusion-onboard-ifc.hsbc.com.cn": "No-Matching-Access-Group"
#   }
#
# Exit Codes:
#   0 - Success (all lookups completed)
#   1 - One or more lookups failed
# =============================================================================

import sys
import os
import json
import argparse
import requests
from akamai.edgegrid import EdgeGridAuth
from configparser import ConfigParser

# -----------------------------------------------------------------------------
# Setup Akamai EdgeGrid Session
# -----------------------------------------------------------------------------
def setup_session(section):
    edgerc = os.path.join(os.path.expanduser("~"), ".edgerc")
    parser = ConfigParser()
    parser.read(edgerc)

    if not parser.has_section(section):
        print(f"[ERROR] Missing section [{section}] in {edgerc}")
        sys.exit(1)

    base_url = f"https://{parser.get(section, 'host')}"
    session = requests.Session()
    session.auth = EdgeGridAuth(
        client_token=parser.get(section, "client_token"),
        client_secret=parser.get(section, "client_secret"),
        access_token=parser.get(section, "access_token")
    )
    session.headers.update({"Accept": "application/json"})
    return session, base_url

# -----------------------------------------------------------------------------
# Helper: Get group name by ID
# -----------------------------------------------------------------------------
def get_group_name_by_id(session, base_url, group_id, debug=False):
    try:
        url = f"{base_url}/papi/v1/groups"
        resp = session.get(url, timeout=20)
        if debug:
            print(f"[DEBUG] GET {url} -> {resp.status_code}")
        if resp.status_code != 200:
            return "UNKNOWN"
        for item in resp.json().get("groups", {}).get("items", []):
            if item.get("groupId") == group_id:
                return item.get("groupName", "UNKNOWN")
    except Exception as e:
        if debug:
            print(f"[DEBUG] Exception while fetching group name: {e}")
    return "UNKNOWN"

# -----------------------------------------------------------------------------
# Reverse lookup by FQDN
# -----------------------------------------------------------------------------
def reverse_fqdn_lookup(session, base_url, fqdn, debug=False):
    fqdn = fqdn.lower()
    url = f"{base_url}/papi/v1/hostnames?search={fqdn}"

    if debug:
        print(f"[DEBUG] Querying hostnames endpoint: {url}")

    try:
        resp = session.get(url, timeout=30)
        if resp.status_code != 200:
            if debug:
                print(f"[DEBUG] HTTP {resp.status_code} for {fqdn}")
            return None
        data = resp.json()
    except Exception as e:
        if debug:
            print(f"[DEBUG] Exception during lookup: {e}")
        return None

    host_entries = (
        data.get("items")
        or data.get("hostnames", {}).get("items", [])
        or data.get("hostnames", [])
    )

    for entry in host_entries:
        cname_from = str(entry.get("cnameFrom", "")).lower()
        cname_to = str(entry.get("cnameTo", "")).lower()
        edge = str(entry.get("edgeHostname", "")).lower()
        staging = str(entry.get("stagingEdgeHostname", "")).lower()

        if fqdn not in (cname_from, cname_to, edge, staging):
            continue

        property_id = entry.get("propertyId")
        contract_id = entry.get("contractId")
        group_id = entry.get("groupId")

        if not (property_id and contract_id and group_id):
            continue

        # Retrieve property metadata
        prop_url = f"{base_url}/papi/v1/properties/{property_id}?contractId={contract_id}&groupId={group_id}"
        try:
            prop_resp = session.get(prop_url, timeout=20)
            if debug:
                print(f"[DEBUG] GET {prop_url} -> {prop_resp.status_code}")
            if prop_resp.status_code == 200:
                prop_data = prop_resp.json()
                prop_items = prop_data.get("properties", {}).get("items", [])
                real_group_id = prop_items[0].get("groupId", group_id) if prop_items else group_id
            else:
                real_group_id = group_id
        except Exception as e:
            if debug:
                print(f"[DEBUG] Property metadata exception: {e}")
            real_group_id = group_id

        # Resolve group name
        access_group_name = get_group_name_by_id(session, base_url, real_group_id, debug)

        return {
            "fqdn": fqdn,
            "groupId": real_group_id,
            "accessGroupName": access_group_name
        }

    return None

# -----------------------------------------------------------------------------
# Main
# -----------------------------------------------------------------------------
def main():
    parser = argparse.ArgumentParser(
        description="Akamai FQDN ➜ Access Group lookup utility (multi-FQDN + JSON support)"
    )
    parser.add_argument("--section", required=True, help="Environment section from .edgerc")
    parser.add_argument("--fqdn", required=True, action="append", help="FQDN(s) to look up (can specify multiple)")
    parser.add_argument("--output", help="Optional JSON file to save results")
    parser.add_argument("--debug", action="store_true", help="Enable verbose output for troubleshooting")
    parser.add_argument("--dry_run", action="store_true", help="Simulate success for CI/CD pipeline continuation")
    args = parser.parse_args()

    session, base_url = setup_session(args.section)
    results = {}
    has_failures = False

    for fqdn in args.fqdn:
        result = reverse_fqdn_lookup(session, base_url, fqdn, args.debug)
        if result:
            results[fqdn] = {
                "accessGroupName": result.get("accessGroupName"),
                "groupId": result.get("groupId")
            }
        else:
            results[fqdn] = "No-Matching-Access-Group"
            has_failures = True

    # Output handling
    if args.output:
        with open(args.output, "w") as f:
            json.dump(results, f, indent=2)
        print(f"[INFO] JSON output saved: {args.output}")
    else:
        print("\nAkamai FQDN Access Group Lookup Utility")
        print("=========================================")
        for fqdn, data in results.items():
            print(f"\nFQDN: {fqdn}")
            if isinstance(data, dict):
                print(f"Access Group: {data['accessGroupName']}")
                print(f"Group ID: {data['groupId']}")
            else:
                print("Access Group: No-Matching-Access-Group")
        print("=========================================\n")

    # Exit code management
    if args.dry_run:
        print("[INFO] Dry-run mode: pipeline will continue regardless of results.")
        sys.exit(0)
    elif has_failures:
        sys.exit(1)
    else:
        sys.exit(0)


if __name__ == "__main__":
    main()
