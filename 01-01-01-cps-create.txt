#!/usr/bin/env python
# ===============================================================
#  Akamai Entitlement Validator
# ===============================================================
#  Description:
#     Validates whether a given FQDN and access group have
#     corresponding entitlements across:
#       - CPS (Certificate Provisioning System)
#       - AppSec (Web Application Firewall / Security Configs)
#       - PAPI (Property Manager hostnames)
#
#  This tool supports automated pre-validation during onboarding,
#  ensuring each FQDN is correctly linked to its Akamai entities.
#
# ---------------------------------------------------------------
#  Usage Examples:
# ---------------------------------------------------------------
#  python akamai_entitlement_validator.py \
#      --section DEV_APPSEC \
#      --fqdn espspos-dev-059test.hsbc.com.hk \
#      --access-group ServiceNow-itilUser
#
#  python akamai_entitlement_validator.py \
#      --section PROD \
#      --fqdn myapp.hsbc.com \
#      --access-group CyberWasp
#
# ---------------------------------------------------------------
#  Output:
#  - output/cps_raw.json        (raw CPS API response)
#  - output/appsec_raw.json     (raw AppSec API response)
#  - output/papi_raw.json       (raw PAPI API response)
#  - output/entitlement_summary.json  (final structured summary)
#
# ---------------------------------------------------------------
#  Exit Codes:
#    0 = Authorized (at least one API validated the FQDN)
#    1 = Unauthorized (no match found)
# ===============================================================

import os
import sys
import json
import argparse
import traceback
from datetime import datetime
from requests.sessions import Session
from akamai.edgegrid import EdgeGridAuth
from configparser import ConfigParser
from os.path import expanduser

# ===============================================================
# REGION SETTINGS
# Update these mappings for your environments
# ===============================================================
REGION_SETTINGS = {
    "DEV": {
        "contract_id": "ctr_1-5A82MTA",
        "group_id": "grp_272095"
    },
    "PROD": {
        "contract_id": "ctr_1-XXXXXXX",
        "group_id": "grp_YYYYYYY"
    }
}


# ===============================================================
# SESSION SETUP
# ===============================================================
def setup_session(section):
    """Create an authenticated Akamai session using .edgerc credentials."""
    edgerc = os.path.join(expanduser("~"), ".edgerc")
    parser = ConfigParser()
    parser.read(edgerc)

    if not parser.has_section(section):
        raise ValueError(f"[ERROR] Missing section [{section}] in .edgerc")

    base_url = "https://" + parser.get(section, "host")
    session = Session()
    session.auth = EdgeGridAuth(
        client_token=parser.get(section, "client_token"),
        client_secret=parser.get(section, "client_secret"),
        access_token=parser.get(section, "access_token")
    )

    # Fix CPS 'missing accept header'
    session.headers.update({
        "Content-Type": "application/json",
        "Accept": "application/json"
    })

    return session, base_url


# ===============================================================
# CPS LOOKUP
# ===============================================================
def check_cps(session, base_url, contract_id, fqdn, access_group):
    """Query CPS for enrollments matching the FQDN and access group."""
    url = f"{base_url}/cps/v2/enrollments?contractId={contract_id}"
    print(f"[INFO] CPS lookup: {url}")
    result = {"found": False, "url": url, "matches": []}

    try:
        resp = session.get(url, timeout=(10, 60))
        with open("output/cps_raw.json", "w") as f:
            f.write(resp.text)

        if resp.status_code != 200:
            print(f"[FAILURE] CPS API returned {resp.status_code}")
            return result

        data = resp.json()
        for cert in data.get("enrollments", []):
            cn = (cert.get("csr") or {}).get("cn", "")
            sans = (cert.get("csr") or {}).get("sans", [])
            all_values = " ".join([cn] + sans).lower()

            if fqdn.lower() in all_values and access_group.lower() in json.dumps(cert).lower():
                expires = (cert.get("certificate") or {}).get("notAfter", "")
                result["matches"].append({
                    "cn": cn,
                    "sans": sans,
                    "expires": expires
                })

        result["found"] = bool(result["matches"])
        print(f"[RESULT] CPS: {'FOUND' if result['found'] else 'NOT FOUND'}")

    except Exception as e:
        print(f"[ERROR] CPS lookup failed: {e}")
        traceback.print_exc()

    return result


# ===============================================================
# APPSEC LOOKUP
# ===============================================================
def check_appsec(session, base_url, contract_id, group_id, access_group):
    """Query AppSec configurations and match by name containing access group."""
    url = f"{base_url}/appsec/v1/configs?contractId={contract_id}&groupId={group_id}"
    print(f"[INFO] AppSec lookup: {url}")
    result = {"found": False, "url": url, "matches": []}

    try:
        resp = session.get(url, timeout=(10, 60))
        with open("output/appsec_raw.json", "w") as f:
            f.write(resp.text)

        if resp.status_code != 200:
            print(f"[FAILURE] AppSec API returned {resp.status_code}")
            return result

        data = resp.json()
        for cfg in data.get("configurations", []):
            name = cfg.get("name", "")
            if access_group.lower() in name.lower():
                result["matches"].append({
                    "id": cfg.get("id"),
                    "name": name,
                    "latestVersion": cfg.get("latestVersion")
                })

        result["found"] = bool(result["matches"])
        print(f"[RESULT] AppSec: {'FOUND' if result['found'] else 'NOT FOUND'}")

    except Exception as e:
        print(f"[ERROR] AppSec lookup failed: {e}")
        traceback.print_exc()

    return result


# ===============================================================
# PAPI LOOKUP
# ===============================================================
def check_papi(session, base_url, fqdn, access_group):
    """Query PAPI for hostnames that match the given FQDN and access group."""
    url = f"{base_url}/papi/v1/hostnames"
    print(f"[INFO] PAPI lookup: {url}")
    result = {"found": False, "url": url, "matches": []}

    try:
        resp = session.get(url, timeout=(10, 60))
        with open("output/papi_raw.json", "w") as f:
            f.write(resp.text)

        if resp.status_code != 200:
            print(f"[FAILURE] PAPI API returned {resp.status_code}")
            return result

        data = resp.json()
        items = (data.get("hostnames") or {}).get("items", [])
        ag = access_group.lower()

        for entry in items:
            cname_from = entry.get("cnameFrom", "")
            property_name = entry.get("propertyName", "")
            fqdn_match = cname_from.lower() == fqdn.lower()
            group_match = ag in property_name.lower()

            if fqdn_match:
                result["matches"].append({
                    "propertyName": property_name,
                    "cnameFrom": cname_from,
                    "contractId": entry.get("contractId"),
                    "groupId": entry.get("groupId")
                })
                if group_match:
                    result["found"] = True

        result["found"] = result["found"] or bool(result["matches"])
        print(f"[RESULT] PAPI: {'FOUND' if result['found'] else 'NOT FOUND'}")

    except Exception as e:
        print(f"[ERROR] PAPI lookup failed: {e}")
        traceback.print_exc()

    return result


# ===============================================================
# MAIN VALIDATION LOGIC
# ===============================================================
def validate_entitlement(section, access_group, fqdn):
    """Perform entitlement validation across CPS, AppSec, and PAPI."""
    print("\n=====================================================")
    print("      Akamai Entitlement Validator Suite")
    print("=====================================================")
    print(f"Section:      {section}")
    print(f"Access Group: {access_group}")
    print(f"FQDN:         {fqdn}")
    print("-----------------------------------------------------")

    os.makedirs("output", exist_ok=True)

    region = REGION_SETTINGS.get(section.upper())
    if not region:
        print(f"[ERROR] Invalid section: {section}")
        sys.exit(1)

    session, base_url = setup_session(section)
    contract_id = region["contract_id"]
    group_id = region["group_id"]

    results = {
        "section": section,
        "access_group": access_group,
        "fqdn": fqdn,
        "cps": check_cps(session, base_url, contract_id, fqdn, access_group),
        "appsec": check_appsec(session, base_url, contract_id, group_id, access_group),
        "papi": check_papi(session, base_url, fqdn, access_group)
    }

    validated_by = [k.upper() for k, v in results.items() if isinstance(v, dict) and v.get("found")]
    results["validated_by"] = validated_by
    results["authorized"] = bool(validated_by)

    print("-----------------------------------------------------")
    print(f"[SUMMARY] Validation result: {'AUTHORIZED' if results['authorized'] else 'UNAUTHORIZED'}")
    print(f"[SUMMARY] Validated by: {', '.join(validated_by) if validated_by else 'None'}")
    print("-----------------------------------------------------")

    with open("output/entitlement_summary.json", "w") as f:
        json.dump(results, f, indent=4)

    print("[INFO] Summary written to output/entitlement_summary.json\n")
    return 0 if results["authorized"] else 1


# ===============================================================
# ENTRY POINT
# ===============================================================
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Akamai Entitlement Validator")
    parser.add_argument("--section", required=True, help="Section in .edgerc (e.g., DEV_APPSEC, PROD)")
    parser.add_argument("--access-group", required=True, help="Akamai Access Group name")
    parser.add_argument("--fqdn", required=True, help="FQDN to validate")

    args = parser.parse_args()
    sys.exit(validate_entitlement(args.section, args.access_group, args.fqdn))






#!/bin/bash
# ===============================================================
#  Akamai Entitlement Validation Test Suite
# ===============================================================
#  Description:
#     Wrapper script to run entitlement validation for a single
#     FQDN against Akamai CPS, AppSec, and PAPI APIs using the
#     Python validator.
#
#  The script logs the outcome to the console and generates:
#     - output/*.json files (raw API and summary data)
#
# ---------------------------------------------------------------
#  Usage Examples:
# ---------------------------------------------------------------
#  ./test_suite_entitlement.sh \
#       --section DEV_APPSEC \
#       --fqdn espspos-dev-059test.hsbc.com.hk \
#       --access-group ServiceNow-itilUser
#
#  ./test_suite_entitlement.sh \
#       --section PROD \
#       --fqdn myapp.hsbc.com \
#       --access-group CyberWasp
#
# ---------------------------------------------------------------
#  Exit Codes:
#     0 = Authorized
#     1 = Unauthorized
# ===============================================================

set -euo pipefail
IFS=$'\n\t'

# -------------------------------
# Resolve Script Directory
# -------------------------------
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PYTHON_CMD="python"

# -------------------------------
# Default Variables
# -------------------------------
SECTION=""
FQDN=""
ACCESS_GROUP=""
OUTPUT_DIR="${SCRIPT_DIR}/output"

# -------------------------------
# Parse Arguments
# -------------------------------
while [[ $# -gt 0 ]]; do
  case "$1" in
    --section)
      SECTION="$2"
      shift 2
      ;;
    --fqdn)
      FQDN="$2"
      shift 2
      ;;
    --access-group)
      ACCESS_GROUP="$2"
      shift 2
      ;;
    *)
      echo "[ERROR] Unknown argument: $1"
      echo "Usage: $0 --section <section> --fqdn <fqdn> --access-group <access-group>"
      exit 1
      ;;
  esac
done

# -------------------------------
# Validate Inputs
# -------------------------------
if [[ -z "$SECTION" || -z "$FQDN" || -z "$ACCESS_GROUP" ]]; then
  echo "[ERROR] Missing required arguments."
  echo "Usage: $0 --section <section> --fqdn <fqdn> --access-group <access-group>"
  exit 1
fi

# -------------------------------
# Prepare Environment
# -------------------------------
mkdir -p "$OUTPUT_DIR"
LOG_FILE="${OUTPUT_DIR}/${FQDN}.log"

# -------------------------------
# Header
# -------------------------------
echo "=============================================================="
echo "  Akamai Entitlement Validation Test Suite"
echo "=============================================================="
echo "Section:       $SECTION"
echo "Access Group:  $ACCESS_GROUP"
echo "FQDN:          $FQDN"
echo "--------------------------------------------------------------"

# -------------------------------
# Run Validation
# -------------------------------
echo "[INFO] Starting entitlement validation..."
$PYTHON_CMD "${SCRIPT_DIR}/akamai_entitlement_validator.py" \
  --section "$SECTION" \
  --access-group "$ACCESS_GROUP" \
  --fqdn "$FQDN" | tee "$LOG_FILE"

RESULT=${PIPESTATUS[0]}

# -------------------------------
# Output Summary
# -------------------------------
echo "--------------------------------------------------------------"
if [[ $RESULT -eq 0 ]]; then
  echo "[SUMMARY] Validation Result: AUTHORIZED"
  echo "[INFO] Entitlement confirmed for $FQDN"
else
  echo "[SUMMARY] Validation Result: UNAUTHORIZED"
  echo "[INFO] No valid entitlement found for $FQDN"
fi
echo "--------------------------------------------------------------"
echo "Output files written to: $OUTPUT_DIR"
echo "Log file: $LOG_FILE"
echo "=============================================================="

exit $RESULT











