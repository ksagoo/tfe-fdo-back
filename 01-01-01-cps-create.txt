#!/usr/bin/env python3
"""
Akamai Entitlement Validator

Validates a requested FQDN against Akamai products (CPS, AppSec, PAPI) using a
single .edgerc section and region mapping for contract/group. It distinguishes
between full and partial matches, and writes a clean summary JSON.

Usage:
  python akamai_entitlement_validator.py \
    --section DEV \
    --fqdn epspos-dev-059test.hsbc.com.hk \
    --access-group ServiceNow-itilUser \
    [--debug]

Summary output:
  output/entitlement_summary.json

With --debug:
  output/cps_raw.json
  output/appsec_raw.json
  output/papi_raw.json
"""

import os
import sys
import json
import argparse
import traceback
from requests.sessions import Session
from akamai.edgegrid import EdgeGridAuth
from configparser import ConfigParser
from os.path import expanduser

# =============================================================================
# Region Mappings (exactly as provided/working)
# =============================================================================
REGION_SETTINGS = {
    "Global": {
        "parent_group_name": "HSBC-DDoS-KSD-D-2YN4YRH",
        "contract_id": "P-2YN4YRH",
        "group_id": "154041",
    },
    "APAC": {
        "parent_group_name": "HSBC - APAC-V-5A82LRN",
        "contract_id": "V-5A82LRN",
        "group_id": "272084",
    },
    "EMEA": {
        "parent_group_name": "HSBC - EMEA-V-5A82MHB",
        "contract_id": "V-5A82MHB",
        "group_id": "272093",
    },
    "LATAM": {
        "parent_group_name": "HSBC-AMER -LATAM(V-5A854K9)",
        "contract_id": "V-5A854K9",
        "group_id": "272094",
    },
    "AMER": {
        "parent_group_name": "HSBC-AMER -LATAM(V-5A854K9)",
        "contract_id": "V-5A854K9",
        "group_id": "272094",
    },
    "DEV": {
        "parent_group_name": "HSBC - DEV (V-5A82MTA)",
        "contract_id": "V-5A82MTA",
        "group_id": "272095",
    },
}

# =============================================================================
# Helpers
# =============================================================================
def ensure_output_dir():
    os.makedirs("output", exist_ok=True)

def write_text(path: str, body: str):
    try:
        with open(path, "w", encoding="utf-8") as f:
            f.write(body)
    except Exception:
        pass

def write_json(path: str, obj):
    try:
        with open(path, "w", encoding="utf-8") as f:
            json.dump(obj, f, indent=2)
    except Exception:
        pass

def safe_json(resp):
    try:
        return resp.json()
    except Exception:
        return None

# =============================================================================
# Session
# =============================================================================
def setup_session(section: str):
    edgerc = os.path.join(expanduser("~"), ".edgerc")
    parser = ConfigParser()
    parser.read(edgerc)

    if not parser.has_section(section):
        print(f"[ERROR] Missing section [{section}] in {edgerc}")
        sys.exit(1)

    base_url = "https://" + parser.get(section, "host")

    s = Session()
    # Build auth explicitly from keys to support all installs
    s.auth = EdgeGridAuth(
        client_token=parser.get(section, "client_token"),
        client_secret=parser.get(section, "client_secret"),
        access_token=parser.get(section, "access_token"),
    )
    # sane defaults
    s.headers.update({
        "Content-Type": "application/json",
        "Accept": "application/json",
    })
    return s, base_url

# =============================================================================
# Lookups
# =============================================================================
def check_cps(session, base_url, fqdn, contract_id, debug=False):
    """
    Full match requires: the FQDN appears in CN or SANs of the enrollment.
    Partial if we see substring-y hints but not exact CN/SAN equality.
    """
    url = f"{base_url}/cps/v2/enrollments?contractId={contract_id}"
    print(f"[INFO] CPS lookup: {url}")

    result = {
        "found": False,
        "partial": False,
        "url": url,
        "matches": [],          # full matches
        "partial_matches": [],  # lightweight hints
    }

    try:
        # CPS needs the vendor Accept header to avoid 406
        headers = {
            "Accept": "application/vnd.akamai.cps.enrollments.v11+json",
            "Content-Type": "application/json",
        }
        resp = session.get(url, headers=headers, timeout=(10, 60))
        if debug:
            ensure_output_dir()
            write_text("output/cps_raw.json", resp.text)

        if resp.status_code != 200:
            print(f"[FAILURE] CPS API returned {resp.status_code}")
            return result

        data = safe_json(resp)
        if not isinstance(data, dict):
            print("[ERROR] CPS returned non-JSON or unexpected structure")
            return result

        fqdn_l = fqdn.lower()

        for enr in data.get("enrollments", []):
            csr = enr.get("csr") or {}
            cn = csr.get("cn")
            sans = csr.get("sans", []) if isinstance(csr.get("sans"), list) else []

            cn_l = cn.lower() if isinstance(cn, str) else None
            sans_l = [s.lower() for s in sans if isinstance(s, str)]

            full = (cn_l == fqdn_l) or (fqdn_l in sans_l)
            if full:
                result["matches"].append({
                    "id": enr.get("id"),
                    "cn": cn,
                    "networkType": (enr.get("networkConfiguration") or {}).get("networkType"),
                    "matchType": "full",
                })
                continue

            # partial – only if not full
            tokens = [t for t in ([cn_l] if cn_l else []) + sans_l]
            if any((t and fqdn_l in t) for t in tokens):
                result["partial_matches"].append({
                    "id": enr.get("id"),
                    "cn": cn,
                    "matchType": "partial",
                })

        result["found"] = len(result["matches"]) > 0
        result["partial"] = len(result["partial_matches"]) > 0 and not result["found"]
        print(f"[RESULT] CPS: {'FOUND' if result['found'] else ('PARTIAL MATCH' if result['partial'] else 'NOT FOUND')}")
        return result

    except Exception as e:
        print(f"[ERROR] CPS lookup failed: {e}")
        traceback.print_exc()
        return result


def check_appsec(session, base_url, fqdn, contract_id, group_id, access_group, debug=False):
    """
    Full match requires BOTH: FQDN appears in payload and access group appears in config name.
    Partial when exactly one of the conditions is observed.
    """
    url = f"{base_url}/appsec/v1/configs?contractId={contract_id}&groupId={group_id}"
    print(f"[INFO] AppSec lookup: {url}")

    result = {
        "found": False,
        "partial": False,
        "url": url,
        "matches": [],
        "partial_matches": [],
    }

    try:
        resp = session.get(url, timeout=(10, 60))
        if debug:
            ensure_output_dir()
            write_text("output/appsec_raw.json", resp.text)

        if resp.status_code != 200:
            print(f"[FAILURE] AppSec API returned {resp.status_code}")
            return result

        data = safe_json(resp)
        if not isinstance(data, dict):
            print("[ERROR] AppSec returned non-JSON or unexpected structure")
            return result

        fqdn_l = fqdn.lower()
        ag_l = access_group.lower()

        for cfg in data.get("configurations", []):
            name = (cfg.get("name") or "")
            name_l = name.lower()
            payload_l = json.dumps(cfg).lower()

            fqdn_hit = fqdn_l in payload_l    # fqdn anywhere in config payload
            ag_hit   = ag_l in name_l          # access group in name (per your rule)

            if fqdn_hit and ag_hit:
                result["matches"].append({
                    "id": cfg.get("id"),
                    "name": name,
                    "latestVersion": cfg.get("latestVersion"),
                    "stagingVersion": cfg.get("stagingVersion"),
                    "productionVersion": cfg.get("productionVersion"),
                    "targetProduct": cfg.get("targetProduct"),
                    "matchType": "full",
                })
            elif fqdn_hit or ag_hit:
                result["partial_matches"].append({
                    "id": cfg.get("id"),
                    "name": name,
                    "matchType": "partial",
                    "reason": "fqdn_only" if fqdn_hit else "access_group_only",
                })

        result["found"] = len(result["matches"]) > 0
        result["partial"] = len(result["partial_matches"]) > 0 and not result["found"]
        print(f"[RESULT] AppSec: {'FOUND' if result['found'] else ('PARTIAL MATCH' if result['partial'] else 'NOT FOUND')}")
        return result

    except Exception as e:
        print(f"[ERROR] AppSec lookup failed: {e}")
        traceback.print_exc()
        return result


def check_papi(session, base_url, fqdn, access_group, debug=False):
    """
    Full match in PAPI requires: cnameFrom == fqdn AND the propertyName contains the access group.
    Partial when we see exactly one of those conditions.
    """
    url = f"{base_url}/papi/v1/hostnames"
    print(f"[INFO] PAPI lookup: {url}")

    result = {
        "found": False,
        "partial": False,
        "url": url,
        "matches": [],
        "partial_matches": [],
    }

    try:
        resp = session.get(url, timeout=(10, 60))
        if debug:
            ensure_output_dir()
            write_text("output/papi_raw.json", resp.text)

        if resp.status_code != 200:
            print(f"[FAILURE] PAPI API returned {resp.status_code}")
            return result

        data = safe_json(resp)
        if data is None:
            print("[ERROR] PAPI returned non-JSON")
            return result

        fqdn_l = fqdn.lower()
        ag_l = access_group.lower()

        # hostnames list can be in "hostnames" or "items", sometimes a raw list
        if isinstance(data, dict):
            items = data.get("hostnames") or data.get("items") or []
        elif isinstance(data, list):
            items = data
        else:
            items = []

        for entry in items:
            if isinstance(entry, dict):
                cname_from = (entry.get("cnameFrom") or "")
                property_name = (entry.get("propertyName") or "")
            else:
                # fallback if entry is a scalar
                cname_from = str(entry)
                property_name = ""

            fqdn_hit = cname_from.lower() == fqdn_l
            ag_hit   = ag_l in property_name.lower()

            if fqdn_hit and ag_hit:
                result["matches"].append({
                    "propertyName": property_name,
                    "cnameFrom": cname_from,
                    "contractId": entry.get("contractId") if isinstance(entry, dict) else None,
                    "groupId": entry.get("groupId") if isinstance(entry, dict) else None,
                    "matchType": "full",
                })
            elif fqdn_hit or ag_hit:
                result["partial_matches"].append({
                    "propertyName": property_name,
                    "cnameFrom": cname_from,
                    "matchType": "partial",
                    "reason": "fqdn_only" if fqdn_hit else "access_group_only",
                })

        result["found"] = len(result["matches"]) > 0
        result["partial"] = len(result["partial_matches"]) > 0 and not result["found"]
        print(f"[RESULT] PAPI: {'FOUND' if result['found'] else ('PARTIAL MATCH' if result['partial'] else 'NOT FOUND')}")
        return result

    except Exception as e:
        print(f"[ERROR] PAPI lookup failed: {e}")
        traceback.print_exc()
        return result

# =============================================================================
# Main
# =============================================================================
def main():
    parser = argparse.ArgumentParser(description="Akamai Entitlement Validator")
    parser.add_argument("--section", required=True, help="Region / .edgerc section (e.g., DEV, APAC, EMEA, ...)")
    parser.add_argument("--fqdn", required=True, help="FQDN to validate")
    parser.add_argument("--access-group", required=True, help="Akamai Access Group name")
    parser.add_argument("--debug", action="store_true", help="Write raw API bodies and extra logs")
    args = parser.parse_args()

    section = args.section.strip()
    fqdn = args.fqdn.strip()
    access_group = args.access_group.strip()
    debug = args.debug

    print("\n==============================================================")
    print("             Akamai Entitlement Validator Suite")
    print("==============================================================")
    print(f"Section:      {section}")
    print(f"Access Group: {access_group}")
    print(f"FQDN:         {fqdn}")
    print(f"Debug Mode:   {'ON' if debug else 'OFF'}\n")

    region = REGION_SETTINGS.get(section)
    if not region:
        print(f"[ERROR] Invalid section '{section}'. Check REGION_SETTINGS.")
        return 1

    session, base_url = setup_session(section)
    ensure_output_dir()

    cps   = check_cps(session, base_url, fqdn, region["contract_id"], debug=debug)
    appsec = check_appsec(session, base_url, fqdn, region["contract_id"], region["group_id"], access_group, debug=debug)
    papi  = check_papi(session, base_url, fqdn, access_group, debug=debug)

    # Authorization only on FULL matches
    authorized = any(r["found"] for r in (cps, appsec, papi))

    # Build a readable “validated_by” that shows partial-only as “(partial)”
    validated_by = []
    for name, r in (("CPS", cps), ("AppSec", appsec), ("PAPI", papi)):
        if r["found"]:
            validated_by.append(name)
        elif r["partial"]:
            validated_by.append(f"{name} (partial)")

    summary = {
        "section": section,
        "access_group": access_group,
        "fqdn": fqdn,
        "cps": cps,
        "appsec": appsec,
        "papi": papi,
        "validated_by": validated_by,
        "authorized": authorized,
    }

    write_json("output/entitlement_summary.json", summary)

    print("--------------------------------------------------------------")
    if authorized:
        print("[SUMMARY] Validation Result: AUTHORIZED")
    elif any(r["partial"] for r in (cps, appsec, papi)):
        print("[SUMMARY] Validation Result: UNAUTHORIZED (PARTIAL MATCH DETECTED)")
    else:
        print("[SUMMARY] Validation Result: UNAUTHORIZED")
    print(f"[SUMMARY] Validated by: {', '.join(validated_by) if validated_by else 'None'}")
    print("--------------------------------------------------------------\n")
    print("[INFO] Summary written to output/entitlement_summary.json\n")

    return 0 if authorized else 1


if __name__ == "__main__":
    sys.exit(main())
