import re
import time
import requests

SEP = "—" * 68  # separator line


def reverse_fqdn_lookup(session, base_url, fqdn, access_group, debug=False):
    """
    Performs Akamai reverse lookup for a given FQDN and validates property name
    against the access group using normalized comparison rules.

    Returns:
        dict: {
            found: bool,
            groupId: str,
            propertyName: str,
            accessGroupName: str,
            strippedPropertyName: str,
            matchAccessGroup: bool,
            matchType: str ('full'|'partial'|'none')
        }
    """

    # ------------------------ helper functions ------------------------

    def get_group_name_by_id(sess, base, gid):
        """Resolve group name from groupId via PAPI."""
        if not gid:
            return None
        gid_clean = str(gid).replace("grp_", "")
        try:
            r = sess.get(f"{base}/papi/v1/groups",
                         headers={"accept": "application/json", "PAPI-Use-Prefixes": "true"},
                         timeout=20)
            if r.status_code == 200:
                data = r.json() or {}
                for g in (data.get("groups", {}).get("items", []) or []):
                    if str(g.get("groupId", "")).replace("grp_", "") == gid_clean:
                        return g.get("groupName")
        except Exception:
            pass
        return None

    def normalize_name(name: str) -> str:
        """
        Normalize property/access group name for comparison:
        - Lowercase
        - Remove leading 'sd-' (first 3 chars only)
        - Remove '-prod', '-nonprod', '-non-prod', '_prod', etc.
        - Remove all non-alphanumeric characters
        """
        if not name:
            return ""
        n = name.strip().lower()
        if n.startswith("sd-"):  # first 3 chars only
            n = n[3:]
        # remove any prod/nonprod variant at end
        n = re.sub(r"(-|_)?non[-_]?prod$", "", n)
        n = re.sub(r"(-|_)?prod$", "", n)
        # remove punctuation and spaces
        n = re.sub(r"[^a-z0-9]", "", n)
        return n

    def print_card(fqdn_disp, ag_disp, prop_disp, match_flag):
        """Clean and consistent formatted printout for each FQDN."""
        print(SEP)
        print(f"{'FQDN:':13} {fqdn_disp}")
        print(f"{'Access Group:':13} {ag_disp}")
        print(f"{'Property:':13} {prop_disp}")
        print(f"{'Match:':13} {'TRUE' if match_flag else 'FALSE'}")
        print(SEP)

    # ------------------------ setup ------------------------

    fqdn_l = fqdn.strip().lower()
    ag_display = access_group or ""
    ag_norm = normalize_name(ag_display)

    result = {
        "found": False,
        "groupId": None,
        "propertyName": None,
        "accessGroupName": None,
        "strippedPropertyName": None,
        "matchAccessGroup": False,
        "matchType": "none",
    }

    url = f"{base_url}/papi/v1/hostnames?search={fqdn_l}"
    if debug:
        print(f"\n[INFO] Performing reverse lookup for: {fqdn_l}")
        print(f"[DEBUG] PAPI URL: {url}")

    # ------------------------ API call with retry ------------------------
    for attempt in range(3):
        try:
            resp = session.get(
                url,
                headers={"accept": "application/json", "PAPI-Use-Prefixes": "true"},
                timeout=30,
            )
            break
        except requests.exceptions.RequestException as e:
            if attempt < 2:
                print(f"[WARN] Attempt {attempt + 1} failed: {e} — retrying...")
                time.sleep(2 ** attempt)
            else:
                print(f"[ERROR] Reverse lookup failed for {fqdn_l}: {e}")
                return result

    if resp.status_code != 200:
        print(f"[ERROR] HTTP {resp.status_code} during reverse lookup for {fqdn_l}")
        return result

    data = resp.json() or {}
    host_entries = (
        (data.get("items"))
        or (data.get("hostnames", {}).get("items") if isinstance(data.get("hostnames"), dict) else None)
        or (data.get("hostnames") if isinstance(data.get("hostnames"), list) else None)
        or []
    )

    if not host_entries:
        print_card(fqdn_l, ag_display, "<none>", False)
        return result

    # ------------------------ evaluate entries ------------------------
    for entry in host_entries:
        cname_from = str(entry.get("cnameFrom", "")).lower()
        cname_to = str(entry.get("stagingCnameTo", "")).lower()
        edge_host = str(entry.get("stagingEdgeHostnameId", "")).lower()

        if fqdn_l not in (cname_from, cname_to, edge_host) and fqdn_l not in cname_from:
            continue

        property_name = entry.get("propertyName") or ""
        prop_norm = normalize_name(property_name)
        match_flag = (prop_norm == ag_norm)

        group_id = entry.get("groupId")
        ag_name_from_id = get_group_name_by_id(session, base_url, group_id)

        result.update({
            "found": True,
            "groupId": group_id,
            "propertyName": property_name,
            "accessGroupName": ag_name_from_id,
            "strippedPropertyName": prop_norm,
            "matchAccessGroup": match_flag,
            "matchType": "full" if match_flag else "partial",
        })

        print_card(fqdn_l, ag_display, property_name, match_flag)

        if match_flag:  # stop on first TRUE
            return result

    # If we got here: no matches were TRUE
    return result
