import re
import time
import requests

SEP = "—" * 68

def reverse_fqdn_lookup(session, base_url, fqdn, access_group, debug=False):
    """
    Robust Akamai reverse lookup and property/access-group matcher.
    """

    # ---------------- helpers ----------------
    def get_group_name_by_id(sess, base, gid):
        """Resolve group name from ID."""
        if not gid:
            return None
        gid_clean = str(gid).replace("grp_", "")
        try:
            r = sess.get(f"{base}/papi/v1/groups",
                         headers={"accept": "application/json", "PAPI-Use-Prefixes": "true"},
                         timeout=20)
            if r.status_code == 200:
                for g in (r.json().get("groups", {}).get("items", []) or []):
                    if str(g.get("groupId", "")).replace("grp_", "") == gid_clean:
                        return g.get("groupName")
        except Exception:
            pass
        return None

    def normalize_name(name: str) -> str:
        """Lowercase, strip prefix/suffix, remove non-alphanumerics."""
        if not name:
            return ""
        n = name.strip().lower()
        if n.startswith("sd-"):  # only first 3 chars
            n = n[3:]
        if n.endswith("-nonprod"):
            n = n[:-8]
        elif n.endswith("-prod"):
            n = n[:-4]
        n = re.sub(r"[^a-z0-9]", "", n)
        return n

    def print_card(fqdn, ag, prop, match):
        print(SEP)
        print(f"{'FQDN:':13} {fqdn}")
        print(f"{'Access Group:':13} {ag}")
        print(f"{'Property:':13} {prop}")
        print(f"{'Match:':13} {'TRUE' if match else 'FALSE'}")
        print(SEP)

    # ---------------- setup ----------------
    fqdn = fqdn.strip().lower()
    ag_display = access_group or ""
    ag_norm = normalize_name(ag_display)

    result = {
        "found": False,
        "groupId": None,
        "propertyName": None,
        "accessGroupName": None,
        "strippedPropertyName": None,
        "matchAccessGroup": False,
        "matchType": "none",
    }

    url = f"{base_url}/papi/v1/hostnames?search={fqdn}"
    if debug:
        print(f"\n[INFO] Reverse lookup: {url}")

    # ---------------- API call ----------------
    for attempt in range(3):
        try:
            resp = session.get(
                url,
                headers={"accept": "application/json", "PAPI-Use-Prefixes": "true"},
                timeout=30
            )
            break
        except requests.exceptions.RequestException as e:
            if attempt < 2:
                if debug:
                    print(f"[WARN] Attempt {attempt+1} failed ({e}), retrying...")
                time.sleep(2 ** attempt)
            else:
                print(f"[ERROR] Failed after 3 retries: {e}")
                return result

    if resp.status_code != 200:
        print(f"[ERROR] HTTP {resp.status_code} for {fqdn}")
        return result

    data = resp.json() or {}
    host_entries = (
        (data.get("items"))
        or (data.get("hostnames", {}).get("items") if isinstance(data.get("hostnames"), dict) else None)
        or (data.get("hostnames") if isinstance(data.get("hostnames"), list) else None)
        or []
    )

    if not host_entries:
        print_card(fqdn, ag_display, "<none>", False)
        return result

    # ---------------- find match ----------------
    match_found = False
    for entry in host_entries:
        cname_from = str(entry.get("cnameFrom", "")).lower()
        cname_to = str(entry.get("stagingCnameTo", "")).lower()
        edge_host = str(entry.get("stagingEdgeHostnameId", "")).lower()

        if fqdn not in (cname_from, cname_to, edge_host) and fqdn not in cname_from:
            continue

        property_name = entry.get("propertyName") or ""
        prop_norm = normalize_name(property_name)
        match_flag = (prop_norm == ag_norm)

        if match_flag:
            # full hit, stop immediately
            group_id = entry.get("groupId")
            ag_name_from_id = get_group_name_by_id(session, base_url, group_id)
            result.update({
                "found": True,
                "groupId": group_id,
                "propertyName": property_name,
                "accessGroupName": ag_name_from_id,
                "strippedPropertyName": prop_norm,
                "matchAccessGroup": True,
                "matchType": "full",
            })
            print_card(fqdn, ag_display, property_name, True)
            return result

    # if we reach here — no matches, but property entries exist
    print_card(fqdn, ag_display, property_name, False)
    result.update({
        "found": True,
        "propertyName": property_name,
        "strippedPropertyName": prop_norm,
        "matchAccessGroup": False,
        "matchType": "partial",
    })
    return result
