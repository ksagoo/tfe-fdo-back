# ---- Reverse FQDN Lookup ----
csv_data = []

if args.all_fqdns:
    fqdn_list = get_all_fqdns(session, base_url, fqdn, debug=args.debug)
    print(f"[INFO] Retrieved {len(fqdn_list)} FQDNs from PAPI.")
    print(f"[INFO] Running reverse lookup for {len(fqdn_list)} FQDNs...\n")

    seen_fqdns = set()
    for fqdn_item in sorted(fqdn_list):
        if fqdn_item.lower() in seen_fqdns:
            continue
        seen_fqdns.add(fqdn_item.lower())

        reverse_result = reverse_fqdn_lookup(session, base_url, fqdn_item, access_group, debug=args.debug)
        csv_data.append(reverse_result)

else:
    reverse_result = reverse_fqdn_lookup(session, base_url, fqdn, access_group, debug=args.debug)
    csv_data.append(reverse_result)

import re
import requests
import time

def reverse_fqdn_lookup(session, base_url, fqdn, access_group, debug=False):
    """
    Robust Akamai PAPI reverse FQDN lookup and property/access-group matcher.

    Features:
    - Lowercases both access_group and property_name
    - Removes 'sd-' prefix (first 3 chars only)
    - Removes '-prod' or '-nonprod' suffix
    - Strips all non-alphanumeric characters for robust comparison
    - Outputs aligned, clean console output
    """

    def get_group_name_by_id(sess, base, gid):
        """Fetch group name for given groupId."""
        try:
            r = sess.get(f"{base}/papi/v1/groups",
                         headers={"accept": "application/json", "PAPI-Use-Prefixes": "true"},
                         timeout=20)
            if r.status_code == 200:
                data = r.json() or {}
                items = (data.get("groups") or {}).get("items", [])
                for g in items:
                    if g.get("groupId", "").replace("grp_", "") == (gid or "").replace("grp_", ""):
                        return g.get("groupName") or None
        except Exception:
            pass
        try:
            r = sess.get(f"{base}/identity-management/v3/user-admin/groups",
                         headers={"accept": "application/json"}, timeout=20)
            if r.status_code == 200:
                for g in (r.json() or []):
                    gid2 = str(g.get("groupId") or g.get("id") or "")
                    if gid2.replace("grp_", "") == (gid or "").replace("grp_", ""):
                        return g.get("groupName") or g.get("name") or None
        except Exception:
            pass
        return None

    def normalize_name(name):
        """Normalize name: lowercase, remove sd-, remove -prod/-nonprod, strip punctuation."""
        if not name:
            return ""
        n = name.strip().lower()
        if n.startswith("sd-"):
            n = n[3:]  # remove first 3 chars only
        if n.endswith("-nonprod"):
            n = n[:-8]
        elif n.endswith("-prod"):
            n = n[:-4]
        n = re.sub(r'[^a-z0-9]', '', n)
        return n

    # --- Initialize result ---
    result = {
        "found": False,
        "groupId": None,
        "propertyName": None,
        "accessGroupName": None,
        "strippedPropertyName": None,
        "matchAccessGroup": None,
        "matchType": "none",
    }

    fqdn = (fqdn or "").strip().lower()
    access_group_l = normalize_name(access_group)

    # --- API call ---
    url = f"{base_url}/papi/v1/hostnames?search={fqdn}"
    if debug:
        print("\n==== Starting Reverse FQDN Lookup ====")
        print(f"[INFO] Performing PAPI reverse lookup: {url}")

    for attempt in range(3):
        try:
            resp = session.get(url, headers={"accept": "application/json", "PAPI-Use-Prefixes": "true"}, timeout=30)
            break
        except requests.exceptions.RequestException as e:
            if attempt < 2:
                if debug:
                    print(f"[WARN] Request failed ({e}), retrying...")
                time.sleep(2 ** attempt)
            else:
                print(f"[ERROR] Reverse lookup failed after retries: {e}")
                return result

    if resp.status_code != 200:
        print(f"[ERROR] Reverse lookup failed: HTTP {resp.status_code}")
        return result

    data = resp.json() or {}
    host_entries = []

    if isinstance(data, list):
        host_entries = data
    elif isinstance(data, dict):
        if "items" in data:
            host_entries = data["items"] or []
        elif "hostnames" in data:
            hn = data["hostnames"]
            if isinstance(hn, dict) and "items" in hn:
                host_entries = hn["items"] or []
            elif isinstance(hn, list):
                host_entries = hn

    if not host_entries:
        if debug:
            print(f"[WARN] No hostnames found for {fqdn}")
        return result

    # --- Find full or partial hit ---
    full_hit = None
    partial_hit = None
    for entry in host_entries:
        if not isinstance(entry, dict):
            continue
        cname_from = str(entry.get("cnameFrom", "")).lower()
        cname_to = str(entry.get("stagingCnameTo", "")).lower()
        edge_host = str(entry.get("stagingEdgeHostnameId", "")).lower()

        if fqdn in (cname_from, cname_to, edge_host):
            full_hit = entry
            break
        if fqdn in cname_from or fqdn in cname_to:
            partial_hit = partial_hit or entry

    hit = full_hit or partial_hit
    if not hit:
        if debug:
            print(f"[WARN] No matching entry found for {fqdn}")
        return result

    # --- Normalize property and compare ---
    group_id = hit.get("groupId") or None
    property_name = hit.get("propertyName") or ""
    prop_normalized = normalize_name(property_name)
    access_group_name = get_group_name_by_id(session, base_url, group_id)
    match_flag = (prop_normalized == access_group_l)

    # --- Update result ---
    result.update({
        "found": True,
        "groupId": group_id,
        "propertyName": property_name,
        "accessGroupName": access_group_name,
        "strippedPropertyName": prop_normalized,
        "matchAccessGroup": match_flag,
        "matchType": "full" if full_hit else "partial",
    })

    # --- Aligned console output ---
    print("\n" + "=" * 70)
    print(f"{'FQDN:':20} {fqdn}")
    print(f"{'Access Group:':20} {access_group}")
    print(f"{'Property:':20} {property_name}")
    print(f"{'Match:':20} {'TRUE' if match_flag else 'FALSE'}")
    print("=" * 70)

    if debug:
        print(f"[DEBUG] Normalized Property:     {prop_normalized}")
        print(f"[DEBUG] Normalized Access Group: {access_group_l}")
        print(f"[DEBUG] Match Type:              {'FULL' if full_hit else 'PARTIAL'}")
        print(f"[DEBUG] Group ID:                {group_id} ({access_group_name or 'UNKNOWN'})")

    return result
