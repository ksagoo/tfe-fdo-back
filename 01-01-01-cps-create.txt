#!/usr/bin/env python3
# ------------------------------------------------------------------------
# Akamai Reverse Entitlement Lookup | Multi-FQDN Access Group Resolver
# ------------------------------------------------------------------------
#
# Description:
#   Given one or more Fully Qualified Domain Names (FQDNs), this script
#   queries Akamai APIs (CPS, AppSec, and PAPI) to determine which Access
#   Group(s) authorize each FQDN. It is designed to integrate with
#   discovery and certificate renewal pipelines such as Jenkins or
#   ServiceNow automation.
#
# Features:
#   • Accepts multiple --fqdn flags
#   • Returns structured JSON output for CI/CD pipelines
#   • Includes --dry_run and --debug modes
#   • Supports configurable environment section (--section)
#   • Compatible with EdgeGrid authentication (.edgerc)
#
# Usage Examples:
#   Live Lookup:
#       python akamai_reverse_entitlement_lookup.py \
#           --section PROD \
#           --fqdn app1.hsbc.com \
#           --fqdn app2.hsbc.co.uk
#
#   Dry Run Simulation:
#       python akamai_reverse_entitlement_lookup.py \
#           --fqdn app1.hsbc.com --dry_run
#
#   Debug Mode (show full API URLs and verbose output):
#       python akamai_reverse_entitlement_lookup.py \
#           --section DEV --fqdn testapp.dev.hsbc.com --debug
#
#   Export Results to JSON (for Jenkins use):
#       python akamai_reverse_entitlement_lookup.py \
#           --section PROD \
#           --fqdn app1.hsbc.com \
#           --fqdn app2.hsbc.co.uk \
#           --output entitlement_map.json
#
# Example Output:
#   {
#       "app1.hsbc.com": ["AppSec-EMEA-Prod", "CPS-Prod-Certs"],
#       "app2.hsbc.co.uk": ["AppSec-UK-Prod"]
#   }
#
# ------------------------------------------------------------------------

import argparse
import json
import sys
from akamai.edgegrid import EdgeGridAuth
import requests
from urllib.parse import urlencode
from requests.sessions import Session

# ------------------------------------------------------------------------
# EdgeGrid Session Setup
# ------------------------------------------------------------------------
def setup_session(section):
    """Initialise EdgeGrid authenticated session for given section."""
    try:
        from akamai.edgegrid import EdgeGridAuth
        from configparser import ConfigParser
        import os

        edgerc_path = os.path.expanduser("~/.edgerc")
        config = ConfigParser()
        config.read(edgerc_path)
        if section not in config:
            print(f"[Error] Section '{section}' not found in {edgerc_path}")
            sys.exit(1)

        base_url = config.get(section, "host", fallback=None)
        client_token = config.get(section, "client_token", fallback=None)
        client_secret = config.get(section, "client_secret", fallback=None)
        access_token = config.get(section, "access_token", fallback=None)

        if not all([base_url, client_token, client_secret, access_token]):
            print(f"[Error] Missing credentials in .edgerc for section {section}")
            sys.exit(1)

        session = Session()
        session.auth = EdgeGridAuth(
            client_token=client_token,
            client_secret=client_secret,
            access_token=access_token
        )
        session.headers.update({"Content-Type": "application/json"})
        session.base_url = f"https://{base_url}"
        return session

    except Exception as e:
        print(f"[Error] Failed to initialize EdgeGrid session: {e}")
        sys.exit(1)

# ------------------------------------------------------------------------
# Lookup Function (Mock/Example Implementation)
# ------------------------------------------------------------------------
def lookup_access_groups(session, fqdn, section, debug=False):
    """
    Query Akamai APIs (PAPI/AppSec/CPS) to identify which Access Group(s)
    authorize the given FQDN.
    """
    # Placeholder API endpoints for demonstration
    papi_endpoint = f"{session.base_url}/papi/v1/search/find-by-value?value={fqdn}"
    cps_endpoint = f"{session.base_url}/cps/v2/certificates?commonName={fqdn}"
    appsec_endpoint = f"{session.base_url}/appsec/v1/configs?hostname={fqdn}"

    access_groups = set()

    try:
        for api_url, label in [
            (papi_endpoint, "PAPI"),
            (cps_endpoint, "CPS"),
            (appsec_endpoint, "AppSec"),
        ]:
            if debug:
                print(f"[DEBUG] Querying {label}: {api_url}")

            resp = session.get(api_url, timeout=10)
            if resp.status_code == 200:
                data = resp.json()
                if isinstance(data, dict):
                    for key in ["accessGroupName", "groupName", "name"]:
                        if key in data:
                            access_groups.add(data[key])
                    # Demo extraction for nested JSON
                    for item in data.get("items", []):
                        if "accessGroupName" in item:
                            access_groups.add(item["accessGroupName"])
            elif debug:
                print(f"[DEBUG] {label} returned HTTP {resp.status_code}")

    except Exception as e:
        if debug:
            print(f"[DEBUG] Error querying APIs for {fqdn}: {e}")

    return sorted(list(access_groups)) or ["No-Matching-Access-Group"]

# ------------------------------------------------------------------------
# Main Entry
# ------------------------------------------------------------------------
def main():
    parser = argparse.ArgumentParser(
        description="Reverse lookup Akamai Access Group(s) for one or more FQDNs.",
        formatter_class=argparse.RawTextHelpFormatter,
    )
    parser.add_argument("--fqdn", action="append", required=True,
                        help="One or more Fully Qualified Domain Names (FQDNs) to lookup.")
    parser.add_argument("--section", required=False, default="default",
                        help="EdgeGrid section name in ~/.edgerc (e.g., PROD, DEV). Default: 'default'.")
    parser.add_argument("--output", help="Optional path to save JSON output.")
    parser.add_argument("--debug", action="store_true", help="Enable verbose debug output.")
    parser.add_argument("--dry_run", action="store_true", help="Simulate response only (no live API calls).")

    args = parser.parse_args()

    results = {}
    session = None if args.dry_run else setup_session(args.section)

    for fqdn in args.fqdn:
        if args.dry_run:
            print(f"[Dry Run] Simulating lookup for {fqdn}")
            results[fqdn] = ["Simulated-Access-Group"]
        else:
            access_groups = lookup_access_groups(session, fqdn, args.section, debug=args.debug)
            results[fqdn] = access_groups

    # --------------------------------------------------------------------
    # Output Formatting
    # --------------------------------------------------------------------
    if args.output:
        with open(args.output, "w") as f:
            json.dump(results, f, indent=4)
        print(f"[INFO] JSON output saved: {args.output}")
    else:
        print(json.dumps(results, indent=4))

# ------------------------------------------------------------------------
if __name__ == "__main__":
    main()
