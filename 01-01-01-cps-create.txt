#!/usr/bin/env python3
import sys
import json
import argparse
import os
import requests
from akamai.edgegrid import EdgeGridAuth
from requests.sessions import Session
from datetime import datetime

# =============================================================================
# Region Mappings
# =============================================================================
REGION_SETTINGS = {
    "Global": {
        "parent_group_name": "HSBC-DDoS-KSD-D-2YN4YRH",
        "contract_id": "P-2YN4YRH",
        "group_id": "154041",
    },
    "APAC": {
        "parent_group_name": "HSBC - APAC-V-5A82LRN",
        "contract_id": "V-5A82LRN",
        "group_id": "272084",
    },
    "EMEA": {
        "parent_group_name": "HSBC - EMEA-V-5A82MHB",
        "contract_id": "V-5A82MHB",
        "group_id": "272093",
    },
    "LATAM": {
        "parent_group_name": "HSBC-AMER -LATAM(V-5A854K9)",
        "contract_id": "V-5A854K9",
        "group_id": "272094",
    },
    "AMER": {
        "parent_group_name": "HSBC-AMER -LATAM(V-5A854K9)",
        "contract_id": "V-5A854K9",
        "group_id": "272094",
    },
    "DEV": {
        "parent_group_name": "HSBC - DEV (V-5A82MTA)",
        "contract_id": "V-5A82MTA",
        "group_id": "272095",
    },
}

# =============================================================================
# Setup Akamai Session
# =============================================================================
def setup_session(section: str) -> Session:
    import configparser

    edgerc_path = os.path.expanduser("~/.edgerc")
    config = configparser.ConfigParser()
    config.read(edgerc_path)

    if section not in config:
        print(f"[ERROR] Section '{section}' not found in {edgerc_path}")
        sys.exit(1)

    base_url = f"https://{config[section]['host']}"
    session = Session()
    session.auth = EdgeGridAuth.from_edgerc(config, section)
    return session, base_url


# =============================================================================
# Core Lookup Functions
# =============================================================================
def safe_json(response):
    """Safely parse JSON responses and handle invalid content."""
    try:
        return response.json()
    except Exception:
        print("[ERROR] Invalid JSON response received")
        return {}

def check_cps(session, base_url, fqdn, contract_id):
    url = f"{base_url}/cps/v2/enrollments?contractId={contract_id}"
    print(f"[INFO] CPS lookup: {url}")
    try:
        response = session.get(url)
        print(f"[DEBUG] CPS HTTP status: {response.status_code}")
        data = safe_json(response)
        matches, partial = [], False

        for e in data.get("enrollments", []):
            csr = e.get("csr") or {}
            cn = csr.get("cn")
            sans = csr.get("sans", [])
            if fqdn == cn or fqdn in sans:
                matches.append({
                    "id": e.get("id"),
                    "cn": cn,
                    "networkType": e.get("networkConfiguration", {}).get("networkType"),
                    "matchType": "full"
                })
            elif any(fqdn in s for s in ([cn] if isinstance(cn, str) else []) + sans if isinstance(s, str)):
                partial = True

        if matches:
            print(f"[RESULT] CPS: FOUND {len(matches)} match(es)")
            for m in matches:
                print(f"         → ID {m['id']} | CN: {m['cn']} | Type: {m.get('networkType')}")
        elif partial:
            print("[RESULT] CPS: PARTIAL MATCH")
        else:
            print("[RESULT] CPS: NOT FOUND")

        return {"found": bool(matches), "partial": partial, "url": url, "matches": matches, "raw": data}

    except Exception as e:
        print(f"[ERROR] CPS lookup failed: {e}")
        return {"found": False, "partial": False, "url": url, "matches": [], "raw": {}}


def check_appsec(session, base_url, fqdn, contract_id, group_id, access_group):
    url = f"{base_url}/appsec/v1/configs?contractId={contract_id}&groupId={group_id}"
    print(f"[INFO] AppSec lookup: {url}")
    try:
        response = session.get(url)
        print(f"[DEBUG] AppSec HTTP status: {response.status_code}")
        data = safe_json(response)
        matches, partial = [], False

        for c in data.get("configurations", []):
            name = c.get("name", "")
            if fqdn in name and access_group in name:
                matches.append({"id": c.get("id"), "name": name, "matchType": "full"})
            elif fqdn in name or access_group in name:
                partial = True

        if matches:
            print(f"[RESULT] AppSec: FOUND {len(matches)} match(es)")
            for m in matches:
                print(f"         → ID {m['id']} | Name: {m['name']}")
        elif partial:
            print("[RESULT] AppSec: PARTIAL MATCH")
        else:
            print("[RESULT] AppSec: NOT FOUND")

        return {"found": bool(matches), "partial": partial, "url": url, "matches": matches, "raw": data}

    except Exception as e:
        print(f"[ERROR] AppSec lookup failed: {e}")
        return {"found": False, "partial": False, "url": url, "matches": [], "raw": {}}


def check_papi(session, base_url, fqdn):
    url = f"{base_url}/papi/v1/hostnames"
    print(f"[INFO] PAPI lookup: {url}")
    try:
        response = session.get(url)
        print(f"[DEBUG] PAPI HTTP status: {response.status_code}")
        data = safe_json(response)
        matches, partial = [], False

        host_list = []
        if isinstance(data, dict):
            host_list = data.get("hostnames") or data.get("items") or []
        elif isinstance(data, list):
            host_list = data

        for h in host_list:
            hostname = h.get("cnameFrom") if isinstance(h, dict) else h
            if fqdn == hostname:
                matches.append(h if isinstance(h, dict) else {"cnameFrom": hostname, "matchType": "full"})
            elif fqdn in str(hostname):
                partial = True

        if matches:
            print(f"[RESULT] PAPI: FOUND {len(matches)} match(es)")
            for m in matches:
                cname = m.get("cnameFrom", "")
                prop = m.get("propertyName", "")
                print(f"         → CNAME: {cname} | Property: {prop}")
        elif partial:
            print("[RESULT] PAPI: PARTIAL MATCH")
        else:
            print("[RESULT] PAPI: NOT FOUND")

        return {"found": bool(matches), "partial": partial, "url": url, "matches": matches, "raw": data}

    except Exception as e:
        print(f"[ERROR] PAPI lookup failed: {e}")
        return {"found": False, "partial": False, "url": url, "matches": [], "raw": {}}


# =============================================================================
# Main Logic
# =============================================================================
def main():
    parser = argparse.ArgumentParser(description="Akamai Entitlement Validator")
    parser.add_argument("--section", required=True, help="Section / Region name (e.g., DEV, APAC)")
    parser.add_argument("--fqdn", required=True, help="Fully qualified domain name")
    parser.add_argument("--access-group", required=True, help="Access group name")
    parser.add_argument("--debug", action="store_true", help="Enable debug output")
    args = parser.parse_args()

    section = args.section.upper()
    fqdn = args.fqdn.strip()
    access_group = args.access_group.strip()
    debug = args.debug

    print("\n==============================================================")
    print("             Akamai Entitlement Validator Suite")
    print("==============================================================")
    print(f"Section:      {section}")
    print(f"Access Group: {access_group}")
    print(f"FQDN:         {fqdn}")
    print(f"Debug Mode:   {'ON' if debug else 'OFF'}\n")

    if section not in REGION_SETTINGS:
        print(f"[ERROR] Invalid section '{section}'. Check REGION_SETTINGS.")
        sys.exit(1)

    region = REGION_SETTINGS[section]
    session, base_url = setup_session(section)

    cps = check_cps(session, base_url, fqdn, region["contract_id"])
    appsec = check_appsec(session, base_url, fqdn, region["contract_id"], region["group_id"], access_group)
    papi = check_papi(session, base_url, fqdn)

    authorized = cps["found"] or appsec["found"] or papi["found"]
    validated_by = [x for x, y in zip(["CPS", "AppSec", "PAPI"], [cps, appsec, papi]) if y["found"] or y["partial"]]

    summary = {
        "section": section,
        "access_group": access_group,
        "fqdn": fqdn,
        "cps": {k: v for k, v in cps.items() if k != "raw"},
        "appsec": {k: v for k, v in appsec.items() if k != "raw"},
        "papi": {k: v for k, v in papi.items() if k != "raw"},
        "validated_by": validated_by,
        "authorized": authorized,
    }

    os.makedirs("output", exist_ok=True)
    timestamp = datetime.utcnow().strftime("%Y%m%d_%H%M%S")

    summary_path = f"output/entitlement_summary.json"
    with open(summary_path, "w") as f:
        json.dump(summary, f, indent=2)

    print("\n--------------------------------------------------------------")
    if authorized:
        print("[SUMMARY] Validation Result: AUTHORIZED")
    elif any([cps["partial"], appsec["partial"], papi["partial"]]):
        print("[SUMMARY] Validation Result: UNAUTHORIZED (PARTIAL MATCH DETECTED)")
    else:
        print("[SUMMARY] Validation Result: UNAUTHORIZED")
    print(f"[SUMMARY] Validated by: {', '.join(validated_by) if validated_by else 'None'}")
    print("--------------------------------------------------------------\n")
    print(f"[INFO] Summary written to {summary_path}\n")

    if debug:
        debug_files = {
            "cps": f"output/raw_cps_{timestamp}.json",
            "appsec": f"output/raw_appsec_{timestamp}.json",
            "papi": f"output/raw_papi_{timestamp}.json",
        }
        for name, path in debug_files.items():
            with open(path, "w") as f:
                json.dump(locals()[name]["raw"], f, indent=2)
            print(f"[DEBUG] Raw {name.upper()} data written to {path}")
        print()


if __name__ == "__main__":
    main()
