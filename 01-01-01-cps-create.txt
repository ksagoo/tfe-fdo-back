#!/usr/bin/env python3
"""
Akamai Entitlement Validator Suite
----------------------------------
Validates whether an FQDN and access group have existing entitlements in:
- CPS (Certificates)
- AppSec (Security Configurations)
- PAPI (Property Hostnames)
"""

import sys
import json
import argparse
import os
import re
import traceback
from requests.sessions import Session
from akamai.edgegrid import EdgeGridAuth
from configparser import ConfigParser
from os.path import expanduser

# =============================================================================
# Region Mappings
# =============================================================================
REGION_SETTINGS = {
    "GLOBAL": {"contract_id": "P-2YN4YRH", "group_id": "154041"},
    "APAC": {"contract_id": "V-5A82LRN", "group_id": "272084"},
    "EMEA": {"contract_id": "V-5A82MHB", "group_id": "272093"},
    "LATAM": {"contract_id": "V-5A854K9", "group_id": "272094"},
    "AMER": {"contract_id": "V-5A854K9", "group_id": "272094"},
    "DEV": {"contract_id": "V-5A82MTA", "group_id": "272095"},
}

# =============================================================================
# Session Setup
# =============================================================================
def setup_session(section: str):
    edgerc = os.path.join(expanduser("~"), ".edgerc")
    parser = ConfigParser()
    parser.read(edgerc)

    if not parser.has_section(section):
        print(f"[ERROR] Missing section [{section}] in {edgerc}")
        sys.exit(1)

    base_url = f"https://{parser.get(section, 'host')}"
    session = Session()
    session.auth = EdgeGridAuth(
        client_token=parser.get(section, "client_token"),
        client_secret=parser.get(section, "client_secret"),
        access_token=parser.get(section, "access_token"),
    )
    session.headers.update({"Accept": "application/json", "Content-Type": "application/json"})
    return session, base_url


# =============================================================================
# Utilities
# =============================================================================
def safe_json(response):
    try:
        return response.json()
    except Exception:
        print("[WARN] Invalid JSON received.")
        return {}


def write_json(data, filename):
    os.makedirs("output", exist_ok=True)
    with open(filename, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=2)


def sanitize_filename(name: str) -> str:
    return re.sub(r"[^A-Za-z0-9_-]+", "_", name)


# =============================================================================
# CPS Lookup
# =============================================================================
def check_cps(session, base_url, fqdn, contract_id, debug=False):
    url = f"{base_url}/cps/v2/enrollments?contractId={contract_id}"
    print(f"[INFO] CPS lookup: {url}")
    matches, partials = [], []

    try:
        # Proper CPS headers
        resp = session.get(
            url,
            headers={
                "Accept": "application/vnd.akamai.cps.enrollments.v11+json",
                "Content-Type": "application/json"
            },
            timeout=(10, 60)
        )
        data = safe_json(resp)
        if debug:
            write_json(data, f"output/raw_cps_{sanitize_filename(fqdn)}.json")

        for enr in data.get("enrollments", []):
            cn = enr.get("csr", {}).get("cn", "")
            sans = enr.get("csr", {}).get("sans", [])
            all_names = [cn] + sans

            if fqdn in all_names:
                matches.append({
                    "id": enr.get("id"),
                    "cn": cn,
                    "matchType": "full",
                })
            elif any(fqdn in n for n in all_names if isinstance(n, str)):
                partials.append({
                    "id": enr.get("id"),
                    "cn": cn,
                    "matchType": "partial",
                    "reason": "substring_match"
                })

        result = {
            "found": bool(matches),
            "partial": bool(partials) and not matches,
            "url": url,
            "matches": matches,
            "partial_matches": partials
        }

        print(f"[RESULT] CPS: {'FOUND' if result['found'] else ('PARTIAL MATCH' if result['partial'] else 'NOT FOUND')}")
        return result

    except Exception as e:
        print(f"[ERROR] CPS lookup failed: {e}")
        if debug:
            traceback.print_exc()
        return {"found": False, "partial": False, "url": url, "matches": [], "partial_matches": []}


# =============================================================================
# AppSec Lookup
# =============================================================================
def check_appsec(session, base_url, fqdn, contract_id, group_id, access_group, debug=False):
    url = f"{base_url}/appsec/v1/configs?contractId={contract_id}&groupId={group_id}"
    print(f"[INFO] AppSec lookup: {url}")
    matches, partials = [], []

    try:
        resp = session.get(url, timeout=(10, 60))
        data = safe_json(resp)
        if debug:
            write_json(data, f"output/raw_appsec_{sanitize_filename(fqdn)}.json")

        fqdn_lower = fqdn.lower()
        ag_lower = access_group.lower()

        for cfg in data.get("configurations", []):
            name = cfg.get("name", "").lower()
            cfg_id = cfg.get("id")

            fqdn_match = fqdn_lower in name
            ag_match = ag_lower in name

            if fqdn_match and ag_match:
                matches.append({
                    "id": cfg_id,
                    "name": cfg.get("name"),
                    "matchType": "full"
                })
            elif fqdn_match or ag_match:
                reason = "fqdn_only" if fqdn_match else "access_group_only"
                partials.append({
                    "id": cfg_id,
                    "name": cfg.get("name"),
                    "matchType": "partial",
                    "reason": reason
                })

        result = {
            "found": bool(matches),
            "partial": bool(partials) and not matches,
            "url": url,
            "matches": matches,
            "partial_matches": partials
        }

        print(f"[RESULT] AppSec: {'FOUND' if result['found'] else ('PARTIAL MATCH' if result['partial'] else 'NOT FOUND')}")
        return result

    except Exception as e:
        print(f"[ERROR] AppSec lookup failed: {e}")
        if debug:
            traceback.print_exc()
        return {"found": False, "partial": False, "url": url, "matches": [], "partial_matches": []}


# =============================================================================
# PAPI Lookup
# =============================================================================
def check_papi(session, base_url, fqdn, access_group, debug=False):
    url = f"{base_url}/papi/v1/hostnames"
    print(f"[INFO] PAPI lookup: {url}")
    matches, partials = [], []

    try:
        resp = session.get(url, timeout=(10, 60))
        data = safe_json(resp)
        if debug:
            write_json(data, f"output/raw_papi_{sanitize_filename(fqdn)}.json")

        fqdn_lower = fqdn.lower()
        ag_lower = access_group.lower()

        # Handle both dicts and strings
        raw_hosts = data.get("hostnames") or data.get("items") or []
        hostnames = []
        for h in raw_hosts:
            if isinstance(h, str):
                hostnames.append({"cnameFrom": h, "propertyName": ""})
            elif isinstance(h, dict):
                hostnames.append(h)

        for h in hostnames:
            cname = h.get("cnameFrom", "").lower()
            prop_name = h.get("propertyName", "").lower()

            fqdn_match = fqdn_lower in cname
            ag_match = ag_lower in prop_name

            if fqdn_match and ag_match:
                matches.append({
                    "propertyName": h.get("propertyName"),
                    "cnameFrom": h.get("cnameFrom"),
                    "matchType": "full"
                })
            elif fqdn_match or ag_match:
                reason = "fqdn_or_access_group_only"
                partials.append({
                    "propertyName": h.get("propertyName"),
                    "cnameFrom": h.get("cnameFrom"),
                    "matchType": "partial",
                    "reason": reason
                })

        result = {
            "found": bool(matches),
            "partial": bool(partials) and not matches,
            "url": url,
            "matches": matches,
            "partial_matches": partials
        }

        print(f"[RESULT] PAPI: {'FOUND' if result['found'] else ('PARTIAL MATCH' if result['partial'] else 'NOT FOUND')}")
        return result

    except Exception as e:
        print(f"[ERROR] PAPI lookup failed: {e}")
        if debug:
            traceback.print_exc()
        return {"found": False, "partial": False, "url": url, "matches": [], "partial_matches": []}


# =============================================================================
# Main Logic
# =============================================================================
def main():
    parser = argparse.ArgumentParser(description="Akamai Entitlement Validator")
    parser.add_argument("--section", required=True)
    parser.add_argument("--fqdn", required=True)
    parser.add_argument("--access-group", required=True)
    parser.add_argument("--debug", action="store_true")
    args = parser.parse_args()

    section = args.section.upper()
    fqdn = args.fqdn.strip()
    access_group = args.access_group.strip()
    debug = args.debug

    print("\n==============================================================")
    print("             Akamai Entitlement Validator Suite")
    print("==============================================================")
    print(f"Section:      {section}")
    print(f"Access Group: {access_group}")
    print(f"FQDN:         {fqdn}")
    print(f"Debug Mode:   {'ON' if debug else 'OFF'}\n")

    if section not in REGION_SETTINGS:
        print(f"[ERROR] Invalid section '{section}'. Check REGION_SETTINGS.")
        sys.exit(1)

    region = REGION_SETTINGS[section]
    session, base_url = setup_session(section)

    cps = check_cps(session, base_url, fqdn, region["contract_id"], debug)
    appsec = check_appsec(session, base_url, fqdn, region["contract_id"], region["group_id"], access_group, debug)
    papi = check_papi(session, base_url, fqdn, access_group, debug)

    authorized = any([cps["found"], appsec["found"], papi["found"]])
    has_partial = any([cps["partial"], appsec["partial"], papi["partial"]])

    validated_by = []
    if cps["found"]:
        validated_by.append("CPS")
    elif cps["partial"]:
        validated_by.append("CPS (partial)")
    if appsec["found"]:
        validated_by.append("AppSec")
    elif appsec["partial"]:
        validated_by.append("AppSec (partial)")
    if papi["found"]:
        validated_by.append("PAPI")
    elif papi["partial"]:
        validated_by.append("PAPI (partial)")

    summary = {
        "section": section,
        "access_group": access_group,
        "fqdn": fqdn,
        "cps": cps,
        "appsec": appsec,
        "papi": papi,
        "validated_by": validated_by,
        "authorized": authorized
    }

    os.makedirs("output", exist_ok=True)
    summary_file = f"output/entitlement_summary_{sanitize_filename(fqdn)}.json"
    write_json(summary, summary_file)

    print("\n--------------------------------------------------------------")
    if authorized:
        print("[SUMMARY] Validation Result: AUTHORIZED")
    elif has_partial:
        print("[SUMMARY] Validation Result: UNAUTHORIZED (PARTIAL MATCH DETECTED)")
    else:
        print("[SUMMARY] Validation Result: UNAUTHORIZED")

    print(f"[SUMMARY] Validated by: {', '.join(validated_by) if validated_by else 'None'}")
    print("--------------------------------------------------------------\n")
    print(f"[INFO] Summary written to {summary_file}\n")


if __name__ == "__main__":
    main()
