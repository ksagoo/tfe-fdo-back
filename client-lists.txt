# Special handling for Reputation Allowlist naming convention
if original_name.startswith("Reputation Allowlist"):
    try:
        # Inject access group inside the parentheses
        base, paren = original_name.split("(", 1)
        paren = paren.replace("Security Policy Template", "").strip().rstrip(")")
        new_name = f"{base.strip()} ({paren}{access_group})"
    except Exception:
        # fallback if parsing fails
        new_name = f"{original_name} ({access_group})"
else:
    # Standard pattern: strip out 'Security Policy Template' and prepend access group
    suffix = original_name.replace("Security Policy Template", "").strip()
    new_name = f"SC-{access_group} {suffix}"



def activate_client_list(session, base_url, list_id, network="STAGING", comments=None, email=None):
    url = f"{base_url}/client-list/v1/lists/{list_id}/environments/{network}/activate"
    payload = {
        "action": "ACTIVATE",
        "network": network
    }
    if comments:
        payload["comments"] = comments
    if email:
        payload["notificationRecipients"] = [email]

    try:
        resp = session.post(url, json=payload)
        resp.raise_for_status()
        print(f"[INFO] Activation requested for list {list_id} in {network}")
        return True
    except Exception as e:
        print(f"[ERROR] Activation failed for list {list_id}: {e}")
        return False

def wait_for_activation(session, base_url, list_id, timeout=600, interval=20):
    url = f"{base_url}/client-list/v1/lists/{list_id}/environments/STAGING/status"
    headers = {"accept": "application/json"}

    start = time.time()
    while time.time() - start < timeout:
        response = session.get(url, headers=headers)
        if response.status_code == 200:
            status = response.json().get("activationStatus", "")
            print(f"[WAIT] List {list_id} activation status: {status}")
            if status == "ACTIVE":
                print(f"[SUCCESS] List {list_id} is now ACTIVE.")
                return True
        else:
            print(f"[ERROR] Failed to get status for list {list_id}: {response.text}")
        
        time.sleep(interval)

    print(f"[TIMEOUT] Activation did not complete within {timeout} seconds for list {list_id}.")
    return False


                 # Trigger STAGING activation
                activated_staging = activate_client_list(
                    session=session,
                    base_url=base_url,
                    list_id=created_id,
                    network="STAGING",
                    comments=f"Auto-activation for {new_name}"
                )

                # Only wait for specific lists
                if activated_staging and "Rate Controls Bypass List" in new_name:
                    wait_for_activation(session, base_url, created_id)

                # Optional: Activate in PRODUCTION
                if activated_staging and activate_in_production:
                    activate_client_list(
                        session=session,
                        base_url=base_url,
                        list_id=created_id,
                        network="PRODUCTION",
                        comments=f"Auto-activation to PROD for {new_name}"
                    )


