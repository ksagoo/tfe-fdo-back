import requests
import argparse
import configparser
import os
from akamai.edgegrid import EdgeGridAuth

def rename_client_list(session, base_url, list_id, new_name):
    patch_url = f"{base_url}/client-list/v1/lists/{list_id}"
    headers = {"accept": "application/json", "content-type": "application/json"}
    try:
        resp = session.patch(patch_url, json={"name": new_name}, headers=headers)
        resp.raise_for_status()
        print(f"[RENAMED] {list_id} → '{new_name}'")
        return True
    except Exception as e:
        print(f"[ERROR] Failed to rename {list_id} → '{new_name}': {e}")
        return False

def delete_client_lists(session, base_url, access_group, debug=False, purge_deprecated=False):
    prefix = f"SC-{access_group}".lower()
    url = f"{base_url}/client-list/v1/lists?includeDeprecated=true&includeNetworkLists=true"

    try:
        resp = session.get(url)
        resp.raise_for_status()
        client_lists = resp.json().get("content", [])
    except Exception as e:
        print(f"[ERROR] Failed to fetch client lists: {e}")
        return

    for cl in client_lists:
        name = cl.get("name", "")
        norm_name = name.lower()
        list_id = cl.get("listId")
        status = cl.get("status", "").upper()
        deprecated = cl.get("deprecated", False)

        if not norm_name.startswith(prefix):
            continue

        if debug:
            print(f"[DEBUG] {name} (ID: {list_id}) — Status: {status or 'UNKNOWN'}, Deprecated: {deprecated}")
            continue

        # Handle ACTIVE lists by renaming
        if status == "ACTIVE":
            new_name = f"ToBeDeleted-{name}"
            rename_client_list(session, base_url, list_id, new_name)
            continue

        # Handle deprecated lists
        if deprecated:
            if purge_deprecated:
                try:
                    del_url = f"{base_url}/client-list/v1/lists/{list_id}"
                    del_resp = session.delete(del_url)
                    if del_resp.status_code == 204:
                        print(f"[PURGED] Deprecated list {name} (ID: {list_id})")
                    else:
                        print(f"[ERROR] Failed to purge {name} — Status: {del_resp.status_code}, Body: {del_resp.text}")
                except Exception as e:
                    print(f"[ERROR] Exception purging {name}: {e}")
            else:
                print(f"[SKIP] {name} (ID: {list_id}) is deprecated. Use --purge-deprecated to force deletion.")
            continue

        # Delete inactive lists
        try:
            del_url = f"{base_url}/client-list/v1/lists/{list_id}"
            del_resp = session.delete(del_url)
            if del_resp.status_code == 204:
                print(f"[DELETED] {name} (ID: {list_id}) — Status: {status or 'UNKNOWN'}")
            else:
                print(f"[ERROR] Failed to delete {name} — Status: {del_resp.status_code}, Body: {del_resp.text}")
        except Exception as e:
            print(f"[ERROR] Exception deleting {name}: {e}")

def main():
    parser = argparse.ArgumentParser(description="Delete or rename SC-{access_group} client lists")
    parser.add_argument("--access-group", required=True, help="Access group prefix (e.g. XYZ)")
    parser.add_argument("--edgerc", default="~/.edgerc", help="Path to .edgerc file")
    parser.add_argument("--section", default="default", help="Section name in .edgerc (e.g. DEV)")
    parser.add_argument("--debug", action="store_true", help="Only display lists and their status without deleting or renaming")
    parser.add_argument("--purge-deprecated", action="store_true", help="Also delete lists that are already deprecated")

    args = parser.parse_args()

    config = configparser.ConfigParser()
    config.read(os.path.expanduser(args.edgerc))

    if args.section not in config:
        print(f"[ERROR] Section '{args.section}' not found in {args.edgerc}")
        return

    section_config = config[args.section]
    base_url = f"https://{section_config['host']}"

    session = requests.Session()
    session.auth = EdgeGridAuth(
        client_token=section_config["client_token"],
        client_secret=section_config["client_secret"],
        access_token=section_config["access_token"]
    )

    delete_client_lists(session, base_url, args.access_group,
                        debug=args.debug,
                        purge_deprecated=args.purge_deprecated)

if __name__ == "__main__":
    main()



python delete_bypass_list.py \
  --access-group XYZ \
  --section DEV \
  --edgerc ~/.edgerc \
  --debug






# Client List Activations
    parser.add_argument("--wait-for-all-client-list-activations", action="store_true", default=False, help="If set, waits for all cloned client lists to become ACTIVE before continuing")
    parser.add_argument("--activate-client-lists-in-production", action="store_true", default=False, help="If set, activates cloned client lists in Production after successful Staging activation")

def activate_client_list(session, base_url, list_id, network="STAGING"):
    """
    Triggers activation of a client list in the specified network (STAGING or PRODUCTION).
    """
    url = urljoin(base_url, f"/client-list/v1/lists/{list_id}/activate")
    headers = {"accept": "application/json", "content-type": "application/json"}

    try:
        response = session.put(url, json={"network": network}, headers=headers)
        response.raise_for_status()
        print(f"[INFO] Activation triggered for client list {list_id} on {network}")
        return True
    except Exception as e:
        print(f"[ERROR] Failed to activate client list {list_id} on {network}: {e}")
        return False

def wait_for_client_list_activation(session, base_url, list_id, timeout=600, interval=15):
    """
    Polls the client list status until it becomes ACTIVE, or times out.
    """
    status_url = urljoin(base_url, f"/client-list/v1/lists/{list_id}")
    headers = {"accept": "application/json"}

    start = time.time()
    while time.time() - start < timeout:
        try:
            response = session.get(status_url, headers=headers)
            response.raise_for_status()
            status = response.json().get("status", "").upper()
            if status == "ACTIVE":
                print(f"[INFO] Client list {list_id} is now ACTIVE")
                return True
            else:
                print(f"[WAIT] Client list {list_id} status: {status} — retrying in {interval}s")
        except Exception as e:
            print(f"[WARN] Failed to fetch status for client list {list_id}: {e}")
        time.sleep(interval)

    print(f"[ERROR] Timeout waiting for client list {list_id} to become ACTIVE")
    return False

def should_wait_for_activation(name, wait_for_all=False):
    """
    Determines whether to wait for activation based on name or CLI override.
    """
    return wait_for_all or "rate controls bypass list" in name.lower()

def run_all_reassignments(base_url, session, config_id, version, old_policy_id, new_policy_id, fqdn_list, isProd, section, access_group, wait_for_all_client_list_activations=False, activate_client_lists_in_production=False, print_summary=True):

    results = {}
    results["clone_client_lists"] = clone_and_rename_client_lists(session, base_url, config_id, version, access_group, section=None, dry_run=False, wait_for_all=wait_for_all_client_list_activations, activate_in_production=activate_client_lists_in_production)
 

Main()
    # Reassignment of policies/client lists
    results = run_all_reassignments(
        base_url=base_url,
        session=session,
        config_id=config_id,
        version=args.version_to_clone,
        old_policy_id=template_policy_id,
        new_policy_id=policy_id,
        fqdn_list=fqdn_list,
        isProd=args.isProd,
        section=args.section,
        access_group=args.access_group,
        wait_for_all_client_list_activations=args.wait_for_all_client_list_activations,
        activate_client_lists_in_production=args.activate_client_lists_in_production
    )

def clone_and_rename_client_lists(session, base_url, config_id, version, access_group, section, dry_run=True, wait_for_all=False, activate_in_production=False):
    summary = {
        "processed": 0,
        "successful": 0,
        "failed": 0,
        "skipped_existing": [],
        "results": []
    }

    def normalize(name):
        return name.strip().lower()

    def should_wait_for_activation(name):
        return wait_for_all or "rate controls bypass list" in name.lower()

    try:
        url = f"{base_url}/client-list/v1/lists?includeDeprecated=true&includeNetworkLists=true"
        if section:
            url += f"&section={section}"

        resp = session.get(url)
        resp.raise_for_status()
        client_lists = resp.json().get("content", [])
    except Exception as e:
        print(f"[ERROR]: Failed to fetch client lists: {e}")
        return summary

    for cl in client_lists:
        original_name = cl.get("name", "")
        if "Security Policy Template" not in original_name:
            continue
        if original_name.startswith("SC-"):
            continue
        if "ASN Block List" in original_name:
            print(f"[INFO] Skipping ASN Block List: {original_name}")
            continue

        suffix = original_name.replace("Security Policy Template", "").strip()
        new_name = f"SC-{access_group} {suffix}"
        norm_new_name = normalize(new_name)

        matching = [x for x in client_lists if normalize(x.get("name", "")) == norm_new_name]
        still_in_use = any(not m.get("deprecated", False) for m in matching)

        if still_in_use:
            summary["skipped_existing"].append(new_name)
            continue

        payload = {
            "name": new_name,
            "type": cl.get("type"),
            "listType": cl.get("listType"),
            "description": f"Cloned from template list '{original_name}'",
            "tags": [],
            "cloneFromList": {"listId": cl.get("listId")}
        }

        if dry_run:
            summary["successful"] += 1
            summary["results"].append({
                "status": "dry-run",
                "source": original_name,
                "target": new_name
            })
        else:
            clone_url = f"{base_url}/client-list/v1/lists"
            if section:
                clone_url += f"?section={section}"

            try:
                response = session.post(clone_url, json=payload)
                response.raise_for_status()
                created_id = response.json().get("listId")
                print(f"[SUCCESS] Cloned: '{original_name}' => '{new_name}' (listId: {created_id})")

                # Activation logic
                activated_staging = activate_client_list(session, base_url, created_id, network="STAGING")

                if activated_staging and should_wait_for_activation(new_name):
                    activated_staging = wait_for_client_list_activation(session, base_url, created_id)

                if activated_staging and activate_in_production:
                    activate_client_list(session, base_url, created_id, network="PRODUCTION")

                status = "cloned+activated" if activated_staging else "activation_failed"
                summary["successful" if activated_staging else "failed"] += 1
                summary["results"].append({
                    "status": status,
                    "source": original_name,
                    "target": new_name,
                    "listId": created_id
                })

            except Exception as e:
                print(f"[ERROR]: Failed to clone '{original_name}' to '{new_name}': {e}")
                summary["failed"] += 1
                summary["results"].append({
                    "status": "failed",
                    "source": original_name,
                    "target": new_name,
                    "error": str(e)
                })

        summary["processed"] += 1

    return summary



def clone_and_rename_client_lists(session, base_url, config_id, version, access_group, section,
                                  dry_run=True,
                                  wait_for_all=False,
                                  activate_in_production=False):
    summary = {
        "processed": 0,
        "successful": 0,
        "failed": 0,
        "skipped_existing": [],
        "results": []
    }

    def normalize(name):
        return name.strip().lower()

    def should_wait_for_activation(name):
        return wait_for_all or "rate controls bypass list" in name.lower()

    try:
        url = f"{base_url}/client-list/v1/lists?includeDeprecated=true&includeNetworkLists=true"
        if section:
            url += f"&section={section}"

        resp = session.get(url)
        resp.raise_for_status()
        client_lists = resp.json().get("content", [])
    except Exception as e:
        print(f"[ERROR]: Failed to fetch client lists: {e}")
        return summary

    for cl in client_lists:
        original_name = cl.get("name", "")
        if "Security Policy Template" not in original_name:
            continue
        if original_name.startswith("SC-"):
            continue
        if "ASN Block List" in original_name:
            print(f"[INFO] Skipping ASN Block List: {original_name}")
            continue

        suffix = original_name.replace("Security Policy Template", "").strip()
        new_name = f"SC-{access_group} {suffix}"
        norm_new_name = normalize(new_name)

        matching = [x for x in client_lists if normalize(x.get("name", "")) == norm_new_name]
        still_in_use = any(not m.get("deprecated", False) for m in matching)

        if still_in_use:
            summary["skipped_existing"].append(new_name)
            continue

        payload = {
            "name": new_name,
            "type": cl.get("type"),
            "listType": cl.get("listType"),
            "description": f"Cloned from template list '{original_name}'",
            "tags": [],
            "cloneFromList": {"listId": cl.get("listId")}
        }

        if dry_run:
            summary["successful"] += 1
            summary["results"].append({
                "status": "dry-run",
                "source": original_name,
                "target": new_name
            })
        else:
            clone_url = f"{base_url}/client-list/v1/lists"
            if section:
                clone_url += f"?section={section}"

            try:
                response = session.post(clone_url, json=payload)
                response.raise_for_status()
                created_id = response.json().get("listId")
                print(f"[SUCCESS] Cloned: '{original_name}' => '{new_name}' (listId: {created_id})")

                # Activation logic starts here
                activated_staging = activate_client_list(session, base_url, created_id, network="STAGING")

                if activated_staging and should_wait_for_activation(new_name):
                    activated_staging = wait_for_client_list_activation(session, base_url, created_id)

                if activated_staging and activate_in_production:
                    activate_client_list(session, base_url, created_id, network="PRODUCTION")

                status = "cloned+activated" if activated_staging else "activation_failed"
                summary["successful" if activated_staging else "failed"] += 1
                summary["results"].append({
                    "status": status,
                    "source": original_name,
                    "target": new_name,
                    "listId": created_id
                })

            except Exception as e:
                print(f"[ERROR]: Failed to clone '{original_name}' to '{new_name}': {e}")
                summary["failed"] += 1
                summary["results"].append({
                    "status": "failed",
                    "source": original_name,
                    "target": new_name,
                    "error": str(e)
                })

        summary["processed"] += 1



def get_client_list_status(session, base_url, list_id):
    """
    Fetches and logs the current status of a client list before activation.
    """
    from urllib.parse import urljoin

    url = urljoin(base_url, f"/client-list/v1/lists/{list_id}")
    headers = {"accept": "application/json"}

    try:
        response = session.get(url, headers=headers)
        response.raise_for_status()
        data = response.json()
        print(f"[STATUS] List {list_id} — Status: {data.get('status')}, Deprecated: {data.get('deprecated')}, Name: {data.get('name')}")
        return data
    except Exception as e:
        print(f"[WARN] Could not fetch status for list {list_id}: {e}")
        return {}

def activate_client_list(session, base_url, list_id, network="STAGING"):
    """
    Triggers activation of a client list in the specified network,
    with pre-check logging and detailed error diagnostics.
    """
    from urllib.parse import urljoin

    # Pre-check status
    status_data = get_client_list_status(session, base_url, list_id)
    current_status = status_data.get("status", "UNKNOWN")
    deprecated = status_data.get("deprecated", False)

    if current_status == "ACTIVE":
        print(f"[SKIP] List {list_id} is already ACTIVE — skipping activation.")
        return True
    if deprecated:
        print(f"[SKIP] List {list_id} is deprecated — cannot activate.")
        return False

    # Proceed with activation
    url = urljoin(base_url, f"/client-list/v1/lists/{list_id}/activate")
    headers = {
        "accept": "application/json",
        "content-type": "application/json"
    }

    try:
        response = session.put(url, json={"network": network}, headers=headers)
        response.raise_for_status()
        print(f"[INFO] Activation triggered for client list {list_id} on {network}")
        return True
    except requests.exceptions.HTTPError as e:
        print(f"[ERROR] Activation failed for client list {list_id} on {network}")
        print(f"Status Code: {response.status_code}")
        print(f"Response Body: {response.text}")
        print(f"Request URL: {url}")
        print(f"Payload: {{'network': '{network}'}}")
        return False
    except Exception as e:
        print(f"[ERROR] Unexpected error during activation for list {list_id}: {e}")
        return False



    return summary
-----------------------------------------------------


from urllib.parse import urljoin

def get_client_list_status(session, base_url, list_id):
    url = urljoin(base_url, f"/client-list/v1/lists/{list_id}")
    headers = {"accept": "application/json"}

    try:
        response = session.get(url, headers=headers)
        response.raise_for_status()
        data = response.json()
        print(f"[STATUS] List {list_id} — Status: {data.get('status')}, Deprecated: {data.get('deprecated')}, Name: {data.get('name')}")
        return data
    except Exception as e:
        print(f"[WARN] Could not fetch status for list {list_id}: {e}")
        return {}

def activate_client_list(session, base_url, list_id, network="STAGING"):
    """
    Triggers activation of a client list in the specified network,
    with pre-check logging and detailed error diagnostics.
    """
    status_data = get_client_list_status(session, base_url, list_id)
    current_status = status_data.get("status", "UNKNOWN")
    deprecated = status_data.get("deprecated", False)

    if current_status == "ACTIVE":
        print(f"[SKIP] List {list_id} is already ACTIVE — skipping activation.")
        return True
    if deprecated:
        print(f"[SKIP] List {list_id} is deprecated — cannot activate.")
        return False

    url = urljoin(base_url, f"/client-list/v1/lists/{list_id}/activate")
    headers = {
        "accept": "application/json",
        "content-type": "application/json"
    }

    try:
        response = session.put(url, json={"network": network}, headers=headers)
        response.raise_for_status()
        print(f"[INFO] Activation triggered for client list {list_id} on {network}")
        return True
    except requests.exceptions.HTTPError as e:
        print(f"[ERROR] Activation failed for client list {list_id} on {network}")
        print(f"Status Code: {response.status_code}")
        print(f"Response Body: {response.text}")
        print(f"Request URL: {url}")
        print(f"Payload: {{'network': '{network}'}}")
        return False
    except Exception as e:
        print(f"[ERROR] Unexpected error during activation for list {list_id}: {e}")
        return False

------------------------------------------------------------------

import time
from urllib.parse import urljoin

def get_client_list_status(session, base_url, list_id):
    url = urljoin(base_url, f"/client-list/v1/lists/{list_id}")
    headers = {"accept": "application/json"}

    try:
        response = session.get(url, headers=headers)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        print(f"[WARN] Could not fetch status for list {list_id}: {e}")
        return {}

def activate_client_list(session, base_url, list_id, environment="STAGING", wait=True, timeout=60, interval=5):
    """
    Activates the given client list in the specified environment.
    If wait=True, polls until the list reaches ACTIVE status or timeout.
    """
    activate_url = urljoin(base_url, f"/client-list/v1/lists/{list_id}/environments/{environment}/activate")
    headers = {"accept": "application/json"}

    try:
        resp = session.post(activate_url, headers=headers)
        resp.raise_for_status()
        print(f"[INFO] Activation triggered for list {list_id} in {environment}")
    except requests.exceptions.HTTPError as e:
        print(f"[ERROR] Activation failed — Status: {resp.status_code}, Body: {resp.text}")
        return False
    except Exception as e:
        print(f"[ERROR] Unexpected error during activation: {e}")
        return False

    if not wait:
        return True

    # Wait for activation to complete
    print(f"[WAIT] Polling for list {list_id} to reach ACTIVE status...")
    start_time = time.time()
    while time.time() - start_time < timeout:
        status_data = get_client_list_status(session, base_url, list_id)
        current_status = status_data.get("status", "UNKNOWN")
        if current_status == "ACTIVE":
            print(f"[SUCCESS] List {list_id} is now ACTIVE.")
            return True
        elif current_status == "FAILED":
            print(f"[ERROR] List {list_id} activation failed.")
            return False
        time.sleep(interval)

    print(f"[TIMEOUT] List {list_id} did not reach ACTIVE status within {timeout} seconds.")
    return False
